<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/03/26/test/"/>
    <url>/2023/03/26/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xxp</title>
    <link href="/2023/03/26/xxp/"/>
    <url>/2023/03/26/xxp/</url>
    
    <content type="html"><![CDATA[<p>xxp</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/test.png" alt="test.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/26/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/26/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li><p>通过类里函数可以给私有成员赋值，同时也可以通过函数return 出值</p></li><li><p>特殊的成员函数，主要用于创建对象时初始化对象-&gt;给对象成员赋予初值</p></li><li><p>构造函数的特点</p><ul><li>构造函数的函数名与类名相同</li><li>构造函数没有返回值类型，也没有返回值</li><li>构造函数可以重载</li></ul></li><li><p>没有写构造函数，自己会生成，由于内联函数，牺牲时间换效率</p><ul><li><p>系统给的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Myclass</span>()&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>系统给的构造函数相当于低保</p></li><li><p>构造函数，在创建时系统就会调用，不能通过对象调用构造函数</p></li><li><p>默认给的构造函数，是<code>public</code>类型</p></li><li><p><code>const</code>:改变性质，将变量变成常量</p><ul><li><p>对<code>const</code>修饰的变量在函数创建时进行赋值：</p></li><li><p>是在初始化的时候赋初值，不是在声明的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostram&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">chg</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num2;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num3;<br>    <span class="hljs-built_in">chg</span>();<br>  <span class="hljs-keyword">private</span>:  <br>&#125;;<br><br>chg::<span class="hljs-built_in">chg</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i):<span class="hljs-built_in">num1</span>(n),<span class="hljs-built_in">num2</span>(i),<span class="hljs-built_in">num3</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//括号里面可以是变量也可以是常量</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol><li>一种特殊的函数，作用是在对象的生命周期结束时进行清理，系统可以自动调用析构函数</li><li>函数名与类名一致，在前面加上<code>~</code></li><li>没有返回值，也没有参数，但必须有参数表也就是（）</li><li>有低保，没写的话，系统自动分配</li><li>可以通过外部访问到析构函数</li><li>在类创建时，自动使用一次，构造，和析构（在生命周期结束时，会自动调用析构函数）</li><li>先构造的后析构</li></ol><h2 id="拷贝构造，-函数"><a href="#拷贝构造，-函数" class="headerlink" title="拷贝构造， 函数"></a>拷贝构造， 函数</h2><ol><li><p>先是构造函数，才可能是拷贝构造函数</p></li><li><p>有低保，系统会统一给</p></li><li><p>第一个参数是，该类的对象</p><p>操作实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//构造函数</span><br>    ~<span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//析构函数</span><br>    <span class="hljs-built_in">Myclass</span>(Myclass&amp; obj);<span class="hljs-comment">//拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用时机</p><ul><li><p>使用一个对象给另一个对象进行初始化</p></li><li><p>使用一个对象构造另一个对象</p></li><li><p>函数的参数是类的对象</p></li><li><p>返回值是类</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zjy2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    zjy zjy3;<span class="hljs-comment">//进行无参构造</span><br>    <br>    <span class="hljs-keyword">return</span> zjy3;<span class="hljs-comment">//由于zjy3存在于栈区，所以函数结束会被回收，因此返回值是zjy3的复制体，此时调用了拷贝构造</span><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> chg;<br>     <span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n);<br>     <span class="hljs-built_in">zjy</span>();<br>     ~<span class="hljs-built_in">zjy</span>();<br>     <span class="hljs-built_in">zjy</span>(zjy&amp;obj);<br>&#125;;<br> zjy::<span class="hljs-built_in">zjy</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;无参构造&quot;</span>&lt;&lt;endl;<br>&#125;<br> zjy::<span class="hljs-built_in">zjy</span>(zjy &amp;obj)<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br> zjy::~<span class="hljs-built_in">zjy</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><br> zjy::<span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n)<br>&#123;<br>     chg=<span class="hljs-number">520</span>;<br>     n=chg;<br>     cout&lt;&lt;n&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;带参构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     zjy obj;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-function">zjy <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二个代码运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201151814859.png" alt="image-20221201151814859"></p><ul><li>无参构造：<code>func</code>里面的<code>obj</code></li><li>析构函数：函数调用完会释放内存，这里释放的是第一个obj，所以调用析构函数</li><li>带参构造：43行代码</li><li>无参构造：是因为用了chg来接收</li></ul><p>由于上面结果不一致，重点参考下面的</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201152314605.png" alt="image-20221201152314605"></p><ul><li>无参构造：调用<code>test_func_2()</code>，从主调函数，进入被调函数，创建<code>Monster obj</code>采用的是无参构造</li><li>拷贝构造1号：因为需要函数返回<code>obj</code>,但是函数里面的数据在函数完成时，会被释放，所以采用拷贝构造创建的副本<code>obj</code></li><li>析构（1）：当函数完成时，释放内存，调用析构函数释放原本的<code>obj</code></li><li>析构（2）：由于没有接收<code>obj</code>,所以会在执行完76行释放返回的<code>obj</code>副本</li><li>无参构造：78行调用函数（如上的无参构造）</li><li>拷贝构造1号：如上</li><li>析构（3）：如上，第一个析构</li><li>析构（4）：这里的析构和第二个析构不一样，这里的析构是因为，<code>main</code>完成了，释放<code>monster</code>接收的<code>obj</code></li></ul></li><li><p>问题1：为什么第78行<code>Monster monster=test_func_2()</code>这里没有拷贝构造？</p><ul><li>没有东西去接收复制体时，系统会创建一个临时的对象，再用拷贝构造，将返回的<code>obj</code>，拷贝构造给临时变量</li><li>由于78行，有一个<code>monster</code>接收返回的<code>obj</code>，系统优化，直接复制给<code>monster</code>,所以不会调用拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201154807685.png" alt="image-20221201154807685"></p><ul><li>无参构造：因为这里在<code>return </code>后面创建了一个<code>zjy（匿名对象）</code>，相当于在函数外边创建了一个对象，这里不会采用拷贝构造，所以时无参构造</li><li>析构函数：因为没有接收对象，所以在49行的时候析构掉了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//func();</span><br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201155016536.png" alt="image-20221201155016536"></p><ul><li>无参构造：因为调用<code>test_func_2()</code>，创建了一个匿名对象，采用无参构造（和上面的无参构造一样）</li><li>析构：因为main函数结束，调用析构函数</li></ul></li></ul></li><li><p>对于指针的构造：不能直接将指针指向那个地址，而是，创建一个新的内存用于存放原有的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *q=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        p[i]=i;<span class="hljs-comment">//可以相当于创建了一个数组，对于数组的存储可以用arr[i]=int类型</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        q[i]=p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>浅拷贝和深拷贝</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202094645975.png" alt="image-20221202094645975"></p></li><li><p>如何防止默认拷贝的发生（浅拷贝）？</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202095003679.png" alt="image-20221202095003679"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/26/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"/>
    <url>/2023/03/26/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h1><h2 id="new-amp-amp-delete"><a href="#new-amp-amp-delete" class="headerlink" title="new&amp;&amp;delete"></a>new&amp;&amp;delete</h2><p>1. </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="lambda高级使用"><a href="#lambda高级使用" class="headerlink" title="lambda高级使用"></a>lambda高级使用</h1><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的 this <a href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><ol><li>没有捕获的时候，我们将该lambda变量可以看成函数指针</li><li>有捕获的时候，我们将该lambda表达式堪称仿函数</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>使用<code>function</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; func&#123;[](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;&#125;;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>使用<code>bind</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>([](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/26/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/"/>
    <url>/2023/03/26/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="右值和左值"><a href="#右值和左值" class="headerlink" title="右值和左值"></a>右值和左值</h1><h2 id="右值左值的区分"><a href="#右值左值的区分" class="headerlink" title="右值左值的区分"></a>右值左值的区分</h2><ol><li><p>能取地址的是左值，不能取地址的是右值</p></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//左值</span><br>    <span class="hljs-type">int</span> lvalue=<span class="hljs-number">244</span>;<br>    <span class="hljs-comment">//左值引用</span><br>    <span class="hljs-type">int</span> &amp;lvalueCite=lvalue;<br>    <span class="hljs-comment">//右值</span><br>    <span class="hljs-comment">//右值引用</span><br>    <span class="hljs-type">int</span> &amp;&amp;rvalueCite=<span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用右值引用延长生命周期</p></li></ol><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><ol><li><p>作用： 复用其他对象的资源（堆内存）</p></li><li><p>实现浅拷贝 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参构造</span><br>    <span class="hljs-built_in">name1</span>()&#123;<br>        mPtr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-built_in">name1</span>(<span class="hljs-type">const</span> name1 &amp;tem)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mPtr=tem.mPtr;<br>    &#125;<br>    <span class="hljs-comment">//移动构造</span><br>    <span class="hljs-built_in">name1</span>(name1&amp;&amp; tem):<span class="hljs-built_in">mPtr</span>(tem.mPtr)<br>    &#123;<br>        tem.mPtr=<span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> * mPtr;<br>&#125;;<br><br><span class="hljs-function">name1 <span class="hljs-title">getObj</span><span class="hljs-params">()</span></span>&#123;<br>    name1 name11;<br>    *name11.mPtr=<span class="hljs-number">2</span>;<br>    std::cout&lt;&lt;name11.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> name11;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//要求右侧是个临时对象，才会调用移动拷贝构造函数</span><br>    <span class="hljs-comment">//如果没有移动拷贝构造函数，就会调用拷贝构造函数</span><br>    name1 obj=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj.mPtr&lt;&lt;std::endl;<br>    name1&amp;&amp; obj2=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj2.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj2.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用 C++11 提供的 std::forward () 函数，该函数实现的功能称之为完美转发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/26/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <url>/2023/03/26/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h1><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可以按照函数的方法进行调用</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>函数指针</p><blockquote><p>使用<code>using</code>进行定义函数指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>);<br></code></pre></td></tr></table></figure></li><li><p>仿函数</p></li><li><p>可以转换为函数的类对象</p></li><li><p>类成员的函数指针</p></li><li><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*这段代码定义了一个名为name1的类，其中包含两个函数testFunc和testFunc2。testFunc是静态函数，可以通过指针调用，而testFunc2是实例方法，只能通过对象调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此外，代码还定义了一个名为callBack的函数指针类型，它接受一个int类型和一个double类型的参数，并且没有返回值。在类定义中，将operator callBack()定义为转换运算符，它返回testFunc的指针，使得对象也可以像函数一样被调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在main函数中，首先使用obj.operator callBack()将obj对象转换为callBack类型的函数指针，并将其赋值给func。然后，使用&amp;name1::testFunc将testFunc的地址赋值给func2，使用&amp;name1::testFunc2将testFunc2的地址赋值给func3。最后，使用func(1,2)调用testFunc函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">整体来说，此代码演示了如何定义和使用函数指针以及转换运算符的概念。*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">using</span> callBack=<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//callBack是定义的函数指针变量名,这一步是想将类名当作函数使用</span><br>     <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">return</span> testFunc;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">testFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testFunc2</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> callBack2=<span class="hljs-built_in">void</span>(name1::*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br>    name1 obj;<br>    <span class="hljs-comment">//通过转换运算符</span><br>    callBack func=obj.<span class="hljs-keyword">operator</span> <span class="hljs-built_in">callBack</span>();<br>    <span class="hljs-comment">//通过函数指针</span><br>    callBack func2=&amp;name1::testFunc;<br>    <span class="hljs-comment">//callBack2是限定了作用域的函数指针，注意此处必须要有&amp;</span><br>    callBack2 func3=&amp;name1::testFunc2;<br><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="function的使用"><a href="#function的使用" class="headerlink" title="function的使用"></a><code>function</code>的使用</h2><ul><li><p>作用：说是可调用对象当作函数使用</p></li><li><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> a,std::string s);<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;this is func&quot;</span>&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">testStruct</span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is testStruct&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">classFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>          <span class="hljs-keyword">return</span> classFunc;<br>      &#125;<br>  <br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classOperator()&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>      <span class="hljs-comment">//调用function</span><br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          <span class="hljs-built_in">tem</span>(a,s);<br>      &#125;<br>  <span class="hljs-keyword">private</span>:<br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>  &#125;;<br>  <br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-comment">//通过函数包装器调用普通函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f1=func;<br>      <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//伪函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f2=<span class="hljs-built_in">testStruct</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-comment">//类里面的静态函数</span><br>      f2=name1::classFunc;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;tsy&quot;</span>);<br>      <span class="hljs-comment">//通过转换运算符，将类变成了可调用对象</span><br>      name1 name;<br>      f2=name;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<br>  <br>      <span class="hljs-comment">//尝试将function当成参数，调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint</span><span class="hljs-params">(f1)</span></span>;<br>      objPrint.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;jc&quot;</span>);<br>      <span class="hljs-comment">//因为我们的类是可调用的对象所以可以当作function</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint2</span><span class="hljs-params">(name)</span></span>;<br>      objPrint2.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;wr&quot;</span>);<br>      <span class="hljs-comment">//调用类的静态</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint3</span><span class="hljs-params">(name.classFunc)</span></span>;<br>      objPrint3.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;01&quot;</span>);<br>      <span class="hljs-comment">//普通函数调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint4</span><span class="hljs-params">(func)</span></span>;<br>      objPrint4.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;gzx&quot;</span>);<br>      <span class="hljs-comment">//使用伪函数时需要创建对象</span><br>      testStruct testStruct;<br>      <span class="hljs-function">print <span class="hljs-title">objPrint5</span><span class="hljs-params">(testStruct)</span></span>;<br>      objPrint5.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&quot;tcx&quot;</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>## 可调用对象绑定器<br><br>- 作用：<br>  - 将可调用对象绑定成仿函数<br>  - 将多元参数函数绑定成参数为<span class="hljs-number">1</span>，或者（n<span class="hljs-number">-1</span>）的可调用对象<br><br>- 绑定非类的实例：<br><br>  ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot; a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; s = &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,std::placeholders::_2);<br>      <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//注意如果在bind的时候初始化了a和s则在f2(),的括号中添加的参数，没有效果</span><br>      <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(print,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-built_in">f2</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<span class="hljs-comment">//无效果</span><br>      <span class="hljs-keyword">auto</span> f3= std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,<span class="hljs-string">&quot;xxp&quot;</span>);<br>      <span class="hljs-built_in">f3</span>(<span class="hljs-number">3</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>绑定类里的成员函数和成员变量的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>    &#125;<br>    std::string s;<br>&#125;;<br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>    <span class="hljs-comment">//调用function</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        <span class="hljs-built_in">tem</span>(a,s);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//类的成员函数的绑定</span><br>    myClass myclassObj1;<br>    <span class="hljs-keyword">auto</span> f1= std::<span class="hljs-built_in">bind</span>(&amp;myClass::test,&amp;myclassObj1,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-function">print <span class="hljs-title">frintObj1</span><span class="hljs-params">(f1)</span></span>;<br>    frintObj1.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-comment">//绑定类的成员变量</span><br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(&amp;myClass::s,&amp;myclassObj1);<br>    <span class="hljs-built_in">f2</span>()=<span class="hljs-string">&quot;chg&quot;</span>;<span class="hljs-comment">//对类成员赋值</span><br>    std::cout&lt;&lt;<span class="hljs-built_in">f2</span>()&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/26/hello-world/"/>
    <url>/2023/03/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
