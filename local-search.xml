<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go随记</title>
    <link href="/2023/05/08/go/go%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/05/08/go/go%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初始go</title>
    <link href="/2023/05/07/go/%E5%88%9D%E5%A7%8Bgo/"/>
    <url>/2023/05/07/go/%E5%88%9D%E5%A7%8Bgo/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="初始GO"><a href="#初始GO" class="headerlink" title="初始GO"></a>初始GO</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><ol><li><p>一个项目只有一个包<code>main</code></p><p>而且在<code>main</code>里面有一个<code>func main</code></p></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//单行注释</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="简单的程序"><a href="#简单的程序" class="headerlink" title="简单的程序"></a>简单的程序</h3><ol><li><p>小程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;awd&quot;</span><br>fmt.Println(name)<br>name = <span class="hljs-string">&quot;Awdawd&quot;</span><br>fmt.Println(name)<br><span class="hljs-keyword">var</span> Int <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br>fmt.Println(Int, name)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意<code>Println</code>的不一样的用法</li></ul></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li><p>声明变量</p><ul><li><p>定义单个变量</p><p><code>var 变量名 变量的类型</code></p></li><li><p>定义多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> (<br>name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;ad&quot;</span><br>Int  <span class="hljs-type">int</span>    = <span class="hljs-number">9</span><br>)<br>fmt.Println(name)<br>fmt.Println(Int, name)<br><br><span class="hljs-built_in">print</span>(Int)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意var()用法</p></li><li><p>变量的初始值</p><p><code>go</code>语言可以为变量默认值 </p></li><li><p>自动推导</p><p>使用<code>变量名 :=</code>不用加<code>var</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name := <span class="hljs-string">&quot;AWda&quot;</span><br>fmt.Println(name)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>打印类型</p><p><code>%T</code>大写</p></li><li><p>打印地址</p><p><code>%p</code>小写  </p></li><li><p><code>_</code>给这个赋任何值都应该该被抛弃</p></li></ul></li><li><p>变量交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">200</span><br>a, b = b, a<br>fmt.Println(a, b)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>变量的作用域</p><ul><li>如果存在全局变量和局部变量，在函数里面优先使用局部变量</li></ul></li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol><li><p>使用关键字<code>const</code></p></li><li><p>也可以使用自动推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> d, e, c = <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">520</span><br><span class="hljs-keyword">const</span> a <span class="hljs-type">int</span> =<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>iota</code> 常计数器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;haha&quot;</span><br>e<br>f = <span class="hljs-number">100</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br>fmt.Println(a, b, c, d, e, f, g, h, i)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>b&#x3D;1,c&#x3D;2</p><p>e&#x3D;haha会与上面的变量保持相同</p><p>g&#x3D;100同理</p><p>h&#x3D;7恢复计数</p><p>i&#x3D;8</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;haha&quot;</span><br>e<br>f = <span class="hljs-number">100</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br><span class="hljs-keyword">const</span> (<br>j = <span class="hljs-literal">iota</span><br>)<br>fmt.Println(a, b, c, d, e, f, g, h, i, j)<br><br>&#125;<br><br><span class="hljs-comment">//j=0;</span><br><span class="hljs-comment">//是一组新的const</span><br></code></pre></td></tr></table></figure><p><img src="https://go-1317182407.cos.ap-nanjing.myqcloud.com/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/iota.png"></p></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p><code>bool</code></p><p>默认值为<code>false</code></p><p>打印格式是<code>%t</code></p></li><li><p>整形</p><ul><li><p>有符号整型：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 和 <code>int</code>。</p></li><li><p>无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code> 和 <code>uint</code>。分别表示 8 位、16 位、32 位、64 位和字节长度的无符号整数。</p></li></ul></li><li><p>浮点型</p><ul><li><p>当规定输出的小数点时，go会四舍五入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> float <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> float2 <span class="hljs-type">float32</span> = <span class="hljs-number">3.19</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\t%f\n&quot;</span>, float, float2)<br>fmt.Printf(<span class="hljs-string">&quot;%.1f\t%.1f&quot;</span>, float, float2)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">140000</span>        <span class="hljs-number">3</span>.<span class="hljs-number">190000</span><br><span class="hljs-attribute">3</span>.<span class="hljs-number">1</span>     <span class="hljs-number">3</span>.<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>部分类型的别名</p><p><img src="https://go-1317182407.cos.ap-nanjing.myqcloud.com/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E9%83%A8%E5%88%86%E5%88%AB%E5%90%8D.png"></p></li><li><p>string</p><ul><li><p>使用%s打印</p></li><li><p>字符串拼接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;AWDawd&quot;</span><br>fmt.Println(str+<span class="hljs-string">&quot;awd&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>和C一样的转义字符</p></li><li><p>数据类型的转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">3</span><br>b := <span class="hljs-number">3.14</span><br>fmt.Println((<span class="hljs-type">float64</span>(a) + b))<br><span class="hljs-comment">//将a转换为float64</span><br><br><br><br>c:=<span class="hljs-type">float64</span>(<span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(a)))<br><span class="hljs-built_in">println</span>(c)<br></code></pre></td></tr></table></figure><ul><li>整形，浮点型不能转成bool</li></ul></li></ol><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><ol><li>基本的都和C语言一样，下面是不一样的</li><li>自增自减只有<code>i++</code>，<code>i--</code></li></ol><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ol><li>和C语言一样</li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>C语言一样</li></ol><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ol><li><p><code>&amp;</code>两个二进制数对应都为1，才为1</p><p>相当于和</p></li><li><p><code>|</code>只要有1，就为 1 </p><p>相当于或</p></li><li><p>打印二进制（b是二进制的缩写）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%b&quot;</span>, b)<br></code></pre></td></tr></table></figure></li><li><p><code>^</code>不同为<code>1</code>，相同为<code>0</code>  </p></li><li><p><code>&lt;&lt; n</code>左移n位</p></li><li><p><code>&gt;&gt; n</code>右移n位</p></li></ol><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>使用<code>fmt</code>里面的<code>scan</code>等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;input:&quot;</span>)<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br>fmt.Scan(&amp;a, &amp;str, &amp;b)<br><br><span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;+&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a+b:&quot;</span>, a+b)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a-b:&quot;</span>, a-b)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;*&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a*b:&quot;</span>, a*b)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;/&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a/b:&quot;</span>, <span class="hljs-type">float64</span>(a/b))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;input error&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p><code>if-else</code></p><p>注意不加小括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> a == <span class="hljs-number">10</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a==10&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;a=&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switch</code></p><p>默认op为<code>true</code></p><p><code>go</code>的<code>op</code>可以是任何数据类型</p><p><code>switch</code>没有穿透性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> a &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>fmt.Println(<span class="hljs-string">&quot;case 1&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>fmt.Println(<span class="hljs-string">&quot;case 2&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;default&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>fallthrough</code>可以提供穿透性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> str &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;case 1&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;case 2&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;case else&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>配合使用<code>break</code>可以跳出穿透</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-keyword">switch</span> str &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;case 1&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:<br><span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;1&quot;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;case 2&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;case else&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>死循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li><p>求长度<code>len</code></p></li><li><p>字符串其他操作</p><p>遍历查询string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;awd&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(str))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>GO基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言平常笔记</title>
    <link href="/2023/05/07/C/C%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/07/C/C%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%B8%B8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言平常笔记"><a href="#C语言平常笔记" class="headerlink" title="C语言平常笔记"></a>C语言平常笔记</h1><ol><li><p>在在自定义函数中使用sqrt函数，必须将开方数，重定义如（double）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">n_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(x=<span class="hljs-number">2</span>;x&lt;<span class="hljs-built_in">sqrt</span>((<span class="hljs-type">double</span>)x);x++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>==a%x)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is not a prime&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a prime&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入判断的数：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>n_prime(num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getchar的用法：如果单独只用gerchar(),则只取一个字符。把getcahr 放入循环中则可读取输入进去的所有值，包括（‘\n’,’ ‘）,但是scanf,只读取缓冲区中‘\n’之前的，\n是因为键盘使用了回车</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这是一个计算输入数字中字母，数字，空格，和其他字符的代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr;<br><span class="hljs-type">int</span> letters=<span class="hljs-number">0</span>,numbers=<span class="hljs-number">0</span>,spaces=<span class="hljs-number">0</span>,others=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入查找的字符串：&quot;</span>);<span class="hljs-comment">//存放得到的字符串</span><br><span class="hljs-keyword">while</span>((arr=getchar())!=<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-comment">//必须放入循环</span><br>&#123;<br><span class="hljs-keyword">if</span>(arr&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;arr&lt;=<span class="hljs-string">&#x27;z&#x27;</span>||arr&gt;<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;arr&lt;<span class="hljs-string">&#x27;Z&#x27;</span>)<br>&#123;<br>letters++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;arr&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>numbers++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27; &#x27;</span>==arr)<br>&#123;<br>spaces++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>others++;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;letters=%d\nnumber=%d\nspace=%d\nothers=%d\n&quot;</span>,letters,numbers,spaces,others);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>staticu作用：</p><p>3.1 隐藏该语句</p><p>3.2 被static修饰的变量存活时间更长</p><p>3.3 初始化变量为0</p></li><li><p>typedef</p><p>4.1 取别名： typedef 类型 别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//数组起别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">array</span> arr=&#123;<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>&#125;；<span class="hljs-comment">//定义的一维数组</span><br><span class="hljs-built_in">array</span> arr2[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//定义2维数组</span><br><br></code></pre></td></tr></table></figure></li><li><p>指针大小在32位是4，在64位是8</p></li><li><p>输出中间取位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4d&quot;</span>,a);<br><span class="hljs-comment">//结果位0002</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d&quot;</span>,a);<br><span class="hljs-comment">//结果为   2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-4d&quot;</span>,a);<br><span class="hljs-comment">//结果为2    (有3个空格)</span><br></code></pre></td></tr></table></figure></li><li><p>sqrt() 函数：括号里里面，放变量名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">A=b*b<span class="hljs-number">-4</span>*a*c;<br><span class="hljs-built_in">sqrt</span>(b*b<span class="hljs-number">-4</span>*a*c);<br><span class="hljs-comment">//不太行</span><br><span class="hljs-built_in">sqrt</span>(A);<br><span class="hljs-comment">//可以</span><br></code></pre></td></tr></table></figure></li><li><p>double,可以用来表示整数</p></li><li><p>取一个高位数，从头开始取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例如</span><br><br>a=x/<span class="hljs-number">10000</span>;<br>b=x%<span class="hljs-number">1000</span>/<span class="hljs-number">100</span>;<br>c=x%<span class="hljs-number">100</span>/<span class="hljs-number">10</span>;<br>d=x%<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li><li><p>乘法符号不能省略</p></li><li><p>如果想使用除法输出小数，先转化再除法</p></li><li><p>define常量，不用加<code>‘;’</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> count 5</span><br><span class="hljs-comment">//就好了</span><br></code></pre></td></tr></table></figure></li><li><p>局部变量是放在栈区上的，栈区内存的使用习惯是，先使用高地址，再使用低地址</p></li><li><p>size_t:它是为了方便系统之间的移植而定义的，不同的系统上，定义size_t 可能不一样。size_t在32位系统上定义为 unsigned int，也就是32位无符号<a href="https://so.csdn.net/so/search?q=%E6%95%B4%E5%9E%8B&spm=1001.2101.3001.7020">整型</a>。在64位系统上定义为 unsigned long ，也就是64位无符号整形</p></li><li><p>清空外部控制台：<code>system(&quot;cls&quot;);</code>,头文件是：<code>stdlib.h</code>。</p></li><li><p><code>void</code>函数<code>return ;</code></p></li><li><p>对于结构体的引用</p><ul><li>若使用地址使用结构体内的成员，使用<code>-&gt;</code></li><li>若直接通过使用结构体的名字则使用：<code>.</code></li></ul></li><li><p>对于链表的使用，应该将所有元素都初始化</p></li><li><p>使用<code>malloc</code>时，需要判断是否申请内存成功</p></li><li><p>判断存储方式</p><ul><li>大端存储：低位存在高地址</li><li>小端存储：低位存放在低地址</li><li>用共同体判断存储方式</li></ul></li><li><p>枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">sex</span>&#123;</span>man, woman&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">sex</span> <span class="hljs-title">chg</span> =</span> <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>chg = a == <span class="hljs-number">0</span> ? man : woman;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chg=%d&quot;</span>, chg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//如果chg=man,打印0</span><br><span class="hljs-comment">//如果chg=woman,打印1</span><br></code></pre></td></tr></table></figure></li><li><p><code>3.14</code>是double 类型,<code>3.14f</code>是float类型</p></li><li><p>内存释放：只是将使用的部分的内存打上可回收的标记，还是可以修改内存所存的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input n:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">while</span> (i &lt; n)<br>&#123;<br>p[i++] = i;<br>&#125;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p[i++]);<br>&#125;<br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\12414\Desktop\笔记\c\平常\C语言平常笔记.assets\image-20221209152359574.png" alt="image-20221209152359574"></p></li><li><p><code>mollioc calloc realloc</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(n,size);<span class="hljs-comment">//n:有多少个连续的int,size:只指针对应的类型的大小</span><br><span class="hljs-type">int</span>* p1=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span>* p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(p,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//n:可用于改变内存（重新申请）</span><br></code></pre></td></tr></table></figure><p>使用<code>calloc</code>会自动初始化，<code>malloc</code>不会</p><p> 使用<code>realloc</code>有两种情况，小扩容，大扩容，小扩容是在原有的内存基础上扩容，大扩容会改变位置</p><p><img src="C:\Users\12414\Desktop\笔记\c\平常\C语言平常笔记.assets\image-20221209153159341.png" alt="image-20221209153159341"></p></li><li><p>自己的交换函数，不能交换地址，交换地址对应的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span> <span class="hljs-params">( <span class="hljs-type">int</span> *a,  <span class="hljs-type">int</span> *b )</span><br>&#123;<br><span class="hljs-type">int</span> p;<br>p=*a;<br>*a=*b;<br>*b=p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不能再自己的函数里面计算，数组的长度，因为，接受的是首地址</p></li><li><p>可以通过字写的程序计算，数组里面的字符（字符串特别适用，数字注意0）</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/2023/05/06/linux/shell/"/>
    <url>/2023/05/06/linux/shell/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h2 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">方法一  直接运行解释器</span><br>sh hello.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">方法二  使用可执行文件</span><br>chmod +x hello.sh<br>./hello.sh<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>系统变量</p><p>系统变量有$HOME、$PWD、$USER等</p></li><li><p>自定义变量</p><ul><li><p>创建变量</p><p>变量名&#x3D;变量值，等号两侧不能有空格，变量名一般习惯用<strong>大写</strong>。</p></li><li><p>删除变量</p><p><code>unset 变量名</code></p></li><li><p>声明静态变量</p><p><code>readonly +变量名</code></p><p>静态变量不能unset</p></li><li><p>使用变量</p><p><code>$name</code></p></li></ul></li></ol><h3 id="将命令返回值赋给变量重点"><a href="#将命令返回值赋给变量重点" class="headerlink" title="将命令返回值赋给变量重点"></a>将命令返回值赋给变量重点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">A=`ls`<br>A=$(ls)<br></code></pre></td></tr></table></figure><h3 id="shell环境变量"><a href="#shell环境变量" class="headerlink" title="shell环境变量"></a>shell环境变量</h3><ol><li>export 变量名&#x3D;变量值，将 Shell 变量输出为环境变量。</li><li>source 配置文件路径，让修改后的配置信息立即生效。</li><li>echo $变量名，检查环境变量是否生效。</li></ol><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><p><strong>基本语法</strong></p><ul><li>$n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。</li><li>$* ：命令行中所有参数，且把所有参数看成一个整体。</li><li>$@ ：命令行中所有参数，且把每个参数区分对待。</li><li>$# ：所有参数个数。</li></ul><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><strong>基本语法</strong></p><ul><li>$$ ：当前进程的 PID 进程号。</li><li>$! ：后台运行的最后一个进程的 PID 进程号。</li><li>$? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><strong>基本语法</strong></p><ul><li>$((运算式)) 或 $[运算式]</li><li>expr m + n 注意 expr 运算符间要有空格</li><li>expr m - n</li><li>expr *，&#x2F;，% 分别代表乘，除，取余</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><code>[ condition ] </code>注意condition前后都要有空格</p><p>非空返回0，0为 true，否则为 false</p><p><code>if语句</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!bin/bash</span><br>Int1=1;<br>Int2=2;<br>if [ $Int1 == $Int2]<br>then<br>        echo &quot;等&quot;<br>else<br>        echo &quot;不相等&quot;<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">Int3=3;<br><br>if [ $Int3 -lt 0 ]<br>then<br>        echo &quot;&lt;0&quot;<br>elif [ $Int3 -lt 3 ]<br>then<br>        echo &quot;&lt;3&quot;<br>else<br>        echo &quot;&gt;=3&quot;<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意-lt是小于的意思</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-gt是大于的意思</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-ge是大于等于</span><br></code></pre></td></tr></table></figure><p><code>case语句</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!bin/bash</span><br>case $1 in<br>        &quot;1&quot;)<br>                echo &quot;1&quot;<br>                ;;<br>        &quot;2&quot;)<br>                echo &quot;2&quot;<br>                ;;<br>        *)<br>                echo &quot;其他&quot;<br>                ;;<br>esac<br><br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><p><code>for循环</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &quot;$@&quot;<br>do<br>        echo &quot;$i  &quot;;<br>done<br>echo &quot;========&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">结果：</span><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>========<br></code></pre></td></tr></table></figure><p>由此可见，结果是竖着的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &quot;$*&quot;<br>do<br>        echo &quot;$i  &quot;;<br>done<br>echo &quot;========&quot;<br><br>1 2 3 4 5 6 7 8 9<br>========<br></code></pre></td></tr></table></figure><p>结果是横着的</p><p><code>C语言风格的for</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>for ((i=0; i&lt;10; i++))<br>do<br>echo &quot;hahah&quot;<br>done<br></code></pre></td></tr></table></figure><p>使用<code>&#123;&#125;</code>的<code>for</code>循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!bin/bash</span><br><br>SUM=0<br><br>for i in &#123;1..100&#125;<br>do<br>        SUM=$(($SUM+$i))<br>done<br><br>echo $SUM<br></code></pre></td></tr></table></figure><p>使用<code>seq</code>的<code>for</code>循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!bin/bash</span><br><br>SUM=0<br><br>for i in $(seq 1 100)<br>do<br>        SUM=$(($SUM+$i))<br>done<br><br>echo $SUM<br></code></pre></td></tr></table></figure><p><code>while</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">i=0;<br>while [ $i -lt 10 ]<br>do<br>        echo $i<br>        i=$((i+1))<br>done<br><br></code></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><code>read -p &quot;输入一个数字:&quot;NUM</code></p><p><code>read -t &quot;在10秒中输入一个数&quot;NUM</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">标准</span><br>function 函数名()&#123;<br>指令<br>return n<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">简写</span><br>function 函数名 &#123;<br>指令<br>return n<br>&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">简写</span><br>函数名&#123;<br>指令<br>return n<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>程序执行的顺序</strong></p><p>系统别名-&gt;函数-&gt;系统命令-&gt;可执行文件</p><p><strong>其他知识点</strong></p><ol><li><p><code>return </code>是退出函数</p><p>exit 退出文件</p></li></ol><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash test1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">与嗲用可执行文件一样</span><br></code></pre></td></tr></table></figure><p>但是注意，调用函数由于</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看链表是否有环</title>
    <link href="/2023/05/01/newcoder/%E6%9F%A5%E7%9C%8B%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
    <url>/2023/05/01/newcoder/%E6%9F%A5%E7%9C%8B%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tqId=605&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295">判断链表中是否有环_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><ul><li>使用快慢指针，如果快指针与慢指针重合，则说明有环</li></ul></li><li><p>理解</p><p>- </p></li><li><p>问题</p><p>- </p><blockquote></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/01/c++/game.exe%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/01/c++/game.exe%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="game-exe的使用方法"><a href="#game-exe的使用方法" class="headerlink" title="game.exe的使用方法"></a>game.exe的使用方法</h1><ol><li><p>使用<code>win+r</code>,调出<code>cmd</code></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230501125706379.png" alt="image-20230501125706379"></p><p>点击确定</p></li><li><p>使用<code>CHCP 65001</code>设置<code>UTF-8</code></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230501125822766.png" alt="image-20230501125822766"></p></li><li><p>直接拖进cmd，将game.exe运行</p></li><li><p>注意不要改变游戏区域的大小</p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230501130058613.png" alt="image-20230501130058613"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用linux</title>
    <link href="/2023/04/30/linux/%E4%BD%BF%E7%94%A8linux/"/>
    <url>/2023/04/30/linux/%E4%BD%BF%E7%94%A8linux/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="使用Linux"><a href="#使用Linux" class="headerlink" title="使用Linux"></a>使用Linux</h1><h2 id="各类小技巧"><a href="#各类小技巧" class="headerlink" title="各类小技巧"></a>各类小技巧</h2><ol><li><p>强制停止</p><ul><li><p><code>Ctrl+c</code> 退出程序</p></li><li><p><code>Ctrl+c</code> 退出登出或退出</p></li></ul><p>  不能用于退出vi&#x2F;vim</p></li><li><p>历史命令查找</p><ul><li><p><code>history</code> </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">history</span> | <span class="hljs-keyword">grep</span> ch<br></code></pre></td></tr></table></figure><p>过滤使用的指令里带有<code>ch</code>的命令</p></li><li><p><code>Ctrl+r</code> 输入内容匹配</p><p>如果搜索到的命令是可执行的，则直接回车</p><p>键盘的左右键，可以得到此命令</p></li><li><p><code>!</code> 匹配最近的</p><p>比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>匹配最近的p开头的命令</p></li></ul></li><li><p>光标移动</p><ul><li><code>Ctrl + a</code> 跳到命令开头</li><li><code>Ctrl + e</code> 跳到命令结尾</li><li><code>Ctrl + 左键</code> 向左跳过一个单词</li><li><code>Ctrl + 右键</code> 向右跳过一个单词</li></ul></li><li><p>清屏</p><ul><li><code>Ctrl + r</code>&#x2F;<code>clean</code></li></ul></li></ol><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="CentOs"><a href="#CentOs" class="headerlink" title="CentOs"></a><code>CentOs</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/Linux/yum.png"></p><p><code>yum</code>指令 </p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a><code>Ubuntu</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/Linux/apt.png"></p><h2 id="控制软件的启动和关闭"><a href="#控制软件的启动和关闭" class="headerlink" title="控制软件的启动和关闭"></a>控制软件的启动和关闭</h2><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/Linux/systemctl.png"></p><p>控制系统的内置服务</p><p>手动添加第三方软件到<code>systemctl</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在系统中创建软连接，可以直接将文件、文件夹放到其他位置，类似于win的快捷方式</p><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ol><li><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ln</span> -s 参数<span class="hljs-number">1</span> 参数<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>参数1：被链接的文件或者文件夹</p><p>参数2：要链接的目的地</p></li></ol><h2 id="时间和时区"><a href="#时间和时区" class="headerlink" title="时间和时区"></a>时间和时区</h2><ol><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">data [-d] [+格式化字符串]<br></code></pre></td></tr></table></figure><ul><li><p><code>-d</code> 按照给定的字符串显示日期，一般用于日期的计算</p></li><li><p>格式化字符串</p><p>通过特定的字符串标记，用来控制显示 的日期</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/Linux/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F.png"></p><p><img src="C:\Users\12414\Desktop\hexo\source_posts\linux\使用linux.assets\image-20230501234712440.png"></p></li></ul></li></ol><h2 id="IP地址、主机名"><a href="#IP地址、主机名" class="headerlink" title="IP地址、主机名"></a>IP地址、主机名</h2><ol><li>IP和主机名</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表中的节点每k个一组翻转</title>
    <link href="/2023/04/26/newcoder/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC/"/>
    <url>/2023/04/26/newcoder/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/intelligent&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/intelligent?questionJobId=10&tagId=21000">链表中的节点每k个一组翻转_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param head ListNode类</span><br><span class="hljs-comment">     * @param k int整型</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> headTem = <span class="hljs-keyword">new</span> ListNode&#123;<span class="hljs-number">0</span>&#125;;<br>        headTem-&gt;next = head;<br><br>        std::vector&lt;ListNode*&gt; vector;<br>        <span class="hljs-keyword">auto</span> moveNode = head;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            vector.<span class="hljs-built_in">push_back</span>(moveNode);<br>            moveNode = moveNode-&gt;next;<br>            i++;<br>            vector.<span class="hljs-built_in">back</span>()-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) &#123;<br>                std::<span class="hljs-built_in">reverse</span>(vector.<span class="hljs-built_in">begin</span>() + i - k, vector.<span class="hljs-built_in">begin</span>() + i );<br>            &#125;<br><br>        &#125;<br>        moveNode = headTem;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : vector) &#123;<br>            moveNode-&gt;next = item;<br>            moveNode = item;<br>        &#125;<br>        <span class="hljs-keyword">return</span> headTem-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><ul><li>使用<code>reverse</code>函数对<code>vector</code>进行翻转</li></ul></li><li><p>理解</p><p>- </p></li><li><p>问题</p><ul><li><p>为什么要使用<code>vector</code></p><blockquote><p>因为使用链表的操作太过于复杂</p></blockquote></li><li><p>33行是为什么？</p><blockquote><p>使得调试的时候方便看结点，这样就只会显示一个节点</p></blockquote></li></ul></li><li><p>注意</p><ul><li><p>迭代器的用法，特别是begin()，和end()</p></li><li><p><code>reverse(迭代器1，迭代器2)</code>函数的用法</p><blockquote><p>将2之前的反转，并不会包括2</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户和权限</title>
    <link href="/2023/04/26/linux/%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/"/>
    <url>/2023/04/26/linux/%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h1><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><ol><li><p><code>su</code></p><p>切换用户</p><ul><li><p><code>su - -root</code></p><p>注意中间的<code>-</code> 前后都有空格</p></li></ul></li><li><p><code>exit</code></p><p>退出返回上一个用户</p></li><li><p><code>sudo</code></p><p>普通用户获得普通的权限，但不是所有的用户都有<code>sudo</code>认证，需要认证</p></li></ol><h2 id="用户用户组"><a href="#用户用户组" class="headerlink" title="用户用户组"></a>用户用户组</h2><ol><li>一个用户可以在多个用户组</li></ol><h3 id="用户组的管理"><a href="#用户组的管理" class="headerlink" title="用户组的管理"></a>用户组的管理</h3><ol><li><p>用户组的创建</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">groupadd` 用户组名<br></code></pre></td></tr></table></figure></li><li><p>删除用户组</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupdel</span> 用户组名<br></code></pre></td></tr></table></figure></li></ol><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86.png"></p><ul><li><p><code>getent passwd</code></p><p>查看当前系统中有哪些用户</p></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7/%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90.png"></p><ol><li><p><code>chmod</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> -R 权限 文件或者文件夹<br></code></pre></td></tr></table></figure><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7/chmod.png"></p><p>使用<code>-R</code>代表将文件夹里面的也一并修改</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">751</span> 文件或者文件夹<br></code></pre></td></tr></table></figure><ul><li>7代表给用户的</li><li>5代表给用户组的权利</li><li>1代表给其他的权利</li></ul><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7/%E6%95%B0%E5%AD%97%E6%9D%83%E9%99%90.png"></p></li><li><p><code>chown</code>修改所属的用户、用户组</p><p>该命令只针对于<code>root</code>用户</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7/chown.png"></p><ul><li><p>只修改用户</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">chown <span class="hljs-keyword">user</span> <span class="hljs-title">test</span>.txt<br></code></pre></td></tr></table></figure></li><li><p>只修改用户组</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">chown :<span class="hljs-keyword">group</span> <span class="hljs-title">test</span>.txt<br></code></pre></td></tr></table></figure></li><li><p>两个都修改</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">chown user:<span class="hljs-keyword">group</span> <span class="hljs-title">test</span>.txt<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从中序与后序遍历序列构造二叉树</title>
    <link href="/2023/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/ab8dde7f01f3440fbbb7993d2411a46b?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">从中序与后序遍历序列构造二叉树_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct TreeNode *left;</span><br><span class="hljs-comment"> *  struct TreeNode *right;</span><br><span class="hljs-comment"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> indexMap;<span class="hljs-comment">//根节点的在后序遍历的下标</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; unorderedMap;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param inorder int整型vector 中序遍历序列</span><br><span class="hljs-comment">     * @param postorder int整型vector 后序遍历序列</span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> leftSub, <span class="hljs-type">int</span> rightSub)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (leftSub &gt; rightSub) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[indexMap]);<br>        <span class="hljs-keyword">auto</span> index = unorderedMap[postorder[indexMap]];<br>        indexMap--;<br>        root-&gt;right = <span class="hljs-built_in">build</span>(inorder, postorder, index + <span class="hljs-number">1</span>, rightSub);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(inorder, postorder, leftSub, index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        indexMap = postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sub = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : inorder) &#123;<br>            unorderedMap[item] = sub++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(inorder, postorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><ul><li><p>后序遍历的最后一个元素是<code>root</code>的<code>val</code></p></li><li><p>采取递归的方法，创建结点</p></li><li><p>注意创建的顺序，应该是先是右的再左的</p><p>因为创建的顺序应该是是从最小树开始创建</p></li></ul></li><li><p>理解</p><ul><li><pre><code class="c++">        for (const auto&amp; item : inorder) &#123;            unorderedMap[item] = sub++;        &#125;</code></pre><p>将&lt;元素，下标&gt;的方式存放数据</p><p>这样操作的原因是：方便的通过后序遍历找到<code>root</code>，再通过<code>map</code>查找数据</p></li><li><p>把每一个都当成一个<code>root</code></p></li></ul></li><li><p>问题</p><ul><li><p><code>leftSub &gt; rightSub</code></p><blockquote><p>当左节点的下标大于右节点的下标就表示这棵树是NULL</p><p>也就是说子串是无的</p></blockquote></li><li><p>为什么要先创建右节点</p><blockquote><p>因为我们的后序遍历顺序是:左-右-根</p><p>所以当我们把<code>root</code>取出剩下的应该就是右节点</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表达式求值</title>
    <link href="/2023/04/21/newcoder/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/04/21/newcoder/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">表达式求值_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * 返回表达式的值</span><br><span class="hljs-comment">     * @param s string字符串 待计算的表达式</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(string str,<span class="hljs-type">int</span> sub)</span></span>&#123;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> op=<span class="hljs-string">&#x27;+&#x27;</span>;<span class="hljs-comment">//默认前面的数是+</span><br>        <span class="hljs-type">int</span> i=sub;<span class="hljs-comment">//设置值下表，用于递归</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//和</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; vector;<span class="hljs-comment">//通过vector,返回sum，和下标</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<span class="hljs-comment">//栈区存放数字</span><br>        <span class="hljs-keyword">for</span>(;i&lt;str.<span class="hljs-built_in">size</span>();++i) &#123;<br>            <span class="hljs-comment">//下面的是，用于计算数字比如100,这样的多位数字</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(str[i])) &#123;<br>                num = num * <span class="hljs-number">10</span> + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (i != str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">//递归标志</span><br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                vector = <span class="hljs-built_in">func</span>(str, ++i);<br>                <span class="hljs-comment">//vector[0]，用于存放sum</span><br>                <span class="hljs-comment">//vector[1],用于存放下标</span><br>                num=vector[<span class="hljs-number">0</span>];<br>                i=vector[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(i!=str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">switch</span> (op) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack.<span class="hljs-built_in">push</span>(num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack.<span class="hljs-built_in">push</span>(-num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    num *= stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    stack.<span class="hljs-built_in">push</span>(num);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            num=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//递归结束的标志</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                op=str[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//下面是求和的过程</span><br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            sum+=stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ::vector&lt;<span class="hljs-type">int</span>&gt;&#123;sum,i&#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here     </span><br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(s,<span class="hljs-number">0</span>).<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC.gif"></p><p>采取栈加递归的方式</p><p>如果是数字，根据前面的符号放进入栈区，如果是’+’，则直接放进去，如果是’-‘，就放入相反数，如果是’*’，就从栈区取出一个元素，然后计算。</p><p>如果遇到<code>(</code>，当作递归的标志，进行递归（注意要设置下标）。</p><p>如果像<code>100</code>，这样的多位数字，就应该进行数字的录入</p></li><li><p>理解</p><ul><li>采用<code>func()</code>,简化运算，方便调用</li><li>使用<code>vector</code>，可以采用返回两个元素（sum，下标）</li></ul></li><li><p>问题</p><p>- </p><blockquote></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>main函数传参</title>
    <link href="/2023/04/20/C/main%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"/>
    <url>/2023/04/20/C/main%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="main函数传参"><a href="#main函数传参" class="headerlink" title="main函数传参"></a>main函数传参</h1><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><ol><li>参数个数</li><li>首个参数到底是谁</li><li>带空格的参数</li></ol><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><ol><li><pre><code class="c">int main(int argc,char* argv[])&#123;    return 0;&#125;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-number">2.</span> 第一个参数的意思是：参数的个数<br><br><span class="hljs-number">3.</span> 第二个参数的意思是：存放的参数，而且至少有一个，如果打印的话，结果是该项目的名称<br><br>   实例：<br><br>   ```<span class="hljs-function">c</span><br><span class="hljs-function">   <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function">   </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++)<br>   &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, argv[i]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>运行结果：![image-20221225201855246](C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221225201855246.png)</code></pre></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始指针</title>
    <link href="/2023/04/20/C/%E5%88%9D%E5%A7%8B%E6%8C%87%E9%92%88/"/>
    <url>/2023/04/20/C/%E5%88%9D%E5%A7%8B%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="初始指针"><a href="#初始指针" class="headerlink" title="初始指针"></a>初始指针</h1><h2 id="what-is-指针"><a href="#what-is-指针" class="headerlink" title="what is 指针"></a>what is 指针</h2><ol><li>指针描述了数据在内存中的位置</li><li>指针也就是内存地址</li><li>一个内存单元为一个字节</li><li>指针在32位平台是4个字节，在64位平台是8个字节</li></ol><h2 id="指针的意义"><a href="#指针的意义" class="headerlink" title="指针的意义"></a>指针的意义</h2><ol><li><p>指针的类型决定了，指针解引用的权限有多大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例如</span><br><span class="hljs-type">char</span>*<span class="hljs-comment">//可以指1个字节</span><br><span class="hljs-type">int</span>*<span class="hljs-comment">//可以指4个字节</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a>取地址运算</h2><ol><li><p>&amp;：取地址后的，需要用%p输出，如果用%x（16进制），则会警告</p><ul><li><p>只有明确的变量才能取他的地址</p></li><li><p>本地变量存放在堆栈的地方，内存地址由高到底</p></li></ul></li><li><p>指针变量：用于记录地址的变量 </p></li><li><p>int* p,q只将p设成指针，q只是普通变量</p></li><li><p>指针用于，函数的传址，当函数需要返回多个值时，需要用指针带回</p></li></ol><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><ol><li><p>传入函数的数组，函数接收到的是函数第一个数的地址,函数中设置接受的数组时，就是设置了指针<code>数组变量是特殊的指针</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">minmax</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span><span class="hljs-comment">//这里</span><br>&#123;<br>    arr[<span class="hljs-number">0</span>]=<span class="hljs-number">11</span>;<br>&#125;<br><span class="hljs-comment">//上面的函数还可以设置成</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minmax2</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span><br>&#123;<br>    a[<span class="hljs-number">0</span>]=<span class="hljs-number">11</span>;<span class="hljs-comment">//与上面结果一致</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[]=&#123;&#125;;<br>    minmax(arr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,arr[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <span class="hljs-comment">//结果是11，因为设置函数时，用了int arr实际上是设置了指针   </span><br></code></pre></td></tr></table></figure><ul><li>因此在使用数组作为函数变量时，有两种方法：<ul><li>int arr</li><li>int* a</li></ul></li><li>arr的地址也就是arr[0]的地址</li></ul></li><li><p>数组变量是<code>const</code>（限定的变量不允许被改变）的指针，所以不能被赋值，数组之间也不能互相赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例子：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> b[]=&#123;&#125;;<br>    a=b;<span class="hljs-comment">//不能这样写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与<code>const</code></h2><ol><li><p>指针可以是<code>const</code>,修饰的值也可能是<code>const</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p=&amp;i;<br>*p=<span class="hljs-number">25</span>;<span class="hljs-comment">//因为使用const修饰p所以不能再使用，*对i进行修改</span><br><span class="hljs-comment">//但是可以通过，直接对i进行修改</span><br></code></pre></td></tr></table></figure></li><li><p>判断被<code>const</code>的标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1=&amp;i;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p2=&amp;i;<br><span class="hljs-comment">//第一个和第二个是一样的，const在*的前面，表示所指的东西不能被修改，const在*的后面表示指针不能被修改</span><br></code></pre></td></tr></table></figure></li><li><p><code>const</code>修饰数组表示，数组里面的每一个元素都被<code>const</code></p></li></ol><h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><ol><li>指针+1，增加一个指针所指的类型，同理对n也有意义，对-也有意义，减出的结果是，差n个指针所指的类型（元素个数）</li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* p=&amp;a;<br>pfintf(<span class="hljs-string">&quot;p=%d&quot;</span>,p);<br>pfintf(<span class="hljs-string">&quot;p+1=%d&quot;</span>,p+<span class="hljs-number">1</span>);<span class="hljs-comment">//p+1为p+4,因为p增加了一个int 的大小</span><br><span class="hljs-type">char</span> b=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span>*q=&amp;b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;q=%d&quot;</span>,q);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;q+1=%d&quot;</span>,q+<span class="hljs-number">1</span>);<span class="hljs-comment">//q+1为q+1,因为q增加了一个char的大小</span><br></code></pre></td></tr></table></figure>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> ac[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">char</span> *p=ac;<br><span class="hljs-comment">//*p-&gt;ac[0]</span><br><span class="hljs-comment">//*(p+1)-&gt;ac[1]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>如果地址加1就没有实际意义</li><li>0地址， 是不能随便触碰的地址如果使用NULL效果和0地址一样，有些编译器，若果强制使用0地址，则可以用NULL </li><li>指针和指针相减的前提是两个指针指向同一个指针</li><li>指针加指针没有什么意义</li></ol><h2 id="指针的类型转换"><a href="#指针的类型转换" class="headerlink" title="指针的类型转换"></a>指针的类型转换</h2><ol><li>强制类型转换，可以用于指针的赋值</li></ol><h2 id="指针的用处需要传入较大的数据用作参数"><a href="#指针的用处需要传入较大的数据用作参数" class="headerlink" title="指针的用处需要传入较大的数据用作参数"></a>指针的用处需要传入较大的数据用作参数</h2><ol><li><p>传入数组对数组操作</p></li><li><p>函数返回不止一个结果</p></li><li><p>用函数修改不止一个变量</p></li><li><p>动态申请内存</p></li></ol><h2 id="动态内存分布"><a href="#动态内存分布" class="headerlink" title="动态内存分布"></a>动态内存分布</h2><ol><li><p><code>malloc</code>:库函数为<code>&lt;stdlib.h&gt;</code></p><ul><li><p>向<code>malloc</code>申请的空间的大小是以字节为单位的，返回的结果是<code>void*</code>,需要类型转换为自己需要的类型</p></li><li><p>同时需要使用，<code>free（）</code>将地址归还，括号里面填存储地址的变量，可以使用free(NULL)</p></li><li><p>如果申请失败的话就会返回0或者NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> number;<br>    <span class="hljs-type">int</span>* a;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入空间大小&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br>    a=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(number*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">//第一个int*是将malloc返回值强制转换为int*,因为a是int*</span><br>    <span class="hljs-comment">//(number*sizeof(int)),*指的是乘法,number,是我们想要的大小,但是需要×相应的类型才能得到,</span><br>    <span class="hljs-built_in">free</span>(a);<span class="hljs-comment">//使用malloc需要归还</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用<code>malloc</code>常见问题</p><ul><li>使用了<code>malloc</code>没有free</li><li>错过了free的时机</li><li><code>free</code>再<code>free</code></li></ul></li></ol><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><ol><li><p>指针指向的位置是不可知的为野指针</p></li><li><p>造成原因</p><ul><li><p>指针没有初始化</p><ul><li>指针的初始化为NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *i;<br>*i=<span class="hljs-number">20</span>;<br><span class="hljs-comment">//这里i 就是野指针</span><br><span class="hljs-comment">//因为i没有初始化，局部变量i默认为随机值，随机的位置来访问i,也就是非法访问</span><br><br></code></pre></td></tr></table></figure></li><li><p>指针越界也会造成野指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>* p =arr;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        *p=i;<br>        p++;<span class="hljs-comment">//这里需要循环10次，但是第10次的时候已经越界，这时候是野指针</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指针指向的空间释放</p></li></ul></li><li><p>如何有效规避野指针</p><ul><li>指针初始化NULL</li><li>小心指针的越界</li><li>指针指向空间及时释放指针为NULL</li><li>检查指针的有效性</li></ul></li><li><p>空指针没有权限使用</p><ul><li><p>使用指针时，最好判断是否为NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span>（p!=<span class="hljs-literal">NULL</span>）<br>&#123;<br>    *p=<span class="hljs-number">20</span>;<br>&#125;<span class="hljs-comment">//最好判断一下，可以减少代码出错</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="指针的标准"><a href="#指针的标准" class="headerlink" title="指针的标准:"></a>指针的标准:</h2><blockquote><p>允许指向数组元素的指针指向数组后面一个地址，不允许指向前面一个地址</p></blockquote><ol><li><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> count 5</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[count]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> i=count;<br><span class="hljs-keyword">for</span>(p=&amp;arr[count];p&gt;&amp;arr[<span class="hljs-number">0</span>];)<br>&#123;<br>--i;<br>*--p=i;<br>        <span class="hljs-comment">//先--，再解引用</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>,arr[i],*p);<br>        <br>  &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><ol><li><p>数组名：是数组首元素的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *p=arr;<br><span class="hljs-comment">//*(p+2)&lt;==&gt;arr[3]&lt;==&gt;*(2+p)&lt;==&gt;*(2+arr)&lt;==&gt;*(arr+2)&lt;==&gt;2[arr]&lt;==&gt;p[2]</span><br><span class="hljs-comment">//因为编译器在编译的时候，将arr[2]--&gt;*（arr+2）,所以我们可以运用交换率，arr[2]=2[arr]</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><ol><li><p>指向指针的指针，被称作为二级指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">8</span>;<br><span class="hljs-comment">//int为a的类型</span><br><span class="hljs-type">int</span> *pa=&amp;a;<br><span class="hljs-comment">//*为指针变量，int 为a的类型</span><br><span class="hljs-type">int</span>* *ppa=&amp;pa;<span class="hljs-comment">//ppa是二级指针变量</span><br><span class="hljs-comment">//第二个*为指针变量，第一个int*为pa的类型</span><br>inte***pppa=&amp;ppa;<br><span class="hljs-comment">//三级指针</span><br></code></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*pa=a;<br>*ppa=pa;<br>**ppa=a;<br></code></pre></td></tr></table></figure></li></ol><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><ol><li><p>存放指针的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* parr[<span class="hljs-number">10</span>];<span class="hljs-comment">//指针数组，cun&#x27;f</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数指针合集</title>
    <link href="/2023/04/20/C/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%90%88%E9%9B%86/"/>
    <url>/2023/04/20/C/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>学习目标：</p><ol><li>认识函数指针</li><li>typedef和函数指针</li><li>万能指针充当函数指针</li></ol><p>[TOC]</p><h1 id="函数指针合集"><a href="#函数指针合集" class="headerlink" title="函数指针合集"></a>函数指针合集</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><p>什么是函数指针</p><blockquote><p>对应函数在内存当中的首地址</p></blockquote></li><li><p>定义函数指针 </p><ul><li><p>使用(*标识符（可以当作指针变量的名字）)替换函数名，剩下的照抄</p></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    ;<br>&#125;<br><span class="hljs-type">int</span> (*p_func)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)<span class="hljs-comment">//函数指针</span><br><span class="hljs-type">void</span> (*p)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span> )=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//形参可以不写</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>通过函数指针调用</p><ul><li><p>给函数指针赋值（通常使用函数名）</p><ul><li><p>直接用函数指针替换函数名调用</p></li><li><p>指针的<code>*</code>操作，调用</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>,a,b);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">p_func2</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;void (*p_func2) (int a,int b)\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//在main里面的定义的函数指针</span><br>    <span class="hljs-type">void</span> (*p)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">void</span> *pp=p_func2();<br>    p=func1;<br>    func1(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//在外面定义的函数指针</span><br>    *p_func2();<br>    *pp;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>函数指针有什么用？、</p><blockquote><p>充当回调函数（以函数指针为参数的函数）</p></blockquote><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)<br>        <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Printf_S</span><span class="hljs-params">(<span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>),<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p(a,b));<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> (*pp)(<span class="hljs-type">int</span> (<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>),<span class="hljs-type">int</span> ,<span class="hljs-type">int</span> )=Printf_S;<br>    pp(Min,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    pp(Max,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\学\笔记\c\函数指针\函数指针合集.assets\image-20221227220007304.png" alt="image-20221227220007304"></p></li></ol><h2 id="typedef和函数指针"><a href="#typedef和函数指针" class="headerlink" title="typedef和函数指针"></a><code>typedef和函数指针</code></h2><ol><li><p><code>typedef</code>基本用法，给类型起别名   </p></li><li><p>定义函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)<br>        <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Printf_S</span><span class="hljs-params">(<span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>),<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p(a,b));<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> (*pp)(<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>),<span class="hljs-type">int</span> ,<span class="hljs-type">int</span> )=Printf_S;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ppp)</span><span class="hljs-params">(<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>),<span class="hljs-type">int</span> ,<span class="hljs-type">int</span> )</span>;<br>    ppp p_f=Printf_S;<br>    p_f(Max,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>    pp(Min,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="万能指针充当函数指针"><a href="#万能指针充当函数指针" class="headerlink" title="万能指针充当函数指针"></a>万能指针充当函数指针</h2><ol><li><p>万能指针：空类型的指针(<code>void *p</code>)</p></li><li><p>万能指针可以操作任何类型的指针，但是在使用前必须强制类型转换</p><ul><li>语法：（要转换的类型）</li></ul></li><li><p>万能指针操作数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">244</span>;<br>    <span class="hljs-type">float</span> b=<span class="hljs-number">3.14f</span>;<br>    <span class="hljs-type">void</span> *p=<span class="hljs-literal">NULL</span>;<br>    p=&amp;a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(<span class="hljs-type">int</span> *)p);<br>    p=&amp;b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>,*(<span class="hljs-type">float</span> *)p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数指针的类型(去掉变量名)</p><p>例如：<code>void (*p)(int,int);</code>类型为<code>void (*)(int,int)</code></p><p>调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">244</span>;<br>    <span class="hljs-type">float</span> b=<span class="hljs-number">3.14f</span>;<br>    <span class="hljs-type">void</span> *p=<span class="hljs-literal">NULL</span>;<br>    p=&amp;a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(<span class="hljs-type">int</span> *)p);<br>    p=&amp;b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>,*(<span class="hljs-type">float</span> *)p);<br>    p=print;<br>    ((<span class="hljs-type">void</span>(*)())p)();<br>    (*(<span class="hljs-type">void</span>(*)())p)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>区分下面4中代码</li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p=&amp;a;<br><span class="hljs-type">const</span> * <span class="hljs-type">int</span> p=&amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p=&amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> * p=&amp;a;<br></code></pre></td></tr></table></figure><ul><li><p><code>*</code>前面的<code>const</code>写在前面和后面是一样的</p><p> 例如：<code>const *int x=1;</code> <code>int const* x=1;</code> 都是让指向的值变成常量</p><p>作用是修饰数据类型的，也就是指向指针所指向的类型</p></li><li><p><code>int* const p</code>  是指针变成了常量，指针只能指一个地址</p></li></ul><ol start="2"><li><p>区分指针数组，数组指针（哪个在后面就是什么）</p><ul><li><p>指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* p[<span class="hljs-number">3</span>]=&#123;<span class="hljs-string">&quot;chg&quot;</span>,<span class="hljs-string">&quot;zjy&quot;</span>,<span class="hljs-string">&quot;tsy&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-built_in">puts</span>(p[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作符详解</title>
    <link href="/2023/04/20/C/%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A31/"/>
    <url>/2023/04/20/C/%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A31/</url>
    
    <content type="html"><![CDATA[<h1 id="操作符详解"><a href="#操作符详解" class="headerlink" title="操作符详解"></a>操作符详解</h1><h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><ol><li>+,-,*,&#x2F;</li><li>除法（-）:得到商，如果结果是小数，int类型只会打印整形，解决方法：<ul><li>将商类型转化</li><li>直接将变量定义为double</li></ul></li><li>余数（%）：只用于整数</li></ol><h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><ol><li>&gt;&gt;和&lt;&lt;左移操作符</li><li>右移两种移法<ul><li>算术右移：右边丢弃一位（存储的二进制），然后左边增加符号位(当前主要)</li><li>逻辑右移：右边丢弃，左边补0</li></ul></li><li>例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a =<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> b=a&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,b);<br><span class="hljs-comment">//结果是8（2^3）</span><br><span class="hljs-comment">//因为16的二进制是（32位）</span><br><span class="hljs-comment">//0（27位）10（4位）</span><br><span class="hljs-comment">//丢弃一位10（27位）10（3位）</span><br><span class="hljs-comment">//右移一位有除2二的效果</span><br></code></pre></td></tr></table></figure></li><li>补充知识：<ul><li>原码，反码，补码</li><li>整数的3码相同。负数的反码为：符号位不变，其他位按位取反。补码：负数的存储格式，为反码加1</li></ul></li><li>左移：左边丢弃，右边补零</li></ol><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ol><li>&amp;（按位与），|按位与，</li><li>&amp;只要有0，则为0，两个1，才为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> c=a&amp;b;<br><span class="hljs-comment">//a在计算机中为00000000000000000000000000000011</span><br><span class="hljs-comment">//b在计算机中为00000000000000000000000000000101</span><br><span class="hljs-comment">//按位与：     00000000000000000000000000000001</span><br><span class="hljs-comment">//切记是补码进行按位与</span><br></code></pre></td></tr></table></figure></li><li>| 按位或：补码，有1则为1</li><li>^按位异或：2进制补码，相同为1，相异为0</li><li>实现两数的交换<ul><li>倒水法（创建临时变量）</li><li>加减法（值大了，容易溢出）</li><li>^法（除了代码难读，没有缺点）</li></ul></li></ol><h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><ol><li>连续赋值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x=y=z=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li>判断为&#x3D;&#x3D;</li><li>复合操作符：<ul><li>+&#x3D;，-&#x3D;等等</li></ul></li></ol><h2 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h2><ol><li>！：把假变成真，把真变成假  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//a为真打印</span><br><span class="hljs-keyword">if</span>(a)<br>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>&#125;<br><span class="hljs-comment">//a为假打印</span><br><span class="hljs-keyword">if</span>(!a)<br>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>&amp;(取地址):配合指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p=&amp;a;<br>*p=<span class="hljs-number">20</span>;<span class="hljs-comment">//让a等于20</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li>sizoef:计算所占空间的大小，单位是字节，注意区分，strlen(数组的长度，不包括‘\0’);<ul><li>指针大小，要不是4（32位系统）个字节，要不是8（64位字节）个字节</li><li>内部表的式不参加运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">short</span> s=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">sizoef</span>(s=a+<span class="hljs-number">5</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,s);<br><span class="hljs-comment">//结果为2和0，因为不参与运算</span><br></code></pre></td></tr></table></figure></li></ul></li><li>~（按位(二进制)取反）：将二进制按位取反，所有位按位取反</li><li>++a:先++，后使用</li><li>a++:先使用，再++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a++);<br><span class="hljs-comment">//结果位0；</span><br></code></pre></td></tr></table></figure></li><li>(类型)：强制类型转换</li></ol><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><ol><li>&amp;&amp;（逻辑与）并且；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> c=a&amp;&amp;b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c);<br><span class="hljs-comment">//结果为1，因为a,b都为真</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,a=<span class="hljs-number">0</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>,d=<span class="hljs-number">4</span>;<br>i=a++ &amp;&amp; ++b &amp;&amp; d++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d,%d&quot;</span>,a,b,c,d);<br><span class="hljs-comment">//结果为i=0,a=1,b=2,c=3,d=4;</span><br><span class="hljs-comment">//因为先使用a,a=0,为假，后面不计算</span><br></code></pre></td></tr></table></figure></li><li>&amp;&amp;,||：对于&amp;&amp;来说只要前面是假，后面不算，对于||来说只要前面是真，就不算</li></ol><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><ol><li><p>exp1?exp2:exp3:如果表达式一位真，则表达式二计算，且为整个表达式的结果，反之是表达式3</p></li><li><p>，（逗号表达式）：简便代码</p></li></ol><h2 id="下标引用操作符"><a href="#下标引用操作符" class="headerlink" title="下标引用操作符"></a>下标引用操作符</h2><ol><li>[]:常用于数组</li></ol><h2 id="函数调用操作符"><a href="#函数调用操作符" class="headerlink" title="函数调用操作符"></a>函数调用操作符</h2><ol><li>()：用于函数</li></ol><h2 id="访问一个结构的成员"><a href="#访问一个结构的成员" class="headerlink" title="访问一个结构的成员"></a>访问一个结构的成员</h2><ol><li><p>struct: 创建一个结构体</p></li><li><p>.成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//相当于盖房子时的规划图,name,age,id为成员</span><br>strcut stu<br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> id[<span class="hljs-number">20</span>]<br>&#125;;<span class="hljs-comment">//注意分号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    strcut stu s1=&#123;<span class="hljs-string">&quot;chg&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;2022124032&quot;</span>&#125;;<span class="hljs-comment">//往规划图里面加东西</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>* <span class="hljs-title">ps</span>=</span>&amp;s1;<span class="hljs-comment">//得到s1的地址</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,si.name);<span class="hljs-comment">//1</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,s1.age);<span class="hljs-comment">//2.查找成员</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,si.id);<span class="hljs-comment">//3</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,(*ps).name);<span class="hljs-comment">//与1相同</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ps-&gt;name);<span class="hljs-comment">//与1相同</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="表达式的求和顺序"><a href="#表达式的求和顺序" class="headerlink" title="表达式的求和顺序"></a>表达式的求和顺序</h2><p>由操作的优先级和结合性决定</p><ol><li><p>隐式类型转换：</p><ul><li><p>整型提升：C的整型算术运算总是至少以缺省整型类型的精度来进行的。 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> a=<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//char 占1个字节，一共8个字符</span><br>    <span class="hljs-comment">//a=00000011</span><br>    <span class="hljs-type">char</span> b=<span class="hljs-number">127</span>;<br>    <span class="hljs-comment">//b=01111111</span><br>    <span class="hljs-type">char</span> c=a+b;<span class="hljs-comment">//相加转换为整形</span><br>    <span class="hljs-comment">//a=00000000000000000000000000000011</span><br>    <span class="hljs-comment">//b=00000000000000000000000001111111</span><br>    <span class="hljs-comment">//c=11111111111111111111111110000010</span><br>    <span class="hljs-comment">//根据符号数补齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>算术运算：将低精度的转换为高精度的</p></li></ul></li><li><p>操作符的属性</p><ul><li>优先级：优先级高的先算</li><li>结合性：</li><li>求值顺序:</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件操作</title>
    <link href="/2023/04/20/C/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/20/C/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h2><ol><li><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221111215431353.png" alt="image-20221111215431353"></li><li>数据文件<ul><li>存放程序运行时需要读取的数据</li></ul></li><li>文件名<ul><li>文件名包含：文件路径+文件主干+文件后缀</li><li><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221111215955712.png" alt="image-20221111215955712"></li></ul></li></ol><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><ol><li>文件指针：指向文件地址</li><li>文件信息区：在内存中开辟的名为<code>FILE</code>的结构体变量(由系统声明)</li><li>通过使用<code>FILE*</code>指针来维护FILE结构体</li><li><code>fopen()</code>函数和:</li><li><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221111221059403.png"></li><li><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221111221754676.png" alt="image-20221111221754676"></li></ol><blockquote><p><code>filename</code>:文件名</p><p><code>mode</code>:打开方式</p><p><code>fopen</code>:打开文件</p><p><code>fclose</code> :关闭文件</p></blockquote><ol start="7"><li>打开文件的方式<ul><li><img src="C:\Users\12414\Desktop\C语言笔记\文件操作\文件操作.assets\image-20221112084050171.png"></li></ul></li></ol><h2 id="文件的读写与关闭"><a href="#文件的读写与关闭" class="headerlink" title="文件的读写与关闭"></a>文件的读写与关闭</h2><ol><li><p>相关函数：</p><ul><li><img src="C:\Users\12414\Desktop\C语言笔记\文件操作\文件操作.assets\image-20221112084625654.png" alt="image-20221112084625654"></li></ul></li><li><p>输入：指从内存中写入到硬盘</p></li><li><p>输出：指从硬盘读取到内存中</p></li><li><p><code>perror</code>():C 库函数 <code>void perror(const char \*str)</code> 把一个描述性错误消息输出到标准错误 <code>stderr</code>。首先输出字符串 <code>str</code>，后跟一个冒号，然后是一个空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE* pr=fopen(<span class="hljs-string">&quot;chg.tet&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(pr==<span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\12414\Desktop\C语言笔记\文件操作\文件操作.assets\image-20221112091903125.png" alt="image-20221112091903125"></p></li><li><p><code>fputc（&#39;char&#39;,流的指针）</code>:写一个数据到流里面去</p></li><li><p><code>fgetc</code>:当文件读取正常，返回的是字符的<code>ASCLL</code>码值是个整形，读取错误（读取完成）则返回的是<code>EOF(-1)</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>FILE* pr;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-comment">//打开文件</span><br>pr=fopen(<span class="hljs-string">&quot;chg.tet&quot;</span>,<span class="hljs-string">&quot;r+&quot;</span>);<br><span class="hljs-comment">//文件的判断</span><br><span class="hljs-keyword">if</span>(pr==<span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen:&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//文件写入</span><br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;c&quot;</span>,pr);<br><span class="hljs-comment">//文件读取</span><br>rewind(pr);<br>ret=fgetc(pr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,ret);<br><span class="hljs-comment">//关闭文件</span><br>fclose(pr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>fputs</code>:写一个字符串</p><ul><li><pre><code class="c">fputs(&quot;chg,tsy\n&quot;,pr);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>     <br><br><span class="hljs-number">8</span>. `fgets`:读一个字符串<br><br>   - ```c<br>     fgets(arr,<span class="hljs-number">4</span>,pr)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c">int main()&#123;    FILE* pr=NULL;    char arr[10];    //文件的创建    pr=fopen(&quot;chg.tet&quot;,&quot;r+&quot;);    //文件的判断    if(pr==NULL)    &#123;        perror(&quot;fopen:&quot;);        return 1;    &#125;    //第一次文件操作    fputs(&quot;chgchg&quot;,pr);    rewind(pr);    fgets(arr,7,pr);    printf(&quot;%s\n&quot;,arr);    //第二次文件操作    rewind(pr);    fputs(&quot;tsytsy&quot;,pr);    rewind(pr);    fgets(arr,7,pr);    printf(&quot;%s\n&quot;,arr);    //文件的关闭    fclose(pr);    return 0;&#125;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>## 结构体数据存储<br><br><span class="hljs-number">1.</span> `<span class="hljs-built_in">fprintf</span>()`:<br><br>   ```<span class="hljs-function">c</span><br><span class="hljs-function">   <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>   <span class="hljs-comment">//创建文件</span><br>   FILE* pr = <span class="hljs-literal">NULL</span>;<br>   pr = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;chg.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);<br>   <br>   stu stu1;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, stu1.number, stu1.name);<br>   <span class="hljs-comment">//文件的判断</span><br>   <span class="hljs-keyword">if</span> (pr == <span class="hljs-literal">NULL</span>)<br>   &#123;<br>   <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen:&quot;</span>);<br>   <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-comment">//文件的写入</span><br>   <span class="hljs-built_in">fprintf</span>(pr, <span class="hljs-string">&quot;number:%s\tname:%s&quot;</span>, stu1.number, stu1.name);<br>   <span class="hljs-built_in">rewind</span>(pr);<br>   <span class="hljs-comment">//关闭文件</span><br>   <span class="hljs-built_in">fclose</span>(pr);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>fscanf()</code>:成功返回1</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//创建文件</span><br>FILE* pr = <span class="hljs-literal">NULL</span>;<br>pr = fopen(<span class="hljs-string">&quot;chg.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);<br><br>stu stu1 = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, stu1.number, stu1.name);<br><span class="hljs-comment">//文件的判断</span><br><span class="hljs-keyword">if</span> (pr == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen:&quot;</span>);<br><span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//文件的写入</span><br><span class="hljs-built_in">fprintf</span>(pr, <span class="hljs-string">&quot;number:%s\tname:%s&quot;</span>, stu1.number, stu1.name);<br><span class="hljs-comment">//文件的读取</span><br>rewind(pr);<br>stu1.number[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;123&quot;</span>;<br>stu1.name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;00000&quot;</span>;<br><span class="hljs-built_in">fscanf</span>(pr, <span class="hljs-string">&quot;number:%s\tname:%s&quot;</span>, &amp;stu1.number,&amp;stu1.name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;number:%s\tname:%s&quot;</span>, stu1.number, stu1.name);<br><span class="hljs-comment">//关闭文件</span><br>fclose(pr);<br>pr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制写入："><a href="#二进制写入：" class="headerlink" title="二进制写入："></a>二进制写入：</h2><ol><li><code>fwrite</code>:将buffer的东西存储进流里面<img src="C:\Users\12414\Desktop\C语言笔记\文件操作\文件操作.assets\image-20221113114946926.png" alt="image-20221113114946926"></li></ol><ul><li><p><code>buffer</code>是个指针，地址</p></li><li><p><code>size</code>:元素的大小，单位是字节</p></li><li><p><code>count</code>:元素个数</p></li><li><p>最后为流地址</p></li><li><pre><code class="c">typedef struct student&#123;    char number[20];    char name[10];&#125;stu;int main()&#123;    //文件的创建    FILE* pr = NULL;    pr = fopen(&quot;chg.txt&quot;, &quot;r+&quot;);    stu stu1;    scanf(&quot;%s%s&quot;, stu1.name, stu1.number);    //文件的2进制读写    fwrite(&amp;stu1, sizeof(stu), 1, pr);    //文件的关闭    fclose(pr);    pr = NULL;    return 0;&#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>    <br><br><span class="hljs-number">2.</span> `fread`:将流里面的东西读出来![image<span class="hljs-number">-20221113130044448</span>](C:\Users\<span class="hljs-number">12414</span>\Desktop\C语言笔记\文件操作\文件操作.assets\image<span class="hljs-number">-20221113130044448.</span>png)<br><br>  ```c<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>  &#123;<br>  <span class="hljs-type">char</span> number[<span class="hljs-number">20</span>];<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br>  &#125;stu;<br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>  <span class="hljs-comment">//文件的创建</span><br>  FILE* pr = <span class="hljs-literal">NULL</span>;<br>  pr = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;chg.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);<br>  stu stu1;<br>  <span class="hljs-comment">//文件的2进制读写</span><br>  <span class="hljs-built_in">fread</span>(&amp;stu1,<span class="hljs-built_in">sizeof</span>(stu1),<span class="hljs-number">1</span>,pr);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s&quot;</span>, stu1.name, stu1.number);<br>  <span class="hljs-comment">//文件的关闭</span><br>  <span class="hljs-built_in">fclose</span>(pr);<br>  pr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul><ol start="3"><li><p>判断文件的读取是否成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">feof(<span class="hljs-string">&quot;文件指针&quot;</span>);<span class="hljs-comment">//读取成功返回0，不成功返回非零值</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a><code>fseek</code></h2><ol><li><p>移动文件内部的指针，达到随机访问的目的</p></li><li><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>遵循顺序：创建文件，文件的判断，文件的写入，文件的读取，文件的关闭，记得让指针只向空，文件写入后记得让指针恢复，再进行</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举</title>
    <link href="/2023/04/20/C/%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/04/20/C/%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="常量符号化"><a href="#常量符号化" class="headerlink" title="常量符号化"></a>常量符号化</h2><ol><li><p>用符号而不是具体的数字来表示程序中的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> red=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//然后直接使用类型的名字</span><br><span class="hljs-comment">//等等</span><br></code></pre></td></tr></table></figure></li><li><p>枚举是一种用户定义的数据类型，他用关键字<code>enum</code>来声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型的名字&#123;</span>名字<span class="hljs-number">0</span>······名字n&#125;;<br></code></pre></td></tr></table></figure></li><li><p>枚举类型的名字通常不直接使用，而是使用大括号里面的名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">colors</span>&#123;</span>red,yellow,green,numcolors&#125;;<br><span class="hljs-comment">//大括号里面的类型是int 他们从0到n</span><br><span class="hljs-comment">//因为最后一个元素可以用于计数，统计前面有多少个enum</span><br><span class="hljs-comment">//如这里，numcolors就表示有3个enum变量</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span>&#123;</span>red=<span class="hljs-number">1</span>,yellow=<span class="hljs-number">5</span>,green=<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//使用举例：</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">name</span> &#123;</span>red=<span class="hljs-number">1</span>,green=<span class="hljs-number">10</span>,black=<span class="hljs-number">3</span>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <br></code></pre></td></tr></table></figure></li><li><p>枚举常用于定义符号量，声明在main以前</p></li></ol><h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h2><ol><li><p><code>strcut</code>:声明在主函数内外都可以，但是想要结构可以在更多的函数中运用最好放在，主函数外面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//形式1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> day;<br><span class="hljs-type">int</span> month;<br><span class="hljs-type">int</span> year;<br>&#125;;<br><span class="hljs-comment">//一定要输入分号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">today</span>;</span><br>    <span class="hljs-comment">//可以理解为，struct定义了多个数据类型</span><br>    <span class="hljs-comment">//这里给数据起名字为today</span><br>today.day=<span class="hljs-number">244</span>;<br>    <span class="hljs-comment">//名字加数据类型</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,today.day);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//形式二</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;p1,p2;<br><span class="hljs-comment">//p1和p2都是一种无名结构，里面有x,y</span><br><span class="hljs-comment">//这种类型不常见，用于周期不长</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<span class="hljs-comment">//（成员变量）</span><br>&#125;p1,p2;<span class="hljs-comment">//变量列表</span><br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;n1=&#123;<span class="hljs-number">10</span>,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-literal">NULL</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>成员初始化是0,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> day;<br><span class="hljs-type">int</span> month;<br><span class="hljs-type">int</span> year;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">today</span>=</span>&#123;<span class="hljs-number">27</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2022</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">chg</span>;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i-%i-%i\n\n&quot;</span>,today.year,today.month,today.day);<br>chg.day=<span class="hljs-number">27</span>;<br>chg.month=<span class="hljs-number">10</span>;<br>chg.year=<span class="hljs-number">2022</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i-%i-%i&quot;</span>,chg.day,chg.month,chg.year);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结构用.或者-&gt; 运算符和名字访问其他成员，-struct stu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">chg</span>=</span>&#123;<span class="hljs-string">&quot;chg&quot;</span>,<span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> *<span class="hljs-title">i</span>=</span>&amp;chg;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,(*i).name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,i-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,chg.name);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;p1,p2;<br><br><span class="hljs-comment">//访问成员的方式</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> </span><br><span class="hljs-class">    <span class="hljs-title">return</span> 0;</span><br>&#125;<br>p1.x=p1=date.x;<br>p2.y=p2=date.y;<br>p1=p2---&gt;p1.x=p2.x,p1.y=p2.y;<br></code></pre></td></tr></table></figure></li><li><p>结构运算 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">today</span>=</span>&#123;<span class="hljs-number">27</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2022</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">chg</span>;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i-%i-%i\n\n&quot;</span>,today.year,today.month,today.day);<br>chg.day=<span class="hljs-number">27</span>;<br>chg.month=<span class="hljs-number">10</span>;<br>chg.year=<span class="hljs-number">2022</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i-%i-%i\n\n&quot;</span>,chg.day,chg.month,chg.year);<br>chg=today;<br>chg.year=<span class="hljs-number">2021</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i-%i-%i\n\n&quot;</span>,chg.day,chg.month,chg.year);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>结构内容的打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> number[<span class="hljs-number">20</span>];<br>    <span class="hljs-comment">//必须加数字</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">chg</span>=</span>&#123;<span class="hljs-number">19</span>,chg,<span class="hljs-string">&quot;2022124032&quot;</span>&#125;;<br>    <span class="hljs-comment">//字符串的创建用&quot;&quot;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%s&quot;</span>,chg.age,chg.name,chg.number);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>嵌套结构只能，在主函数定义，不能在结构体里面定义，但需要命名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> hour;<br><span class="hljs-type">int</span> min;<br><span class="hljs-type">int</span> second;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">today</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span> <span class="hljs-title">now_time</span>;</span><span class="hljs-comment">//不能在这定义now_time的内容，需要定义名字</span><br><span class="hljs-type">int</span> year;<br><span class="hljs-type">int</span> month;<br><span class="hljs-type">int</span> day;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">today</span> <span class="hljs-title">TIME</span>=</span>&#123;&#123;<span class="hljs-number">23</span>,<span class="hljs-number">02</span>,<span class="hljs-number">34</span>&#125;,<span class="hljs-number">2022</span>,<span class="hljs-number">10</span>,<span class="hljs-number">28</span>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h2><ol><li><p>&amp;可以用取地址取到该结构体变量具体的某一类型的地址，而且可以打印出来 </p></li><li><p>传结构给函数，是传值，如果有函数使用过那该值为0</p></li><li><p>用结构也可以接受函数返回的结构的值</p></li><li><p>将结构体变量传入函数的方法是：将结构体变量地址给函数，函数中用指针接受，然后用指针的用法，指需要用的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//传址调用</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stu *chg_1)</span><br>&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,chg_1-&gt;name);<span class="hljs-comment">//chg_1相当于指针的用法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,(*chg_1).name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">chg</span>=</span>&#123;<span class="hljs-string">&quot;chg&quot;</span>,<span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> *<span class="hljs-title">i</span>=</span>&amp;chg;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,(*i).name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,i-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,chg.name);<br>print(&amp;chg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//传值调用</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stu chg_2)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s\n&quot;</span>,chg_2.name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">chg</span>=</span>&#123;<span class="hljs-string">&quot;chg&quot;</span>,<span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> *<span class="hljs-title">i</span>=</span>&amp;chg;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,(*i).name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,i-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,chg.name);<br>print(&amp;chg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由于传值调用需要开辟新空间，可能导致栈压力过大，所以更好的方法是传址调用</p><ul><li><p>栈存储数据先进后出，后进的先出</p></li><li><p>函数调用的参数压栈，从下往上存储数据时叫压栈，</p></li><li><p>出栈是从上往下删</p></li></ul></li></ol><h2 id="函数与栈区"><a href="#函数与栈区" class="headerlink" title="函数与栈区"></a>函数与栈区</h2><ol><li>函数调用都会在内存的栈区上，开辟新的空间</li><li>函数传参，从右往左传参</li><li>自己写的函数也要占用空间</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联合体专解</title>
    <link href="/2023/04/20/C/%E8%81%94%E5%90%88%E4%BD%93%E4%B8%93%E8%A7%A3/"/>
    <url>/2023/04/20/C/%E8%81%94%E5%90%88%E4%BD%93%E4%B8%93%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="联合体专解"><a href="#联合体专解" class="headerlink" title="联合体专解"></a>联合体专解</h1><h2 id="共用体的定义"><a href="#共用体的定义" class="headerlink" title="共用体的定义"></a>共用体的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 名字</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ol><li><p>所有变量使用同一个内存，一般为联合体中数据成员占用内存最多的变量的内存</p></li><li><p>在使用时，只有一个变量有效，在初始化时，不能同时初始化，多个变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> num;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Date</span> <span class="hljs-title">date</span>;</span><br>date.num=<span class="hljs-number">65</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,date.num);<br>    <span class="hljs-comment">//结果为65</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,date.name);<br>    <span class="hljs-comment">//结果为A，虽然没有定义date.name,但是由于共用一个内存，是可以访问的，因为65是A的码值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2023/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    <url>/2023/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的定义和基本术语"><a href="#图的定义和基本术语" class="headerlink" title="图的定义和基本术语"></a>图的定义和基本术语</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png"></p><ol><li><p>完全图</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%AE%8C%E5%85%A8%E5%9B%BE.png"></p><p>有<code>n</code>个点每个点都与<code>n-1</code>个点有边，但是注意如果是无向的边则应该是<code>n*(n-1)/2</code>。如果是有向的边，则应该是<code>n*(n-1)</code></p></li><li><p>稀疏图(e&lt;nlogn)</p><p><strong>带箭头的边称为狐</strong></p><p>有很少的边或狐的图</p></li><li><p>稠密图</p><p>有较多的边或狐的图</p></li><li><p>网</p><p>边&#x2F;狐带权（有意义，如：<code>20km</code>等）的图</p></li><li><p>邻接</p><p>有边&#x2F;狐相连的两个顶点之间的关系</p><p>根据离散的知识(V<del>i</del>,V<del>j</del>)这是不分先后的（小括号括起来），则说V<del>i</del>,V<del>j</del>互称为邻接点</p><p>&lt;V<del>i</del>,V<del>j</del>&gt;则则是有序的，对应有向的图V<del>i</del>邻接到V<del>j</del>，V<del>j</del>邻接于V<del>i</del></p></li><li><p>关联（依附）</p><p>边或者狐与顶点的关系</p></li><li><p>顶点的度</p><p>该顶点相关联的边的条数</p><p>在有向图当中，顶点的度等于该顶点的出度和入度之和</p><ul><li>入度：是以该顶点为终点的有向边</li><li>出度：是以该顶点为起点的有向边</li></ul><p>有向树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E6%9C%89%E5%90%91%E6%A0%91.png"></p></li><li><p>路径</p><p>按续的边构成的点的顶点序列</p></li><li><p>路径长度</p><p>路径上边或者狐的数目（权值）之和</p></li><li><p>环（回路）</p><p>第一个顶点和最后一个顶点相同的路径</p></li><li><p>简单的路径</p><p>除了路径的起点和终点可以相同，其他的都不同</p></li><li><p>简单的回路（简单的环）：除路径和终点相同，其他的顶点都不相同（注意区别简单路径和简单的回路）</p></li><li><p>连通图</p><p>就是图中任意的两个点都能够连接起来</p></li><li><p>权</p><p>图中的边或则弧线具有的相关的数被称为权。表明从一个顶点到另一个顶点的距离和消耗</p></li><li><p>网</p><p>带权的图</p></li><li><p>子图</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%AD%90%E5%9B%BE.png"></p><p>如果一个图是；另一个图的一部分就说明是子图</p></li><li><p>连通分量</p><p>无向图的最大联通的子图就称为G 的连通分量</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png"></p></li><li><p>强连通分量</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png"></p></li><li><p>极小连通子图</p><p>就是连通子图，如果再删除一条边，就不连通则说明是极小的连同子图</p></li><li><p>生成树</p><p>包含无向图的的所有的顶点的绩极小的联通子图</p></li><li><p>图和树的不同</p><ul><li>树是一种特殊的图，但是没有环，也就是说树的两个结点只有唯一路径</li><li>树的每一个节点有且仅有<code>1</code>或者<code>0</code>个前驱。但是树可以有多个前驱</li><li>树的每一个结点只会存在一种关系，即父子关系。但是图可以有多种关系。比如：有向边和无向边</li><li>树一般用于分层存储和处理数据，如文件系统等；而图则更加灵活，可以用于表示各种复杂关系和网络结构，如社交网络、电脑网络、交通网络等等。</li></ul></li><li><p>相同点</p><p>树和图是两种基本的非线性数据结构</p></li></ol><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="数组表示法（邻接矩阵）"><a href="#数组表示法（邻接矩阵）" class="headerlink" title="数组表示法（邻接矩阵）"></a>数组表示法（邻接矩阵）</h3><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p><p>使用矩阵的方式，如果两个点存在一个则对应的数组的值为<code>1</code>，反之为<code>0</code></p><p>无向图的邻接矩阵表示法</p><ol><li><p>临界矩阵的特点</p><ul><li>对角线值为0</li><li>矩阵是对称的</li></ul></li><li><p>矩阵度的计算</p><p>定点<code>i</code>的度，就是第<code>i</code>行<code>1</code>的个数</p><p>特别的完全图的邻接矩阵中，对角线元素为0，其余为1</p></li></ol><p><strong>有向图的邻接矩阵表示法</strong></p><ol><li><p>同理，有箭头的则是<code>1</code>，也就是从该点指出去</p></li><li><p>第<code>i</code>行的含义</p><p>以节点v<del>i</del>为结尾的弧（出度）</p></li><li><p>第<code>i</code>列的含义</p><p>以节点v<del>i</del>为头的弧（入度）</p></li><li><p>有向图的度</p><p>是出度和入度的和</p></li></ol><p><strong>邻接矩阵的实现</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100   <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>VerTexType vexs[MVNum];   <span class="hljs-comment">//定点表</span><br>ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125;AMGraph;<br><br></code></pre></td></tr></table></figure><p><strong>网的表示法</strong></p><ol><li>将有连接的转变成权值而不是<code>1</code></li><li>没有连接的为<code>0</code></li></ol><p><strong>无向图的创建</strong></p><ol><li><p>算法思想</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E5%88%9B%E5%BB%BA.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100   <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> statue;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>VerTexType vexs[MVNum];   <span class="hljs-comment">//定点表</span><br>ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125;AMGraph,*pAMGraph;<br><br><br><span class="hljs-comment">//查找对应的下标</span><br><span class="hljs-comment">//int LocateVex(pAMGraph G,char ch) &#123;</span><br><span class="hljs-comment">//for (int i = 0; i &lt; G-&gt;vexnum; i++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//if (ch == G-&gt;vexs[i]) &#123;</span><br><span class="hljs-comment">//return i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//return -1;</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//&#125;</span><br><br>statu ue <span class="hljs-title function_">CreatUDN</span><span class="hljs-params">(pAMGraph *G)</span> &#123;<br><span class="hljs-type">int</span> x, y;<span class="hljs-comment">//模拟二维数组的x,y;</span><br><span class="hljs-type">char</span> aPoint,bPoint;<span class="hljs-comment">//</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;(*G)-&gt;vexnum, &amp;(*G)-&gt;arcnum);<br><span class="hljs-comment">//创建节点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (*G)-&gt;vexnum; i++)<br>&#123;<br>(*G)-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>&#125;<br><br><span class="hljs-comment">//初始化表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (*G)-&gt;arcnum; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (*G)-&gt;arcnum; j++)<br>&#123;<br>(*G)-&gt;arcs[i][j] = MaxInt;<br>&#125;<br>&#125;<br><span class="hljs-comment">//赋予权值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (*G)-&gt;arcnum; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (*G)-&gt;arcnum; j++)<br>&#123;<br>(*G)-&gt;arcs[i][j] = MaxInt;<br>&#125;<br>&#125; <br><br><span class="hljs-comment">////对每一条边进行赋值</span><br><span class="hljs-comment">//scanf(&quot;%c%c&quot;, &amp;aPoint,&amp;bPoint);//对a-&gt;b的边进行赋权</span><br><span class="hljs-comment">//x = LocateVex(G, aPoint);</span><br><span class="hljs-comment">//y = LocateVex(G, bPoint);</span><br><span class="hljs-comment">//for (int i = 0; i &lt; (*G)-&gt;vexnum; ++i) &#123;</span><br><span class="hljs-comment">//scanf(&quot;%d&quot;, &amp;(*G)-&gt;arcs[x][y]);</span><br><span class="hljs-comment">//(*G)-&gt;arcs[x][y] = (*G)-&gt;arcs[y][x];//无向网，所以邻接矩阵是对称的</span><br><br><span class="hljs-comment">//&#125;</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>pAMGraph G = (pAMGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AMGraph));<br>CreatUDN(&amp;G);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>邻接矩阵构建有向图</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%9C%89%E5%90%91%E5%9B%BE.png"></p><p><strong>使用邻接矩阵的优点</strong></p><blockquote><ol><li><p>直观简单</p></li><li><p>方便查看某个图的节点</p></li><li><p>方便查找任意节点的邻接点</p></li><li><p>方便计算出某个节点的度</p></li></ol></blockquote><p><strong>使用邻接矩阵的缺点</strong></p><blockquote><p>空间复杂度是O(n^2^)</p></blockquote><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><ol><li><p>邻接表 </p><p><strong>无向图</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E8%A1%A8.png"></p><ul><li><p>头结点</p><ul><li><p>第一个元素</p><p>存放定点的数据</p></li><li><p>第二个元素</p><p>存放边节点</p></li></ul></li><li><p>表结点（边节点）</p><ul><li><p>第一个元素</p><p>存放弧终点的节点</p></li><li><p>第二个元素</p><p>存放另一个弧终点的地址</p></li><li><p>第三个元素（图片无）</p><p>存放权值</p></li></ul></li><li><p>不唯一性</p><p>因为每一个边的链表顺序可以变</p><p>按道理来说，应该会有很多种</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9.png"></p></li><li><p>使用邻接矩阵创建邻接表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100       <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>    VerTexType vexs[MVNum];   <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125; AMGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> // 边表节点</span><br><span class="hljs-class">&#123;</span><br>    VerTexType adjvex; <span class="hljs-comment">// 与顶点相连的邻接点下标(adjoin：邻接)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向顶点的下一个邻接点</span><br>&#125; EdgeNode;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span>       // 顶点结构</span><br><span class="hljs-class">&#123;</span><br>    VerTexType vex;      <span class="hljs-comment">// 存储顶点名</span><br>    EdgeNode *firstedge; <span class="hljs-comment">// 边表头指针，指向顶点第一个邻接点</span><br>&#125; VertexNode, AdjList[MVNum];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatGraph</span><span class="hljs-params">(AMGraph **amGraph)</span> &#123;<br>    *amGraph = (AMGraph *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AMGraph));<br>    (*amGraph)-&gt;vexnum = <span class="hljs-number">0</span>;<br>    (*amGraph)-&gt;arcnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        (*amGraph)-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        (*amGraph)-&gt;vexnum++;<br><br>    &#125;<br>    <span class="hljs-comment">//创建邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*amGraph)-&gt;arcs[i][j]);<br>            <span class="hljs-keyword">if</span> ((*amGraph)-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<br>                (*amGraph)-&gt;arcnum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    (*amGraph)-&gt;arcnum /= <span class="hljs-number">2</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatAdjacencyList</span><span class="hljs-params">(AMGraph *amGraph, AdjList adjList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; amGraph-&gt;vexnum; ++i) &#123;<br>        adjList[i].vex = amGraph-&gt;vexs[i];<br>        adjList[i].firstedge = <span class="hljs-literal">NULL</span>;<br>        EdgeNode *moveNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; amGraph-&gt;vexnum; ++j) &#123;<br>            <span class="hljs-comment">//下面就是创建链表的过程，只是在第一个的时候相当于创建头节点</span><br>            <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//=1说明连同</span><br>                <span class="hljs-keyword">if</span> (adjList[i].firstedge == <span class="hljs-literal">NULL</span>) &#123;<br>                    adjList[i].firstedge=(EdgeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> node));<br>                    adjList[i].firstedge-&gt;adjvex = amGraph-&gt;vexs[j];<br>                    adjList[i].firstedge-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode = adjList[i].firstedge;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    EdgeNode *tem=(EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));<br>                    tem-&gt;adjvex=amGraph-&gt;vexs[j];<br>                    tem-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode-&gt;next=tem;<br>                    moveNode=moveNode-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    AMGraph *amGraph;<span class="hljs-comment">//邻接表</span><br>    AdjList adjList=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//邻接表的点集合，全部初始化</span><br>    <span class="hljs-type">int</span> ints[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//在搜索中，记录是否别查看</span><br>    creatGraph(&amp;amGraph);<span class="hljs-comment">//创建邻接矩阵</span><br>    creatAdjacencyList(amGraph,adjList);<span class="hljs-comment">//创建邻接表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>有向图</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8.png"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94.png"></p></li><li><p>邻接多重表</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.png"></p><p>每个数字后面的空格都是，存放指针，用于连接</p><ul><li>连接顺序不唯一</li></ul></li><li><p>十字链表</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png"></p><p>给顶点结点加一个指向出度边的指针</p><p>给狐结点添一个把该节点当成头节点的狐的数据域和指针域</p><p>优点：有利于找到出度和入度，通过<code>head</code>可以找到整个入度的边</p></li></ol><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul><li><p>遍历的实质</p></li><li><p>怎么防止重复访问？</p><p>图中含有回路，而且每一个顶点都与其他顶点相通，所以可能通过某一个过程又回到了原来的点</p><blockquote><p>设置一个辅助的数组，用来标记每一个被访问的顶点，初始状态为<code>0</code></p><p>被访问了，就应该改变状态</p></blockquote><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.png"></p></li></ul><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（<code>DFS</code>）</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><strong>邻接矩阵</strong></h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png"></p><ul><li><p>采取递归的方法</p></li><li><p>防止循环遍历，我们应该建立一个<code>visit</code>存放所有的结点，然后我们把遍历过的结点标识为<code>1</code></p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100       <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>    VerTexType vexs[MVNum];   <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125; AMGraph;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatGraph</span><span class="hljs-params">(AMGraph **amGraph)</span> &#123;<br>    *amGraph = (AMGraph *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AMGraph));<br>    (*amGraph)-&gt;vexnum = <span class="hljs-number">0</span>;<br>    (*amGraph)-&gt;arcnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        (*amGraph)-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        (*amGraph)-&gt;vexnum++;<br><br>    &#125;<br>    <span class="hljs-comment">//创建邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*amGraph)-&gt;arcs[i][j]);<br>            <span class="hljs-keyword">if</span> ((*amGraph)-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<br>                (*amGraph)-&gt;arcnum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    (*amGraph)-&gt;arcnum /= <span class="hljs-number">2</span>;<span class="hljs-comment">//无向边</span><br><br>&#125;<br><br><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(AMGraph *amGraph, <span class="hljs-type">int</span> visited[],<span class="hljs-type">int</span> sub)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,amGraph-&gt;vexs[sub]);<br>    visited[sub]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; amGraph-&gt;vexnum; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[sub][i]!=<span class="hljs-number">0</span>&amp;&amp;visited[i]==<span class="hljs-number">0</span>)&#123;<br>            DFS(amGraph,visited,i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    AMGraph *amGraph;<span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> ints[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//在搜索中，记录是否别查看</span><br>    creatGraph(&amp;amGraph);<span class="hljs-comment">//创建邻接矩阵</span><br>    DFS(amGraph,ints,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a><strong>邻接表</strong></h4><ul><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100       <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>    VerTexType vexs[MVNum];   <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125; AMGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> // 边表节点</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> adjvex; <span class="hljs-comment">// 与顶点相连的邻接点下标(adjoin：邻接)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向顶点的下一个邻接点</span><br>&#125; EdgeNode;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span>       // 顶点结构</span><br><span class="hljs-class">&#123;</span><br>    VerTexType vex;      <span class="hljs-comment">// 存储顶点名</span><br>    EdgeNode *firstedge; <span class="hljs-comment">// 边表头指针，指向顶点第一个邻接点</span><br>&#125; VertexNode, AdjList[MVNum];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatGraph</span><span class="hljs-params">(AMGraph **amGraph)</span> &#123;<br>    *amGraph = (AMGraph *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AMGraph));<br>    (*amGraph)-&gt;vexnum = <span class="hljs-number">0</span>;<br>    (*amGraph)-&gt;arcnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        (*amGraph)-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        (*amGraph)-&gt;vexnum++;<br><br>    &#125;<br>    <span class="hljs-comment">//创建邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*amGraph)-&gt;arcs[i][j]);<br>            <span class="hljs-keyword">if</span> ((*amGraph)-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<br>                (*amGraph)-&gt;arcnum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    (*amGraph)-&gt;arcnum /= <span class="hljs-number">2</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatAdjacencyList</span><span class="hljs-params">(AMGraph *amGraph, AdjList adjList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; amGraph-&gt;vexnum; ++i) &#123;<br>        adjList[i].vex = amGraph-&gt;vexs[i];<br>        adjList[i].firstedge = <span class="hljs-literal">NULL</span>;<br>        EdgeNode *moveNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; amGraph-&gt;vexnum; ++j) &#123;<br>            <span class="hljs-comment">//下面就是创建链表的过程，只是在第一个的时候相当于创建头节点</span><br>            <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//=1说明连同</span><br>                <span class="hljs-keyword">if</span> (adjList[i].firstedge == <span class="hljs-literal">NULL</span>) &#123;<br>                    adjList[i].firstedge=(EdgeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> node));<br>                    adjList[i].firstedge-&gt;adjvex = j;<br>                    adjList[i].firstedge-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode = adjList[i].firstedge;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    EdgeNode *tem=(EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));<br>                    tem-&gt;adjvex=j;<br>                    tem-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode-&gt;next=tem;<br>                    moveNode=moveNode-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-comment">/*void DFS(AMGraph *amGraph, int visited[],int sub) &#123;</span><br><span class="hljs-comment">    printf(&quot;%c&quot;,amGraph-&gt;vexs[sub]);</span><br><span class="hljs-comment">    visited[sub]=1;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; amGraph-&gt;vexnum; ++i) &#123;</span><br><span class="hljs-comment">        if (amGraph-&gt;arcs[sub][i]!=0&amp;&amp;visited[i]==0)&#123;</span><br><span class="hljs-comment">            DFS(amGraph,visited,i);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><br><br><span class="hljs-comment">//邻接表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(AdjList adjList,<span class="hljs-type">int</span> ints[],<span class="hljs-type">int</span> sub)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,adjList[sub].vex);<br>    ints[sub]=<span class="hljs-number">1</span>;<br>    EdgeNode *moveNode=adjList[sub].firstedge;<br>    <span class="hljs-keyword">while</span>(moveNode!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ints[moveNode-&gt;adjvex]==<span class="hljs-number">0</span>)&#123;<br>            DFS(adjList,ints,moveNode-&gt;adjvex);<br>        &#125;<br>        moveNode=moveNode-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    AMGraph *amGraph;<span class="hljs-comment">//邻接表</span><br>    AdjList adjList=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//邻接表的点集合，全部初始化</span><br>    <span class="hljs-type">int</span> ints[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//在搜索中，记录是否别查看</span><br>    creatGraph(&amp;amGraph);<span class="hljs-comment">//创建邻接矩阵</span><br>    creatAdjacencyList(amGraph,adjList);<span class="hljs-comment">//创建邻接表</span><br>    DFS(adjList,ints,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>稠密图适用于邻接矩阵上进行深度遍历</p><p>稀疏图适用于在邻接表上深度遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/DFS%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.png"></p><h4 id="非连通图"><a href="#非连通图" class="headerlink" title="非连通图"></a>非连通图</h4><ol><li>可以想象成两个图，然后增加一个虚拟节点，将图穿起来</li><li>如果图的数量不是2个，那就只能在非第一次遍历的图中再选一个图的随机的一个节点开始遍历</li></ol><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><h4 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100       <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AMGraph</span> &#123;<br>    VerTexType vexs[MVNum];   <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125; AMGraph, *pAMGraph;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatGraph</span><span class="hljs-params">(pAMGraph &amp;amGraph, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>    amGraph = <span class="hljs-keyword">new</span> AMGraph;<br>    amGraph-&gt;arcnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        amGraph-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>    &#125;<br>    amGraph-&gt;vexnum = num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; ++j) &#123;<br>            cin &gt;&gt; amGraph-&gt;arcs[i][j];<br>            <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[i][j] != <span class="hljs-number">0</span>) &#123;<br>                amGraph-&gt;arcnum++;<span class="hljs-comment">//计算边数</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    amGraph-&gt;arcnum /= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(pAMGraph amGraph, <span class="hljs-type">int</span> ints[], <span class="hljs-type">int</span> sub)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(sub);<span class="hljs-comment">//先push，进入循环，但是记得在ints里面标记被push</span><br>    ints[sub]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; amGraph-&gt;vexnum; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[queue.<span class="hljs-built_in">front</span>()][i] == <span class="hljs-number">1</span>&amp;&amp;ints[i]==<span class="hljs-number">0</span>) &#123;<br>                queue.<span class="hljs-built_in">push</span>(i);<br>                ints[i]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;amGraph-&gt;vexs[queue.<span class="hljs-built_in">front</span>()];<br>        queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    pAMGraph amGraph = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> num;<br>    cin &gt;&gt; num;<span class="hljs-comment">//输入节点数</span><br>    <span class="hljs-built_in">creatGraph</span>(amGraph, num);<br>    <span class="hljs-type">int</span> *ints=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[num];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        *(ints+i)=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-comment">//将被查看表全部设为0</span><br>    <span class="hljs-built_in">BFS</span>(amGraph, ints, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">delete</span>[] ints;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767   <span class="hljs-comment">//有向表的正无穷</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100       <span class="hljs-comment">//最大定点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;   <span class="hljs-comment">//定点的类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">//权值</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMGraph</span> &#123;</span><br>    VerTexType vexs[MVNum];   <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum];   <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前点数和边的数目</span><br>&#125; AMGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> // 边表节点</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> adjvex; <span class="hljs-comment">// 与顶点相连的邻接点下标(adjoin：邻接)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向顶点的下一个邻接点</span><br>&#125; EdgeNode;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span>       // 顶点结构</span><br><span class="hljs-class">&#123;</span><br>    VerTexType vex;      <span class="hljs-comment">// 存储顶点名</span><br>    EdgeNode *firstedge; <span class="hljs-comment">// 边表头指针，指向顶点第一个邻接点</span><br>&#125; VertexNode, AdjList[MVNum];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatGraph</span><span class="hljs-params">(AMGraph **amGraph,<span class="hljs-type">int</span> num)</span> &#123;<br>    *amGraph = (AMGraph *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(AMGraph));<br>    (*amGraph)-&gt;vexnum = <span class="hljs-number">0</span>;<br>    (*amGraph)-&gt;arcnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        (*amGraph)-&gt;vexs[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        (*amGraph)-&gt;vexnum++;<br><br>    &#125;<br>    <span class="hljs-comment">//创建邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*amGraph)-&gt;arcs[i][j]);<br>            <span class="hljs-keyword">if</span> ((*amGraph)-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<br>                (*amGraph)-&gt;arcnum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    (*amGraph)-&gt;arcnum /= <span class="hljs-number">2</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatAdjacencyList</span><span class="hljs-params">(AMGraph *amGraph, AdjList adjList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; amGraph-&gt;vexnum; ++i) &#123;<br>        adjList[i].vex = amGraph-&gt;vexs[i];<br>        adjList[i].firstedge = <span class="hljs-literal">NULL</span>;<br>        EdgeNode *moveNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; amGraph-&gt;vexnum; ++j) &#123;<br>            <span class="hljs-comment">//下面就是创建链表的过程，只是在第一个的时候相当于创建头节点</span><br>            <span class="hljs-keyword">if</span> (amGraph-&gt;arcs[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//=1说明连同</span><br>                <span class="hljs-keyword">if</span> (adjList[i].firstedge == <span class="hljs-literal">NULL</span>) &#123;<br>                    adjList[i].firstedge=(EdgeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> node));<br>                    adjList[i].firstedge-&gt;adjvex = j;<br>                    adjList[i].firstedge-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode = adjList[i].firstedge;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    EdgeNode *tem=(EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));<br>                    tem-&gt;adjvex=j;<br>                    tem-&gt;next=<span class="hljs-literal">NULL</span>;<br>                    moveNode-&gt;next=tem;<br>                    moveNode=moveNode-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-comment">/*void DFS(AMGraph *amGraph, int visited[],int sub) &#123;</span><br><span class="hljs-comment">    printf(&quot;%c&quot;,amGraph-&gt;vexs[sub]);</span><br><span class="hljs-comment">    visited[sub]=1;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; amGraph-&gt;vexnum; ++i) &#123;</span><br><span class="hljs-comment">        if (amGraph-&gt;arcs[sub][i]!=0&amp;&amp;visited[i]==0)&#123;</span><br><span class="hljs-comment">            DFS(amGraph,visited,i);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><br><br><span class="hljs-comment">//邻接表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(AdjList adjList,<span class="hljs-type">int</span> ints[],<span class="hljs-type">int</span> sub)</span>&#123;<br>    <span class="hljs-keyword">if</span>(adjList[sub].vex==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ints[sub]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,adjList[sub].vex);<br>        ints[sub]=<span class="hljs-number">1</span>;<br>    &#125;<br>    EdgeNode *moveNode=adjList[sub].firstedge;<br>    <span class="hljs-keyword">while</span>(moveNode!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ints[moveNode-&gt;adjvex]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,adjList[moveNode-&gt;adjvex].vex);<br>            ints[moveNode-&gt;adjvex]=<span class="hljs-number">1</span>;<br>        &#125;<br>        moveNode=moveNode-&gt;next;<br>    &#125;<br>    BFS(adjList,ints,sub+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    AMGraph *amGraph;<span class="hljs-comment">//邻接表</span><br>    AdjList adjList=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//邻接表的点集合，全部初始化</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input the number of node: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>    <span class="hljs-type">int</span>* ints = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (<span class="hljs-type">int</span>)*num);<span class="hljs-comment">//在搜索中，记录是否别查看</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        *(ints+i)=<span class="hljs-number">0</span>;<br>    &#125;<br>    creatGraph(&amp;amGraph,num);<span class="hljs-comment">//创建邻接矩阵</span><br>    creatAdjacencyList(amGraph,adjList);<span class="hljs-comment">//创建邻接表</span><br>    BFS(adjList,ints,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/BFS%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87.png"></p><h4 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/BFS%E5%92%8CDFS%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%88%E7%9B%8A%E6%AF%94%E8%BE%83.png"></p><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ol><li><p>概念回顾</p><ul><li><p>生成树</p><p>所有的顶点，均有边连接起来，不存在回路；也就是全部顶点，部分边</p></li></ul></li><li><p>理论基础</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%9B%BE/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆波兰表达式求值</title>
    <link href="/2023/04/19/newcoder/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/04/19/newcoder/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/885c1db3e39040cbae5cdf59fb0e9382?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">逆波兰表达式求值_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.png"></p><ol><li><p>代码</p><p>自己的版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param tokens string字符串vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//return</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item:tokens)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                num=std::<span class="hljs-built_in">stoi</span>(item.<span class="hljs-built_in">data</span>());<br>                stack.<span class="hljs-built_in">push</span>(num);<br>            &#125;<span class="hljs-built_in">catch</span> (...)&#123;<br>                <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;+&quot;</span>)&#123;<br>                    num=stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    sum=stack.<span class="hljs-built_in">top</span>()+num;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    stack.<span class="hljs-built_in">push</span>(sum);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;-&quot;</span>)&#123;<br>                    num=stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    sum=stack.<span class="hljs-built_in">top</span>()-num;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    stack.<span class="hljs-built_in">push</span>(sum);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                    num=stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    sum=num*stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    stack.<span class="hljs-built_in">push</span>(sum);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                    num=stack.<span class="hljs-built_in">top</span>();<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    sum=stack.<span class="hljs-built_in">top</span>()/num;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                    stack.<span class="hljs-built_in">push</span>(sum);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    cout&lt;&lt;<span class="hljs-string">&quot;input error&quot;</span>&lt;&lt;endl;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存在的问题是，选择太太多了，代码冗长</span><br><span class="hljs-comment"> * try,catch的性能消耗过大</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param tokens string字符串vector</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item: tokens)&#123;<br>            <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;+&quot;</span>||item==<span class="hljs-string">&quot;-&quot;</span>||item==<span class="hljs-string">&quot;*&quot;</span>||item==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                <span class="hljs-type">int</span> num=stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2=stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;+&quot;</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(num2+num);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;-&quot;</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(num2-num);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(num*num2);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(num2/num);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stoi</span>(item));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E6%8F%90%E7%A4%BA.gif"></p></li><li><p>理解</p><ul><li>通过压栈存放临时数据</li></ul></li><li><p>问题</p><ul><li><p>为什么<code>try``catch</code>语句，性能消耗大？</p><blockquote><p>使用 <code>try</code> 和 <code>catch</code> 可以在程序运行时捕获并处理异常。然而，由于异常处理需要额外的开销，如果在代码中频繁地使用 <code>try</code> 和 <code>catch</code>，会对程序的性能产生影响。</p><p>具体来说，当程序出现异常时，C++ 运行时系统需要在堆栈上创建一个异常对象，并执行一系列系统调用来查找匹配的 <code>catch</code> 块。这个过程需要进行堆栈展开（stack unwinding），将程序从异常抛出点回退到能够处理异常的 <code>catch</code> 块处。由于堆栈展开需要降低程序的执行速度，并且需要额外的内存和调用开销，因此异常处理可能会对程序的性能产生负面影响。</p><p>总的来说，在代码中使用 <code>try</code> 和 <code>catch</code> 不会直接影响程序的性能，但是在发生异常时需要进行额外的处理，从而可能导致程序变慢。因此，在实际编写代码时，应该避免滥用异常处理，仅在必要时使用 <code>try</code> 和 <code>catch</code> 来处理异常，以提高程序的性能和效率。</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux随记</title>
    <link href="/2023/04/19/linux/linux%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/19/linux/linux%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="linux随记"><a href="#linux随记" class="headerlink" title="linux随记"></a>linux随记</h1><ol><li><p>sudo </p><p>在Linux系统中，sudo是一种特殊权限（superuser do）命令，允许普通用户以超级管理员的身份执行特定任务或命令。管理员可以使用sudo命令来授权其他用户执行某些特定操作，而无需共享root账户密码</p></li><li><p><code>Ctrl+l</code></p><p>清屏 </p></li><li><p><code>-R</code></p><p>表示递归的参数，用于文件夹相关的参数</p></li><li><p><code>su - root</code></p><p>切换到<code>root</code>用户</p></li><li><p><code>exit</code></p><p>用于退出<code>root</code></p></li><li><p><code>|</code>管道符</p><p>把管道符左边的结果，作为右边命令的输入</p></li><li><p><code>Ctrl+x</code></p><p>也可以用于退出<code>root</code></p></li><li><p><code>shell</code>编程里面</p><p><code>#</code>后面都是注释</p></li><li><p><code>./</code>执行文件</p></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>linux随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用指令</title>
    <link href="/2023/04/17/linux/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/04/17/linux/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ol><li><p><code>LInux</code>的根目录是树形结构</p><p>Linux没有盘符（C盘等）的概念，只有一个根目录<code>/</code></p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p></li><li><p>文件路径的描述方式</p><p>使用<code>/</code></p><p><code>windows</code>使用<code>\</code></p><ul><li>注意文件路径的开始必须是<code>/</code>,第一个是根目录，后面的是层级关系</li></ul></li></ol><h2 id="LInux命令入门"><a href="#LInux命令入门" class="headerlink" title="LInux命令入门"></a>LInux命令入门</h2><ol><li><p>通用格式</p><p><code>command [-options] [parameter]</code></p><ul><li>command 命令本身</li><li>-options 可选的选项(非必填)</li><li>parameter 可选的选项(非必填)</li></ul></li><li><p>ls -r &#x2F;home</p><p>查看<code>home</code>里面的东西</p></li></ol><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/ls%E5%91%BD%E4%BB%A4.png"></p><ul><li><p>默认的工作目录是<code>home</code>目录</p></li><li><p>以平埔的形式展示子目录</p></li><li><p>小结</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/ls%E6%80%BB%E7%BB%93.png"></p></li></ul><ol><li><p>ls 的参数</p><ul><li><code>-a</code> all 列出全部文件（包括隐藏文件）</li><li><code>-l</code> 以列表的形式展示内容，并展示更多的信息</li><li>组和（指的是多个指令同时）<ul><li><code>-l -a</code></li><li><code>-ls</code></li><li><code>-al</code></li></ul></li><li><code>ls -l -a /</code>在根目录上使用<code>-a -l</code></li></ul><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/ls%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.png"></p></li></ol><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/cd.png"></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/pwd.png"></p><ul><li><code>.</code>表示当前目录</li><li><code>..</code>表示上一级目录</li><li><code>~</code>表示<code>home</code>目录</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/mkdir.png"></p><ul><li><p><code>-p</code> 创建一整个链条</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/mkdir_p.png"></p></li></ul><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/touch.png"></p><p>如果原来有这个文件，则修改这个文件的标签，使得时间域本电脑时间一致</p><p>如果没有这个文件，则创建这个文件</p><ol><li><p>文件夹的颜色时深色</p><p>同时还可以使用<code>ls</code>如果前缀是<code>d</code>则是文件夹，是<code>-</code>是文件</p></li></ol><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a><code>comm</code></h3><p>比较已排序的两个人间的差异</p><ul><li><code>-1</code>：不打印出只存在于第一个文件中的行。</li><li><code>-2</code>：不打印出只存在于第二个文件中的行。</li><li><code>-3</code>：不打印出共同存在于两个文件中的行。</li><li><code>-i</code>：在比较时忽略大小写。</li><li><code>-u</code>：以一列输出文件的内容。</li></ul><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a><code>wc</code></h3><p>是一种计算文件字数、行数、字符数等信息的命令。它可以统计给定文件中的行数、单词数和字符数。</p><ul><li><code>-l</code>：仅显示行数。</li><li><code>-w</code>：仅显示单词数。</li><li><code>-m</code>：仅显示字符数。</li><li><code>-c</code>：仅显示字节数。</li><li><code>-L</code>：仅显示最长行的长度。</li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a><code>grep</code></h3><p>是一种命令行文本搜索工具，它可以根据用户提供的正则表达式在一个或多个文件中搜索匹配的行，并将其输出到标准输出。</p><ul><li><code>-c</code>：只显示搜索结果的数量，而不是每一行的内容。</li><li><code>-i</code>：忽略所搜索单词的大小写。</li><li><code>-n</code>：在输出结果中包含被匹配行的行号。</li><li><code>-v</code>：反转匹配，只输出不匹配的行。</li><li><code>-r</code>：递归搜索文件夹内所有文件。</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h3><ol><li><p>查看文件内容</p><p>语法： <code>cat [options] filename</code></p><p>示例： <code>cat file.txt</code></p><p>说明：该命令可以查看指定的文本文件内容。如果需要同时查看多个文件内容，可以在命令行中依次输入多个文件名即可。</p></li><li><p>创建文件</p><p>语法：<code>cat &gt; filename</code></p><p>示例： <code>cat &gt; test.txt</code></p><p>说明：该命令可以在命令行中输入文本，然后以Ctrl + D的方式结束输入，并将输入内容保存到指定的文件中。如果文件已经存在，新输入的内容会覆盖旧的内容。</p></li><li><p>合并多个文件</p><p>语法： <code>cat [option] file1 file2 &gt; newfile</code></p><p>示例： <code>cat file1.txt file2.txt &gt; mergedfile.txt</code></p><p>说明：该命令可以将多个文件合并为一个新文件。在上面的示例中，两个文件(file1.txt和file2.txt)的内容被合并到一个新文件(mergedfile.txt)中。</p></li><li><p>压缩输出信息</p><p>语法： <code>cat [options] filename | gzip &gt; filename.gz</code></p><p>示例： <code>cat file.txt | gzip &gt; file.gz</code></p></li></ol><h3 id="more"><a href="#more" class="headerlink" title="more"></a><code>more</code></h3><ol><li>more可以用于查看，相对于<code>cat</code>，<code>more</code>支持翻页</li><li>使用<code>q</code>退出浏览状态</li></ol><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/cp%E5%91%BD%E4%BB%A4.png"></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/mv.png"></p><p>如果目的地不存在，那么这个文件就会改名成为目标文件</p><p>而且支持文件夹的移动</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/rm.png"></p><p>注意删除文件夹需要<code>-r</code></p><p>可以写多个参数，表示删除多个项目</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/rm%E9%80%9A%E9%85%8D%E7%AC%A6.png"></p><h3 id="which"><a href="#which" class="headerlink" title="which"></a><code>which</code></h3><p>用于查找命令的执行文件</p><ol><li><p>语法</p><p><code>which</code> 要查找的命令</p></li></ol><h3 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h3><p>用于查找文件</p><ol><li><p>命令</p><p><code>find / -name &quot;filename&quot;</code></p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/find.png"></p></li><li><p>也可以使用通配符</p><p><code>find 起始路径 -name &quot;*text*&quot;</code></p></li><li><p>使用文件大小</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/find%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F.png"></p></li></ol><h3 id="grep-1"><a href="#grep-1" class="headerlink" title="grep"></a><code>grep</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/grep.png"></p><h3 id="wc-1"><a href="#wc-1" class="headerlink" title="wc"></a><code>wc</code></h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/wc.png"></p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a><code>echo</code></h3><p>在对话框中打印</p><ol><li><p>语法</p><p><code>echo</code> 输出的内容</p></li><li><p>反引号 </p><p>&#96;&#96;将所包括的内容作为命令输出</p></li><li><p>重定向符</p><p><code>&gt;</code> 将左侧命令覆盖到写入到符号右侧指定的文件中</p><p><code>&gt;&gt;</code>将左侧命令的结果，追加到右侧的指定文件中</p></li></ol><h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a><code>vim</code>文本编辑器</h3><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/vim.png"></p><ol><li><p><code>vim</code> 文件路径</p><p>如果不存在，将会编写新的文件</p><p>存在就只会编辑已有的命令</p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/vim%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F.png"></p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE.png"></p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%BF%AB%E6%8D%B7%E9%94%AE.png"></p></li></ol><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a><code>ln</code></h3><p>它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p><p>可以看成创建一个快捷方式</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h3><blockquote><p>chmod [权限设置方式] [文件名]</p></blockquote><ol><li><p>它允许用户改变文件或目录的读取、写入和执行权限。它可用于设置文件的所有者、组、其他用户的访问权限。</p></li><li><p>权限表示有读(r)、写(w)、执行(x)三种，用字母或数字来表示。其中，字母表示法为 “u” 表示文件所有者，”g” 表示文件所属组，”o” 表示其他用户， “a” 表示所有用户。</p><ul><li><p>数字表示法</p><p>- </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">644</span> example.txt<br></code></pre></td></tr></table></figure><p>将文件 example.txt 的权限修改为 6（110）（所有者读写）、4（100）（组只读）和 4（100）（其他用户只读）。</p></li><li><p>符号表示法</p><p>使用符号表示法，命令格式为：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">chmod [who] [+ | - | =] [permission] <span class="hljs-symbol">FILE</span>...<br></code></pre></td></tr></table></figure><p>其中 [who] 可以是 u（所有者）、g（所属组）、o（其他用户）、a（所有用户），+ 表示新增权限，- 表示移除权限，&#x3D; 表示赋予权限。</p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概述</title>
    <link href="/2023/04/17/linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/04/17/linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>计算机由哪两个部分组成</p><p>软件和硬件</p></li><li><p>操作系统是什么？</p><p>操作系统是软件的一种</p><p>主要作用是协助用户调度硬件工作充当用户和计算机硬件之间的桥梁</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效括号序列</title>
    <link href="/2023/04/17/newcoder/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    <url>/2023/04/17/newcoder/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">有效括号序列_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>                stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;item: s) &#123;<br>            <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;[&#x27;</span> || item == <span class="hljs-string">&#x27;(&#x27;</span> || item == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack.<span class="hljs-built_in">push</span>(item);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;]&#x27;</span> || item == <span class="hljs-string">&#x27;)&#x27;</span> || item == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-comment">//防止栈区为empty，还取出top</span><br>                <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//防止出现只有右开口符号的请情况</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>改进代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item:s)&#123;<br>            <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-comment">//防止空取top</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==stack.<span class="hljs-built_in">top</span>())&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//提高执行效率，如果不对应，就直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">empty</span>();<br>        <span class="hljs-comment">//当true,则说明一一对应</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E6%8F%90%E7%A4%BA.gif"></p></li><li><p>理解</p><ul><li>整体只会遍历一次，遇到开口向右的符号就存进<code>stack</code>，反之对比出栈</li></ul></li><li><p>问题</p><ul><li><p>为什么返回<code>stack.empty()</code></p><blockquote><p>有且仅当，一一对应时才能返回</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp代码规范</title>
    <link href="/2023/04/14/c++/cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2023/04/14/c++/cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="c-代码规范"><a href="#c-代码规范" class="headerlink" title="c++代码规范"></a>c++代码规范</h1><h2 id="基本代码规范"><a href="#基本代码规范" class="headerlink" title="基本代码规范"></a>基本代码规范</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>方法一</strong></p><ol><li>包括两个文件一个是<code>inc</code>这个目录放<code>.h</code>文件，还有一个<code>src</code>目录，放置<code>.cpp</code>文件。</li></ol><p><strong>方法二</strong></p><ol><li>按照功能分文件</li></ol><h3 id="头文件结构"><a href="#头文件结构" class="headerlink" title="头文件结构"></a>头文件结构</h3><p><strong>处理方式一</strong></p><ol><li>使用<code>ifndef</code>&#x2F;<code>define</code>&#x2F;<code>endif</code></li></ol><p><strong>处理方式二</strong></p><ol><li>使用<code>#pragma once</code></li></ol><h3 id="头文件的包含"><a href="#头文件的包含" class="headerlink" title="头文件的包含"></a>头文件的包含</h3><ol><li>使用路径包括</li></ol><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><ol><li>建议使用二级命名空间，第一个命名空间是项目名称，第二个是模块名称</li></ol><h3 id="代码行的使用"><a href="#代码行的使用" class="headerlink" title="代码行的使用"></a>代码行的使用</h3><ol><li><p>一行代码只做一件事</p></li><li><p>在定义变量的时候初始化变量</p><img src="https://pictuures-1317182407.cos.ap-chengdu.myqcloud.com/%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81.png?q-sign-algorithm=sha1&q-ak=AKID62gNbIugj-rlltKDtx9qQ0_NXvaVQ5eNhwwxGkulFmHBe0ryycrOgtLN1PJ48AwE&q-sign-time=1681488019;1681491619&q-key-time=1681488019;1681491619&q-header-list=host&q-url-param-list=&q-signature=e4a689d272023a355d0531e4c2a8e304b91e3f84&x-cos-security-token=0TXuI2oo8Sb5JGse9bsw7agND0rUgf7ab53099746c0362b69c92e54403bee6c1Ar87iX4JGt_CJ_4-yiOqn5qq0oYOzq5Mvx5tZYU4UMH4CzPOLXAXckkgflDKpLF8EFsMkPbIaiZBHDbuZKO7M7wuhqklRkTpvoysQC3p_jlBgtUCJW9hscAxiDk_3qQDgHzlDrdCKzHaDdduRuoDolrxPPI9XoPQLvaqMiBwujWJDhXsHm8ruOPtekvK2ev8" style="zoom:150%;" /></li></ol><h3 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h3><ol><li>版本，版权的说明</li><li>函数接口的说明</li><li>重要代码</li><li>代码即注释</li></ol><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li><p><code>class</code></p><p>采取大驼峰命名法</p><p>例如<code>MyClass</code></p></li><li><p>函数</p><p>采取驼峰命名</p></li><li><p>也可以在中间添加<code>_</code></p><p><code>creat_func</code>前后都是小写</p></li><li><p>变量命名</p><p>变量的意思</p></li></ol><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ol><li>添加<code>()</code></li><li>不编写太复杂的表达式</li></ol><h2 id="概念抽象与命名"><a href="#概念抽象与命名" class="headerlink" title="概念抽象与命名"></a>概念抽象与命名</h2><ol><li>类的命名是名词</li><li>函数是动词</li></ol><h2 id="大道至简"><a href="#大道至简" class="headerlink" title="大道至简"></a>大道至简</h2><ol><li>模块复用</li><li>化繁为简</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的压入和弹出序列</title>
    <link href="/2023/04/13/newcoder/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2023/04/13/newcoder/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.png"></p><ol><li><p>代码</p><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV, vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, n = pushV.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : popV) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; (stack.<span class="hljs-built_in">empty</span>() || stack.<span class="hljs-built_in">top</span>() != item)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(pushV[j++]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>() == item) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二（自写）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV, vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pushV.<span class="hljs-built_in">size</span>() != popV.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; pushV.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; pushV.<span class="hljs-built_in">size</span>() &amp;&amp;i &gt;= <span class="hljs-number">0</span>&amp;&amp; pushV[i] == popV[j] ) &#123;<br>                pushV.<span class="hljs-built_in">erase</span>(pushV.<span class="hljs-built_in">begin</span>() + i);<br>                i--;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (popV.<span class="hljs-built_in">size</span>() == j) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>提示</p><p>方法一：</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.gif"></p><p>方法二：</p><ol><li>遍历<code>push</code>，如果当发现<code>push</code>的元素与<code>pop</code>的元素相等的话，我们就选择将这个<code>push</code>元素<code>erase</code>,并且将下标往前移动一，也就是<code>i--</code></li><li>如果发现<code>pop</code>也都遍历完了，我们就<code>return</code>成功。如果<code>push</code>的下标超过了<code>push.size()</code>我们就选择<code>return false</code></li></ol></li><li><p>理解</p><p>方法一</p><ul><li><p>确保push遍历完时，还可以遍历pop，所以采取遍历pop的方式</p></li><li><p>借助辅助栈，对比是否出栈的顺序是否一致</p></li><li><p>整体的思路如下</p><p>当push没有遍历完，且栈是空或者栈顶不和pop一致，应该往栈push</p><p>如果发现栈顶的值与pop的一致，应该跳出循环，并将栈顶的元素弹出</p><p>如果当push走完时，栈顶元素不和pop相等则说明不相等</p></li><li><p>当两个vector都遍历完时，则说明序列一致</p></li></ul><p>方法二</p><ul><li>将<code>push</code>拿来遍历，如果push都走完了，我们的<code>pop</code>还没走完就选择<code>return false</code></li><li>如果<code>size</code>都不相等，就像应该直接返回<code>false</code></li></ul></li><li><p>问题</p><p>方法一</p><ul><li><p>如何确保push完全走完</p><blockquote><p>循环遍历pop</p></blockquote></li></ul><p>方法二</p><ul><li><p>如何防止<code>popV</code>越界</p><blockquote><p>使用i&gt;&#x3D;0，如果该条件不满足，则说明已经遍历完成</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表结点</title>
    <link href="/2023/04/12/newcoder/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/"/>
    <url>/2023/04/12/newcoder/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">删除链表的节点_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param head ListNode类</span><br><span class="hljs-comment">     * @param val int整型</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* moveNode=dummy;<br>        <span class="hljs-keyword">while</span>(moveNode-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(moveNode-&gt;next-&gt;val==val)<br>            &#123;<br>                moveNode-&gt;next=moveNode-&gt;next-&gt;next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            moveNode=moveNode-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>        <span class="hljs-comment">/*        ListNode* moveNode = head;</span><br><span class="hljs-comment">                ListNode* pre=head;</span><br><span class="hljs-comment">                if(head-&gt;val==val)&#123;</span><br><span class="hljs-comment">                    return head-&gt;next;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                while (moveNode != nullptr) &#123;</span><br><span class="hljs-comment">                    if (moveNode-&gt;val == val) &#123;</span><br><span class="hljs-comment">                        pre-&gt;next=moveNode-&gt;next;</span><br><span class="hljs-comment">                        moveNode = moveNode-&gt;next;</span><br><span class="hljs-comment">                        break;</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                    pre=moveNode;</span><br><span class="hljs-comment">                    moveNode = moveNode-&gt;next;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                return head;*/</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注释是自己的方法</p></li><li><p>提示</p><ul><li>对来链表操作，或者返回链表的使用虚拟头节点</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随记</title>
    <link href="/2023/04/12/java/java%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/12/java/java%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>java的初始化</p><p>Java的初始化是指在创建对象时为其成员变量设定初值的过程。Java中的所有对象在创建时，其成员变量都会被默认初始化为其对应类型的默认值（如int类型的默认值为0，引用类型的默认值为null）。如果需要对成员变量进行显式初始化，可以通过构造函数、代码块或直接赋值的方式实现。</p><p>构造函数是一种特殊的方法，用于在创建对象时执行一些初始化操作。在Java中，每个类都有一个与之同名的构造函数，可以通过这个构造函数来初始化对象的成员变量。如果没有定义构造函数，Java会提供一个默认构造函数，但是默认构造函数不会做任何事情。</p><p>除了构造函数，Java还提供了代码块的概念。<strong>代码块分为静态代码块和非静态代码块。静态代码块在类加载时执行，非静态代码块在每次创建对象时都会执行。代码块中的语句可以用来初始化成员变量。</strong></p></li><li><p><code>java</code>获得数组的长度使用<code>arr.length</code></p><p>在Java中，数组有一个属性 length，用于表示数组的长度。在本题中，数组 arr 的长度为 10，可以使用 <code>arr.length</code> 来获得数组的长度。注意，这里的 length 不是方法，而是成员变量，因此无需使用括号表示。</p></li><li><p><code>string.concat()</code> 将两个字符串连在一起，返回新的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str1.concat(str2);<br>System.out.println(str3);<br></code></pre></td></tr></table></figure></li><li><p>java什么时候传形参，什么时候传引用？</p><p>在Java中，所有基本类型（如 int、double、boolean 等）都是按值传递的，也就是说，在将基本类型作为参数传递给方法时，实际上传递的是该基本类型的值的副本。任何对这个副本的修改都不会影响到原始的基本类型变量。</p><p>而对于对象类型，Java传递的则是对象引用的副本。对象引用是一个存储在栈内存中的值，它指向堆内存中的一个对象。当将一个对象作为参数传递给方法时，实际上传递的是该对象引用的副本，也就是说，传递的是一个指向原始对象的副本。这种方式称为按引用传递。</p><p>虽然 Java 使用的是按值传递的机制，但因为对象引用传递的实现方式，使得在方法内部可以修改该对象的状态，例如通过调用对象的 setter 方法改变其属性值，或通过调用对象的方法改变其内部状态等。此时，由于传递的是对象的引用，方法内部的修改也会影响原始对象。</p><p>需要注意的是，在 Java 中不支持传递引用的方式，如果想要实现类似 C++ 中的传递引用，则需要使用 Java 的封装类型（例如 Integer、Double、Boolean 等）。这些类型都是对象类型，因此在传递这些类型的变量时，实际上是传递了对象引用的副本，因此也可以在方法内部修改其状态。</p></li><li><p><code>substring(1,5)</code></p><p>获取字符串中第1个元素到到5前一个元素</p></li><li><p>构造方法不能是静态的</p></li><li><p>使用<code>javac</code>将<code>java</code>文件编译成<code>.class</code>文件</p><p>使用<code>java</code> 运行文件</p></li><li><p><code>java</code>代码块</p><ul><li><p>静态代码块</p><p>只在类的加载时执行一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <span class="hljs-comment">//初始化static 变量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-comment">//每次类的加载都会执行</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>局部代码块</p><p>用于限定生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> func&#123;<br>    &#123;<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-comment">//限制num的生命周期</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步代码块</p><p>确保线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 同步方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步代码块，保证线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Math类</p><ol><li><code>abs()</code>：返回一个数的绝对值。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>ceil()</code>：返回大于或等于参数的最小整数，即向上取整。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>floor()</code>：返回小于或等于参数的最大整数，即向下取整。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>round()</code>：返回四舍五入后的最接近的整数。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>max()</code>：返回两个值中较大的那个。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>min()</code>：返回两个值中较小的那个。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>pow(double a, double b)</code>：返回a的b次幂。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>sqrt()</code>：返回一个数的平方根。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>sin()</code>：返回一个角度的正弦值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/sin">2</a>]</li><li><code>cos()</code>：返回一个角度的余弦值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/cos">2</a>]</li><li><code>tan()</code>：返回一个角度的正切值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/tan">2</a>]</li><li><code>asin()</code>：返回一个数值的反正弦值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/asin">2</a>]</li><li><code>acos()</code>：返回一个数值的反余弦值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/acos">2</a>]</li><li><code>atan()</code>：返回一个数值的反正切值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/atan">2</a>]</li><li><code>exp()</code>：返回 <code>Math.E</code>（自然对数的底数）的指数。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/exp">2</a>]</li><li><code>log()</code>：返回一个数的自然对数（以e为底数）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/log">2</a>]</li><li><code>random()</code>：返回一个随机数，范围为0到1。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li></ol></li><li><p><code>java</code>使用代码块对static变量进行赋值和直接赋值的区别？</p></li><li><p>执行时机</p><p>直接给static变量赋值时，赋值操作会在类加载时执行，也就是说，当 JVM 加载该类时，就会把static变量的初始值存储到内存中。</p><p>   而代码块则需要等到该类被实例化时才会执行。也就是说，当该类被使用时，代码块中的语句才会执行，从而给static变量赋值。</p></li><li><p>赋值方式</p><p>直接给static变量赋值是一种简单的方式，它可以直接在变量后跟一个等号，然后紧接着赋值的表达式。</p><p>   而代码块提供了更多灵活的赋值方式，我们可以在代码块中编写任意复杂的逻辑来计算出static变量的值，更加符合面向对象的设计思想。</p><p>   综合来看，我们可以根据具体的场景选择不同的方式对static变量进行赋值。如果我们需要简单地给变量赋一个常量值，那么可以直接使用赋值操作；如果我们需要进行一些特殊的计算，或者需要依赖其他变量的值来计算static变量的值，那么可以使用代码块来进行赋值。</p></li><li><p>使用<code>scanner</code>输入字符的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;您输入的字符是：&quot;</span> + c);<br></code></pre></td></tr></table></figure></li><li><p>关于线程</p><p>多线程是指将CPU资源按时间片分配到多个任务上，看似并行工作，实质上在同一时刻只有一个线程在工作；在一段时间之内，是多个线程在同时工作。</p></li><li><p>不含公共类的文件命名</p><p>不含公共类的Java源文件的命名可以使用任何合法的标识符来命名，但必须以<code>.java</code>文件扩展名结尾。这个文件名称一般会反映该文件中定义的类的用途。</p></li><li><p>在Windows操作系统和Linux操作系统运行的JAVA虚拟机没有什么差别</p></li><li><p>在 Java 中，<code>&amp;&amp;</code> 和 <code>||</code> 是短路逻辑运算符（short-circuit logical operators），而 <code>&amp;</code> 和 <code>|</code> 是非短路逻辑运算符（non-short-circuit logical operators）。</p><p>短路逻辑运算符表示当进行逻辑运算时，如果根据前面的条件可以确定整个表达式的值，后面的条件就不会被判断。例如，对于表达式 <code>A &amp;&amp; B</code>，如果 <code>A</code> 的值为 <code>false</code>，则整个表达式的值一定是 <code>false</code>，因此不会再去判断 <code>B</code> 的值。同理，对于表达式 <code>A || B</code>，如果 <code>A</code> 的值为 <code>true</code>，则整个表达式的值一定是 <code>true</code>，因此不会再去判断 <code>B</code> 的值。</p></li><li><p>Java中二维数组既可以表示m行n列的规则数据，也可以表示多行数据，每一行的列数不相同的不规则数组。</p></li><li><p><code>java</code>不定长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) sum / nums.length;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><code>java </code>栈的相关操作</p><ol><li>push(E item)：将元素item压入栈顶。</li><li>pop()：弹出栈顶元素，并返回该元素。</li><li>peek()：返回当前栈顶元素，但不对栈做任何修改。</li><li>empty()：测试栈是否为空，如果为空返回true，否则返回false。</li><li>search(Object o)：查找元素o在栈中的位置，如果存在返回距离栈顶的位置索引，否则返回-1。</li></ol></li><li><p><code>java</code>枚举<code>enum</code></p><p>用于常量的定义</p></li><li><p><code>substring</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">substring(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>左闭右开</p><p>从第三个开始，包含第三个，第四个结束不包含第四个</p></li><li><p><code>StringBuffer</code>不能直接给<code>String</code>赋值，必须使用<code>toString()</code></p></li><li><p>常用的Arrays类静态方法有：</p><ul><li>sort方法：对数组进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>Arrays.sort(nums); <span class="hljs-comment">// 对nums数组进行升序排序</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// [1, 3, 4]</span><br></code></pre></td></tr></table></figure><ul><li>binarySearch方法：在已排序的数组中查找指定元素并返回其下标</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">3</span>); <span class="hljs-comment">// 在nums数组中查找数字3</span><br>System.out.println(index); <span class="hljs-comment">// 2，即数字3在数组中的下标为2</span><br></code></pre></td></tr></table></figure><ul><li>equals方法：比较两个数组是否相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] b = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEqual</span> <span class="hljs-operator">=</span> Arrays.equals(a, b); <span class="hljs-comment">// 判断a和b数组是否相等</span><br>System.out.println(isEqual); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>fill方法：将数组全部填充为指定值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(nums, <span class="hljs-number">4</span>); <span class="hljs-comment">// 将nums数组全部填充为数字4</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// [4, 4, 4, 4, 4]</span><br></code></pre></td></tr></table></figure><ul><li>copyOf方法：复制一个数组的一部分或全部到一个新数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>[] b = Arrays.copyOf(a, <span class="hljs-number">3</span>); <span class="hljs-comment">// 复制a数组的前3个元素到b数组中</span><br>System.out.println(Arrays.toString(b)); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><ul><li>toString方法：将数组转换为字符串输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p>常用的Character类静态方法有：</p><ul><li>isLetter方法：判断字符是否为字母（大小写均可）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLetter</span> <span class="hljs-operator">=</span> Character.isLetter(c); <span class="hljs-comment">// 判断c是否是字母</span><br>System.out.println(isLetter); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>isDigit方法：判断字符是否为数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;5&#x27;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isDigit</span> <span class="hljs-operator">=</span> Character.isDigit(c); <span class="hljs-comment">// 判断c是否是数字</span><br>System.out.println(isDigit); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>toUpperCase方法：将字符转换为大写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">upperCaseC</span> <span class="hljs-operator">=</span> Character.toUpperCase(c); <span class="hljs-comment">// 将小写字母c转换为大写字母</span><br>System.out.println(upperCaseC); <span class="hljs-comment">// A</span><br></code></pre></td></tr></table></figure><ul><li>toLowerCase方法：将字符转换为小写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">lowerCaseC</span> <span class="hljs-operator">=</span> Character.toLowerCase(c); <span class="hljs-comment">// 将大写字母B转换为小写字母</span><br>System.out.println(lowerCaseC); <span class="hljs-comment">// b</span><br></code></pre></td></tr></table></figure><ul><li>isWhitespace方法：判断字符是否为空格字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isWhitespace</span> <span class="hljs-operator">=</span> Character.isWhitespace(c); <span class="hljs-comment">// 判断c是否是空格字符</span><br>System.out.println(isWhitespace); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>isLetterOrDigit方法：判断字符是否为字母或数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLetterOrDigit</span> <span class="hljs-operator">=</span> Character.isLetterOrDigit(c); <span class="hljs-comment">// 判断c是否是字母或数字</span><br>System.out.println(isLetterOrDigit); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>如果父类的函数是<code>private</code>，则不会被覆盖。即使子类重写这个函数，但是调用的时候依然是父类的</p></li><li><p>文件的读写</p><ul><li><p>使用<code>scanner</code>和<code>PrintWrite</code></p><ul><li>在使用<code>scanner</code>时，使用<code>file</code>初始化对象</li></ul></li><li><p>使<code>FileInputStream</code>和<code>FileOutputStream</code></p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AB9[模板]链表</title>
    <link href="/2023/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/AB9-%E6%A8%A1%E6%9D%BF-%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/AB9-%E6%A8%A1%E6%9D%BF-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/97dc1ac2311046618fd19960041e3c6f?tpId=308&tqId=2372688&ru=/exam/company&qru=/ta/algorithm-start/question-ranking&sourceUrl=/exam/company">【模板】链表_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/AB9%5B%E6%A8%A1%E6%9D%BF%5D%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x&#123;<span class="hljs-number">0</span>&#125;,y&#123;<span class="hljs-number">0</span>&#125;,num&#123;<span class="hljs-number">0</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list;<br>    std::string str&#123;&#125;;<br>    std::cin&gt;&gt;num;<br>    <span class="hljs-keyword">auto</span> item=list.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(num--)&#123;<br>        std::cin&gt;&gt;str;<br><br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;insert&quot;</span>)&#123;<br>            std::cin&gt;&gt;x&gt;&gt;y;<br>            <span class="hljs-comment">//下面两行如果不存在将返回最后一个迭代器，也就是实现了如果不存在插入到最后一个</span><br>            <span class="hljs-keyword">auto</span> item1=std::<span class="hljs-built_in">find</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>(),x);<br>            list.<span class="hljs-built_in">insert</span>(item1,y);<br>          <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;delete&quot;</span>)&#123;<br>            std::cin&gt;&gt;y;<br>            <span class="hljs-keyword">auto</span> item1=std::<span class="hljs-built_in">find</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>(),y);<br>            <br>            <span class="hljs-comment">//下面的if-else 实现的是如果有重复的删除一个</span><br>            <span class="hljs-comment">//如果使用remove(value)将会删除所有的与value相同的</span><br>            <span class="hljs-keyword">if</span>(item1!=list.<span class="hljs-built_in">end</span>()) &#123;<br>                <br>                list.<span class="hljs-built_in">erase</span>(item1);<span class="hljs-comment">//参数必须是迭代器</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <br>                list.<span class="hljs-built_in">remove</span>(y);<span class="hljs-comment">//不能是迭代器</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">empty</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item1: list)&#123;<br>            std::cout&lt;&lt;item1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><ul><li><p><code>int x&#123;0&#125;,y&#123;0&#125;,num&#123;0&#125;</code></p><p>这只是一种初始化方式</p></li><li><p><code>list</code>是一个双向的链表</p><ul><li><p><code>insert()</code></p><p>插入元素，有两个参数，有4个重载函数</p><p>但是第一个元素只能是迭代器</p></li><li><p><code>erase()</code></p><p>删除迭代器的元素</p></li><li><p><code>remove(value)</code></p><p>删除所有的与<code>value</code>相等的节点</p></li></ul></li><li><p><code>find()</code></p><p>返回迭代器，如何存在法返回该元素的迭代器，不存在返回最后一个迭代器</p></li></ul></li><li><p>理解</p><p>因为<code>list</code>封装了双向链表，所以直接拿来用</p><p>但是使用<code>find</code>可以查找有没有元素</p></li><li><p>问题</p><ul><li><p>c++封装的链表调用起来会不会时间复杂度很大？</p><blockquote><p>一般情况下，C++ STL 的 <code>list</code> 库的效率要优于手写的链表。这是因为 std::list 不仅实现了常见的操作，例如在任意位置插入&#x2F;删除元素、遍历&#x2F;查找列表、反转&#x2F;排序列表等等，而且还通常采用指针来实现，比手写链表更加高效。</p><p>另外，在 STL 的 list 中，封装程序员带来的好处是程序员不需要设计和编写具体的数据结构，也无需理解底层实现细节。所有 STL 集合类都已经实现了大量的算法和数据结构以及相应的纠错代码，因此能够保证高效、稳定和安全。</p><p>当然，对于一些特殊情况和特定应用场景，手写链表可能会比 C++ STL 的 list 更有效率。但这需要根据具体的实际情况来进行评估和验证。</p><p>总之，在大多数情况下，使用 C++ STL 的 <code>list</code> 库更方便、更高效、更容易维护和调试。</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++随记</title>
    <link href="/2023/04/11/c++/c++%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/11/c++/c++%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="平常笔记"><a href="#平常笔记" class="headerlink" title="平常笔记"></a>平常笔记</h1><ol><li><p>初始化数组需要定义大小才能被<code>cin</code></p></li><li><p><code>cin</code>和<code>scanf</code>一样，都跳过空格</p></li><li><p><code>public</code>和<code>private</code>:用于类的封装</p></li><li><p><code>new </code>和 <code>malloc</code>的主要区别:<code>new</code>调用构造函数，<code>malloc</code>不会</p></li><li><p>int *<code>p1</code> &#x3D; new int[10]，int *<code>p2</code> &#x3D; new int[10]()区别：<code>p1</code>申请的空间里的值是随机值，<code>p2</code>申请的空间里的值已经初始化</p></li><li><p>引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b=a;<br><span class="hljs-type">int</span> c=<span class="hljs-number">20</span>;<br>b=c;<span class="hljs-comment">//这个意思就是说，将c的值赋值给a,因为b是啊的别名</span><br></code></pre></td></tr></table></figure><p>本质为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> b = &amp;a;<span class="hljs-comment">//所以在引用后，不能改变空间</span><br>*b = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<br>*b = c;<br></code></pre></td></tr></table></figure></li><li><p>左值，右值：（但凡能去地址，就是一个左值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x++;<span class="hljs-comment">//把x的值取出来，放进临时变量里面，再让临时变量++，此时x的值是临时变量的是，也就是右值</span><br>++x;<span class="hljs-comment">//自增，然后把自己返回，也就是说是左值</span><br></code></pre></td></tr></table></figure><ul><li><p>左值经过函数返回会变成右值，因为会发生拷贝</p></li><li><p>函数里，定义的参数，是个左值</p></li><li><p>用引用写交换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tem =b;<br>    b=a;<br>    a=tem;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>int &amp;a:左值引用</p></li><li><p>int &amp;&amp;a:右值引用</p></li></ul></li><li><p>对输出小数的控制</p><ul><li>不引入头文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> e=<span class="hljs-number">1</span>;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">4</span>);<br>    cout&lt;&lt;fixed&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    cout&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//将输出4位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>引入头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> e=<span class="hljs-number">1</span>;<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//输出4位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>string.at(n)</code>:用于获取指定字符，n就是获取字符的下标</p></li><li><p>使用new,创建的指针p,用法和数组一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *q=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        p[i]=i;<span class="hljs-comment">//可以相当于创建了一个数组，对于数组的存储可以用arr[i]=int类型</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        q[i]=p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>打印16进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;hex&lt;&lt;<span class="hljs-string">&quot;类容&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//可用于打印地址</span><br></code></pre></td></tr></table></figure></li><li><p><code>public</code>成员最好不要在类中赋值,而是使用成员初始化列表</p></li><li><p>在使用继承释放内存时，注意父类使用虚析构</p></li><li><p>构造函数的技巧：在声明的时候参数缺省</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_class</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">My_class</span>(<span class="hljs-type">double</span> num1=<span class="hljs-number">0.0</span>,<span class="hljs-type">double</span> num2=<span class="hljs-number">0.0</span>);<br>    ~<span class="hljs-built_in">My_class</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> m_num1;<br>    <span class="hljs-type">double</span> m_num2;<br><br>&#125;;<br><br><span class="hljs-comment">//构造</span><br>My_class::<span class="hljs-built_in">My_class</span>(<span class="hljs-type">double</span> num1,<span class="hljs-type">double</span> num2) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;My_class::My_class() &quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在声明的时候对参数缺省，在定义的时候不需要（会报错）</p><p><img src="C:\Users\12414\Desktop\笔记\c++\平常笔记.assets\image-20221210113213961.png" alt="image-20221210113213961"></p></li><li><p>引用做函数返回值</p><ul><li><p>不要将局部变量作为返回值</p></li><li><p>函数的返回值可以作为左值存在</p></li><li><p>如果函数的返回值，是左值必须是引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int a=10;//这么写会报错</span><br>    <span class="hljs-type">static</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>&amp; a = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在c++里面，有时候打印不一定需要，<code>string</code>类,特可以用字符指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_1,<span class="hljs-keyword">typename</span> Type_2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Cout</span><span class="hljs-params">(Type_1 a=<span class="hljs-number">0</span>,Type_2 b=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Cout</span>&lt;<span class="hljs-type">char</span>*,string&gt;(<span class="hljs-string">&quot;char*&quot;</span>,<span class="hljs-string">&quot;string&quot;</span>);<br><span class="hljs-comment">/*    cout&lt;&lt;add&lt;int,int&gt;(a,b)&lt;&lt;endl;</span><br><span class="hljs-comment">    cout&lt;&lt;add&lt;int&gt;(a,b)&lt;&lt;endl;</span><br><span class="hljs-comment">    cout&lt;&lt;add&lt;&gt;(a,b)&lt;&lt;endl;*/</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221211212205234.png" alt="image-20221211212205234"></p></li><li><p>c++中读取字符串的函数</p><ul><li><p><code>getline()</code>     <code>string类</code></p><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\学\笔记\c++\平常笔记.assets\平常笔记.assets\image-20221227225137590.png" alt="image-20221227225137590"></p></li><li><p><code>cin.getline()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">cin</span>.getline(str, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-comment">//cin.getline()里面三个参数，第一个是要储存的字符串数组，第二个是最大长度 + 1，最后一个位置用来存储&#x27;\0&#x27;，也就是说你填20，但是只能存前19个字符，第三个是结束符，可省略，默认是换行符</span><br></code></pre></td></tr></table></figure><p>当第二个参数大于数组本身的长度时，只会读取数组这么长</p></li></ul></li><li><p>使用指针遍历时，不能使用数组名，必须重新创建一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>&#125;,*P=arr;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;arr[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">6</span>;i&gt;<span class="hljs-number">0</span>;--i)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;*P++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字符串的输入</p><ul><li><p>string类</p><p>使用<code>getline(cin,string名称)</code></p></li><li><p>字符数组类</p><p>使用<code>cin.getline(str,sizeof(str))</code>;</p></li></ul></li><li><p>c++的强制类型转换方式</p><p>使用<code>static_cast&lt;强制传换成的类型&gt;(被转变量名)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a =<span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> b=<span class="hljs-number">3</span>;<br>b=<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;a;<br></code></pre></td></tr></table></figure></li><li><p><code>using</code>的三个用处</p><ul><li><p>引入命名空间</p></li><li><p>指定别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ModuleType = ClassOne;<br></code></pre></td></tr></table></figure></li><li><p>在子类中引入基类的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ClassType::ModuleType;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>noexcept</code>关键字的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadEntry</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>default</code>是c++11的标准，它的作用是告诉编译器声明一个无参的默认构造函数</p><ul><li>与手动写的无参构造有什么区别<ul><li>多文件的编程中，使用<code>default</code>声明的不需要再写实现</li><li>代码执行的效率很高</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">test</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-built_in">test</span>(<span class="hljs-type">int</span> a)&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>explict</code>这个关键字的作用是用于修饰只有一个参数的构造函数，并要求为显示的，也就是防止用户做可能会发生隐式转换的事情，会报错</p></li><li><p><code>noexcept</code>这是c++11增加的函数，目的是为了提升函数效率，即告诉编译器这个函数不会产生异常。</p></li><li><p><code>=delete</code>表示不能被调用</p></li><li><p><code>decltype </code></p><p><code>auto</code>根据<code>=</code>右边的初始值 <code>value</code> 推导出变量的类型，而 <code>decltype</code> 根据 <code>exp</code> 表达式推导出变量的类型，跟<code>=</code>右边的 <code>value</code> 没有关系。</p></li><li><p><code>lambda</code>表达式</p><p>[见这个](<a href="https://tsy244.github.io/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/">lambda高级使用 - chg (tsy244.github.io)</a>)</p></li><li><p>c++ 父类构造函数声明<code>vitual</code>的作用</p><p>在C++中，当我们派生一个子类时，子类的构造函数会默认调用父类的构造函数以初始化父类的成员变量。而在某些情况下，我们希望能够在父类的构造函数中调用子类重写的虚函数，此时就需要在父类的构造函数声明为<code>virtual</code>。</p><p>具体来说，当父类的构造函数声明为<code>virtual</code>时，如果我们通过子类的指针或引用调用这个构造函数，那么实际被调用的将是子类的构造函数，而不是父类的构造函数。这样可以保证在父类中调用子类的虚函数时，已经完成了子类对象的初始化，避免出现未定义行为的情况。</p><p>需要注意的是，对于同一对象，构造函数的调用顺序是按照继承层次由上至下的，也就是从基类到派生类。因此，在子类的构造函数中，父类的构造函数已经执行完毕，可以调用虚函数，无需再将父类的构造函数声明为<code>virtual</code>。</p></li><li><p>c++父类里使用<code>vitual</code>的函数子类还会继承嘛？</p><p>在 C++ 中，如果一个父类声明了一个虚函数，那么子类继承这个虚函数并且在子类中可以进行重写（override）。当然，如果子类不想重写这个虚函数，也可以直接继承父类中的实现。</p><p>需要注意的是，在父类的构造函数中调用虚函数时，子类的版本不会被调用。这是因为在子类的构造函数执行之前，父类的构造函数已经执行完毕了，此时子类还没有初始化完成。如果在父类的构造函数中调用子类的函数，就有可能出现未定义行为的情况，因此编译器会强制执行父类版本的虚函数。</p><p>总之，如果一个虚函数在父类中已经声明，子类无论是否重写它，在概念上都是继承了这个虚函数，即子类对象拥有这个虚函数的 vtable（虚函数表） 和 vptr（虚指针），可以通过指针或引用来使用这个虚函数。</p></li><li><p>在使用多态的时候应该将父类的析构函数声明<code>vitrual</code></p></li><li><p>在使用<code>virtual</code>的时候体积的增大，是因为携带了很多信息，如虚函数表，虚指针</p></li><li><p>纯虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">testFunc</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>含有纯虚函数的class不能声明的对象，只能被派生</p></li><li><p>在初始化列表中调用父类的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> fat &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">son</span>();<br><br>    ~<span class="hljs-built_in">son</span>();<br>&#125;;<br><br><span class="hljs-comment">//构造</span><br>son::<span class="hljs-built_in">son</span>(): <span class="hljs-built_in">fat</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son::son()&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>move()</code>的使用</p><p>于在不进行复制或赋值操作的情况下将对象的所有权从一个对象转移到另一个对象。通过使用move，可以避免对资源进行复制和销毁的昂贵开销，从而提高代码效率。</p><p>在构造函数中可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fat::<span class="hljs-built_in">fat</span>(std::string str):<span class="hljs-built_in">str</span>(std::<span class="hljs-built_in">move</span>(str)) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name::name()&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>final</code>关键字的使用</p><ul><li>在类上面的使用</li></ul><p>  类的声明中使用final关键字，可以指示该类不能被继承</p><ul><li><p>在虚函数上面的使用</p><p>在虚函数的声明中使用final关键字，可以阻止子类对该虚函数进行覆盖</p></li></ul><p>需要注意的是，final关键字只能用于类或虚函数的声明中，而不能用于变量、函数或其它类型的声明中。</p></li><li><p><code>const</code>和<code>constexpr</code></p><ul><li><p><code>const</code> 只是将变量标记为“只读”，并非编译期常量，而 <code>constexpr</code> 则需要在编译时求值，生成编译期常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> constInt=<span class="hljs-number">10</span>;<span class="hljs-comment">//只读</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> constNum=<span class="hljs-number">10</span>;<span class="hljs-comment">//编译期常量</span><br></code></pre></td></tr></table></figure></li><li><p>被声明为 <code>constexpr</code> 的变量或函数，必须要满足编译器的常量表达式要求，可以在编译时进行求值。</p></li><li><p><code>constexpr</code> 变量应该使用特定的类型，如整数类型、枚举类型以及一些简单的浮点类型。</p></li><li><p><code>constexpr</code> 函数具有与普通函数类似的语法，但是其参数和返回值类型也必须是可求值的。在调用 <code>constexpr</code> 函数时，所有参数必须是编译期常量。</p></li></ul></li><li><p><code>const</code>修饰函数</p><p>在C++中，<code>const</code> 关键字可以作用于成员函数、非成员函数、指针和引用等对象上。如果将 <code>const</code> 应用于成员函数，则该函数被视为只读函数（read-only function），即在该函数内不能修改成员变量的值，也不能调用非<code> const</code> 成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fat::test</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p><code>constexpr</code>修饰函数</p><ol><li>函数必须是类的一部分；</li><li>函数有返回类型，而且返回类型必须为字面值类型；</li><li>函数体中只能包含诸如 <code>return</code>、<code>static_assert</code> 和 <code>typedef</code> 等语句，不能有分支语句（例如 <code>if</code>、<code>while</code>）和循环语句（例如 <code>for</code>、<code>do-while</code>）；</li><li>函数的参数列表中只能有字面值类型、引用和指针，而且参数都必须是 <code>constexpr</code> 的；</li><li>将函数声明为 <code>constexpr</code> 时，函数体内的所有函数调用都必须是 <code>constexpr</code> 的，这也意味着被调用的函数必须是 <code>constexpr</code> 的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">fat::test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>void(*)(int,int)</code>和<code>void(int,int)</code>区别</p><p>一个是函数指针，一个是函数</p></li><li><p>显示和隐式转换</p><p>隐式转换和显示转换是类型转换中的两种方式，其中隐式转换是指在代码中转换类型时，不需要明确地指定要进行类型转换，而是根据上下文环境自动进行转换。相反地，显示转换则是指需要明确地在代码中使用强制类型转换的语法来将一种类型转换为另一种类型。</p><p>隐式转换通常是由编译器自动完成的，它允许代码更简洁、更易读和更容易维护。例如，当一个整数值被分配给一个接收实数的变量时，编译器会自动将整数隐式转换为实数。</p><p>与此相反，显示转换则需要在代码中使用强制类型转换的语法（例如“（int）x”）来明确告诉编译器我们要将某个值转换为另一种类型。在有些情况下，显示转换是非常必要的，例如当我们需要将浮点数转换为整数时，需要使用显示转换来避免数据精度丢失。</p></li><li><p>将c++的string转变为c的string</p><p>使用string的<code>c_str()</code>函数</p></li><li><p>在C++中，可以使用std::reverse()函数来翻转一个序列中的元素。该函数定义在<algorithm>头文件中，其语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BidirectionalIterator</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span> <span class="hljs-params">(BidirectionalIterator first, BidirectionalIterator last)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>find()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), value);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2023/04/11/c++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/04/11/c++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230315194353315.png" alt="image-20230315194353315"></p><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> tem;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myClass</span>()&#123;<br>        tem=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">myClass</span>(<span class="hljs-type">int</span> a):<span class="hljs-built_in">tem</span>(a)&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::shared_ptr的初始化</span><br>    <span class="hljs-comment">//第一种使用以下方法</span><br>    <span class="hljs-type">int</span> *pInt=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(pInt,[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;delete[] pInt1&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.1</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">sharedPtr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>)</span></span>;<br>    *sharedPtr1=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;*sharedPtr1= &quot;</span>&lt;&lt;*sharedPtr1&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr1.use_count():&quot;</span>&lt;&lt;sharedPtr1.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.2</span><br>    <span class="hljs-type">int</span> intSize=<span class="hljs-number">0</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;intSize:&quot;</span>;<br>    std::cin&gt;&gt;intSize;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[intSize],[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;this lambda&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2.use_count():&quot;</span>&lt;&lt;sharedPtr2.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<span class="hljs-comment">//输出1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intSize; ++i) &#123;<br>        sharedPtr2[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intSize; ++i) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2:&quot;</span>&lt;&lt;sharedPtr2[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.3  //无参构造</span><br>    std::shared_ptr&lt;<span class="hljs-type">char</span>&gt; sharedPtr3;<span class="hljs-comment">//无参构造1</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr3.use_count():&quot;</span>&lt;&lt;sharedPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.4 //直接负值</span><br>    sharedPtr3=sharedPtr1;<br><br>    <span class="hljs-comment">//第二种通过拷贝构造和移动构造</span><br>    <span class="hljs-comment">//2.1 //通过move</span><br>    sharedPtr3= std::<span class="hljs-built_in">move</span>(sharedPtr1);<span class="hljs-comment">//通过move实现资源的转移</span><br><br>    <span class="hljs-comment">//第三种 通过make_shared</span><br>    <span class="hljs-comment">//3.1</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * explain: use a fundamental type</span><br><span class="hljs-comment">     */</span><br>    std::shared_ptr&lt;<span class="hljs-type">int</span> &gt; sharedPtr4=std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);<span class="hljs-comment">//520是对该堆内存的初始化</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr4:&quot;</span>&lt;&lt;*sharedPtr4&lt;&lt;std::endl;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * explain: use a class</span><br><span class="hljs-comment">     */</span><br><br>    std::shared_ptr&lt;myClass&gt; sharedPtr5= std::<span class="hljs-built_in">make_shared</span>&lt;myClass&gt;(<span class="hljs-number">1314</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    sharedPtr5= std::<span class="hljs-built_in">make_shared</span>&lt;myClass&gt;(<span class="hljs-number">244</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5.use_count():&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//第四种 //reseet()</span><br>    <span class="hljs-comment">//reset的两个功能：1.接触该内存的控制  2.接触该内存的控制，并控制其他的内存</span><br>    <span class="hljs-comment">//4.1 接触控制</span><br>    sharedPtr5.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    sharedPtr2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//注意此处，reset的地址应该和原来管理的一样</span><br>    sharedPtr5.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> myClass&#123;<span class="hljs-number">8989</span>&#125;);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5.use_count():&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    <span class="hljs-comment">//操作智能指针</span><br>    <span class="hljs-comment">//删除器函数</span><br>    <span class="hljs-comment">//lambda</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;this is deleting sharedPtr6&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr6:&quot;</span>&lt;&lt;*sharedPtr6.<span class="hljs-built_in">get</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*(sharedPtr6.<span class="hljs-built_in">get</span>()+<span class="hljs-number">1</span>)&lt;&lt;std::endl;<br>    <span class="hljs-comment">//c++自带的</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125;,std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        std::cout&lt;&lt;*(sharedPtr7.<span class="hljs-built_in">get</span>()+i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="unique-ptrc"><a href="#unique-ptrc" class="headerlink" title="unique_ptrc"></a>unique_ptrc</h2><h3 id="操作实例-1"><a href="#操作实例-1" class="headerlink" title="操作实例"></a>操作实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//一，初始化</span><br>    <span class="hljs-comment">//1.1 使用构造函数</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">uniquePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">25</span>&#125;)</span></span>;<br>    std::cout&lt;&lt;*uniquePtr&lt;&lt;std::endl;<br>    *uniquePtr.<span class="hljs-built_in">get</span>()=<span class="hljs-number">100</span>;<br>    std::cout&lt;&lt;*uniquePtr&lt;&lt;std::endl;<br>    std::cout&lt;&lt;uniquePtr.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    <span class="hljs-comment">//1.2 使用移动构造</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uniquePtr1= std::<span class="hljs-built_in">move</span>(uniquePtr);<br>    std::cout&lt;&lt;*uniquePtr1&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//1.3 使用reset</span><br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr1.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> &#123;<span class="hljs-number">959</span>&#125;);<br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>&#125;);<br>    std::cout&lt;&lt;uniquePtr.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//unique_ptr 删除器</span><br>    <span class="hljs-comment">//函数指针实例  lambda在没有捕获的时候，可以看成函数指针</span><br>    <span class="hljs-comment">/*using funcPtr=void(*)(int*);*/</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[],<span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>&gt; <span class="hljs-title">uniquePtr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,[](<span class="hljs-type">int</span> * pInt)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;delete uniquePtr2&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    uniquePtr2[<span class="hljs-number">0</span>]=<span class="hljs-number">244</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[0]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">0</span>]&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[1]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//仿函数实例 lambda在有捕获的时候，只能看成函数仿函数</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>,std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt; <span class="hljs-built_in">uniquePtr3</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">244</span>&#125;,[&amp;uniquePtr2](<span class="hljs-type">int</span>* pInt)&#123;<br>        uniquePtr2[<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;delete uniquePtr3&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">delete</span> pInt;<br>    &#125;);<br>    uniquePtr3.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[1]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br><br><br>    <span class="hljs-comment">//std::unique_ptr 类型可以对数组指针自动管理 不需要想shared的那样的指定删除器函数</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ol><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//weak_ptr的初始化</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">233</span>&#125;)</span></span>;<br>    <span class="hljs-comment">//无参构造</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr;<br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weakPtr1</span><span class="hljs-params">(weakPtr)</span></span>;<br>    <span class="hljs-comment">//通过shared_ptr</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weakPtr2</span><span class="hljs-params">(sharedPtr)</span></span>;<br>    <span class="hljs-comment">//使用=</span><br>     std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr3;<br>     weakPtr3=weakPtr2;<br>     std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr3.use_count:&quot;</span>&lt;&lt;weakPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>     <br>     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>expired</code> 判断所指的对象是否析构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">244</span>&#125;)</span></span>;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">weakPtr</span>(sharedPtr);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.use_count():&quot;</span>&lt;&lt;weakPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.expired():&quot;</span>&lt;&lt;(weakPtr.<span class="hljs-built_in">expired</span>()?<span class="hljs-string">&quot;is&quot;</span>:<span class="hljs-string">&quot;not&quot;</span>)&lt;&lt; std::endl;<br><br>    sharedPtr.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.use_count():&quot;</span>&lt;&lt;weakPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.expired():&quot;</span>&lt;&lt;(weakPtr.<span class="hljs-built_in">expired</span>()?<span class="hljs-string">&quot;is&quot;</span>:<span class="hljs-string">&quot;not&quot;</span>)&lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>不能使用同一个堆内存初始化智能指针</p><p>![image-20230319185006853](C:\Users\12414\OneDrive - cuit.edu.cn\桌面\智能指针.assets\image-20230319185006853.png)</p><p>但是可以使用”&#x3D;” 进行赋值操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test* test=<span class="hljs-keyword">new</span> Test;<br>std::shared_ptr&lt;Test&gt;<span class="hljs-built_in">sharedPtr</span>(test);<br>std::shared_ptr sharedPtr1=sharedPtr;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>std::shared_ptr&lt;Test&gt; sharedPtr2= std::<span class="hljs-built_in">move</span>(sharedPtr);<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2.use_count():&quot;</span>&lt;&lt;sharedPtr2.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>std::shared_ptr&lt;Test&gt; sharedPtr3=sharedPtr;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr3.use_count():&quot;</span>&lt;&lt;sharedPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><span class="hljs-comment">//此时sharedPtr已经move,所以结果为0</span><br></code></pre></td></tr></table></figure></li><li><p>对智能指针使用’.’操作的智能指针的api,如果使用’-&gt;’操作的是，对应的类的成员方法</p></li><li><p>正确的返回<code>this</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span>:<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test&gt;&#123;<br>    <span class="hljs-built_in">Test</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Test()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;~Test()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    std::shared_ptr&lt;Test&gt; sharedPtr1=sharedPtr-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr1.use_count():&quot;</span>&lt;&lt;sharedPtr1.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>共享智能指针不能循环引用</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改程序和设计程序的55个具体做法</title>
    <link href="/2023/04/11/effective/Effective/"/>
    <url>/2023/04/11/effective/Effective/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="改程序和设计程序的55个具体做法"><a href="#改程序和设计程序的55个具体做法" class="headerlink" title="改程序和设计程序的55个具体做法"></a>改程序和设计程序的55个具体做法</h1><h3 id="条款-04"><a href="#条款-04" class="headerlink" title="条款 04"></a>条款 04</h3><p><strong>确保对象在使用中之前被初始化</strong></p><ol><li>使用初始化列表<ul><li>最好初始化列表与变量声明一一对应，也就是说与变量的声明顺序一致</li></ul></li></ol><h2 id="构造-x2F-析构-x2F-赋值"><a href="#构造-x2F-析构-x2F-赋值" class="headerlink" title="构造&#x2F;析构&#x2F;赋值"></a>构造&#x2F;析构&#x2F;赋值</h2><h3 id="条款-05"><a href="#条款-05" class="headerlink" title="条款  05"></a>条款  05</h3><p><strong>了解c++默默写了哪些函数</strong></p><ol><li>构造函数，拷贝构造函数，析构函数</li></ol><h3 id="条款-06"><a href="#条款-06" class="headerlink" title="条款  06"></a>条款  06</h3><p><strong>若不想使用编译器自动生成的函数，就该明确拒绝</strong></p><ol><li>为驳回编译器自动提供的机能，可以将相对应的函数声明为<code>private</code>并且不实现</li></ol><h3 id="条款-07"><a href="#条款-07" class="headerlink" title="条款  07"></a>条款  07</h3><p><strong>为多态基类声明<code>virtual</code>析构函数</strong></p><ol><li><code>vitrual</code>的基类一定要有一个虚析构函数</li><li>普通的类不应该使用<code>vitrual</code>（不当作base class或者不使用多态）</li></ol><h3 id="条款-08"><a href="#条款-08" class="headerlink" title="条款 08"></a>条款 08</h3><ol><li><p>不建议在析构函数里面使用捕获异常的代码</p><p><code>try</code> <code>catch</code></p></li><li><p>最好不要让析构函数吐出异常，如果吐出异常应该吞下（不提供处理）</p></li><li><p>如果需要处理此问题，应该提供一个普通函数，处理异常</p></li></ol><h3 id="条款-09"><a href="#条款-09" class="headerlink" title="条款 09"></a>条款 09</h3><p><strong>绝不在构造和析构函数里调用<code>virtual</code></strong></p><ol><li>因为父类的构造函数会比基类的更早运行，如果在构造函数里面调用，调用的是父类的函数</li><li>使用静态函数得到信息返回给父类的构造函数</li></ol><h3 id="条款-10"><a href="#条款-10" class="headerlink" title="条款 10"></a>条款 10</h3><p><strong>operator&#x3D;返回自身引用</strong></p><ol><li>令赋值操作返回的是引用的<code>* this</code></li></ol><h3 id="条款-11"><a href="#条款-11" class="headerlink" title="条款 11"></a>条款 11</h3><p><strong>operator&#x3D; 返回自身</strong></p><p><img src="https://effective-1317182407.cos.ap-nanjing.myqcloud.com/%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%3D.png?q-sign-algorithm=sha1&q-ak=AKID-PeNlHif0nJ_wEg1BUP9j18Q2muRHA-9XnXXi4WLDqcb3LNivTXqBS9oxdh9wcvR&q-sign-time=1681975771;1681979371&q-key-time=1681975771;1681979371&q-header-list=host&q-url-param-list=&q-signature=1d45e441df698b4111a5f9e3cb05771adc62066d&x-cos-security-token=exjIlrnN5LZXIw2T1Hf3mFeft1nV1RQa18fb9ebae4e1eebf72bece2ba52d694avVpAWkDRSq9op61Vz0dBiJ8jUfvLzNKV3i0j6w605w46bZGDrlMOpOayWo2cZS0WzslpQmC_U_6Le7WBb-drutWIY5I76ngUXLd7cfnA0M500OBF9bOx2tnjwSmHCG6TTfim2DOR_A74zl6Xx8Dh2--a8x6cilYGRVtSbBZSMzv7rRxT3SaDoWfY90mLBCU1"></p><ol><li><p>解决对于自己赋值自己的情况</p><p>在经行操作的时候判断，是否是自己，如果是的话就直接返回</p></li><li><p>如果不考虑自己赋值自己的情况</p><p>应该使用临时变量保存原来的地址，如果<code>new</code>失败了，指向的地址也不会出错</p></li></ol><h3 id="条款-12"><a href="#条款-12" class="headerlink" title="条款 12"></a>条款 12</h3><p><strong>operator&#x3D; 赋值对象时勿忘每一个成分</strong></p><ol><li>在使用复制构造函数或者移动构造函数时，我们需要调用父类的构造函数</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款-13"><a href="#条款-13" class="headerlink" title="条款 13"></a>条款 13</h3><ol><li><code>auto_ptr</code>使用有bg,所以选择c++11的智能指针</li></ol><h3 id="条款-14"><a href="#条款-14" class="headerlink" title="条款 14"></a>条款 14</h3><p><strong>在资源管理中心小心<code>coping</code>行为</strong></p><h3 id="条款-15"><a href="#条款-15" class="headerlink" title="条款 15"></a>条款 15</h3><p><strong>在资源管理类中提供原始的资源的访问</strong></p><ol><li>使用智能指针操作原始资源（和普通指针一模一样）</li><li>使用智能指针的<code>get</code></li><li>每一个资源管理类都应该提供一个取得所管理之资源的能力（智能指针是资源管理类的一种）</li><li>显示转换比较方便，但是隐式转换对客户比较方便</li></ol><h3 id="条款-16"><a href="#条款-16" class="headerlink" title="条款 16"></a>条款 16</h3><p><strong>成对的使用<code>new</code>和<code>delete</code>时要采取相同的形式</strong></p><ol><li>不要用<code>typedef</code>和<code>using</code>对数组的对象取别名，因为数组释放需要<code>delete[]</code>容易忘记</li></ol><h3 id="条款-17"><a href="#条款-17" class="headerlink" title="条款 17"></a>条款 17</h3><p><strong>用独立的语句将newed的成员放入智能指针</strong></p><h2 id="设计和声明"><a href="#设计和声明" class="headerlink" title="设计和声明"></a>设计和声明</h2><h3 id="条款-18"><a href="#条款-18" class="headerlink" title="条款 18"></a>条款 18</h3><p><strong>让接口正确使用</strong></p><ol><li><p><code>explicit</code> 禁止隐性转化</p><p>可以当成某些时候不能直接赋值</p></li><li><p>促进正确使用的方法</p><p>保证接口的一致性，以及与内置类型的行为的兼容，也就是把参数名字写好</p></li><li><p>阻止误用</p><p>静止隐式转换，防止产生新的类型</p></li><li><p>使用智能指针，产生定制的删除器</p></li></ol><h3 id="条款-19"><a href="#条款-19" class="headerlink" title="条款 19"></a>条款 19</h3><p><strong>设计一个<code>class</code>就是设计一个<code>type</code></strong></p><ol><li>新的<code>type</code>的对象应该如何被创建和释放</li><li>对象的初始化和赋值应该是不一样的</li></ol><p>。。。。</p><h3 id="条款-20"><a href="#条款-20" class="headerlink" title="条款 20"></a>条款 20</h3><p><strong>建议引用传递</strong></p><ol><li>更加的高效</li><li>以上的规则不适用于内置类型以及迭代器</li></ol><h3 id="条款-21"><a href="#条款-21" class="headerlink" title="条款 21"></a>条款 21</h3><p><strong>在返回对象的时候，别妄想返回其引用</strong></p><ol><li>有些情况应该直接返回对象，而不是他的引用（计算器）</li></ol><h3 id="条款-22"><a href="#条款-22" class="headerlink" title="条款 22"></a>条款 22</h3><p><strong>将成员变量声明为<code>private</code></strong></p><ol><li>使用<code>getter</code>和<code>setter</code></li></ol><h3 id="条款-23"><a href="#条款-23" class="headerlink" title="条款 23"></a>条款 23</h3><p><strong>可以使用非友元或则非成员函数</strong></p><ol><li>面向对象的思想是，将成员变量进行封装</li><li>因为友元和成员函数，对成员变量的操作性是一致，所以也不介意用友元函数</li></ol><h3 id="条款-24"><a href="#条款-24" class="headerlink" title="条款 24"></a>条款 24</h3><p><strong>若所有的参数都需要类型转换，请为此采用非成员函数</strong></p><h3 id="条款-25"><a href="#条款-25" class="headerlink" title="条款 25"></a>条款 25</h3><p>提供一个不会报错的<code>swap</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转整个链表</title>
    <link href="/2023/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="!%5Bimage-20230410224210507%5D(C:%5CUsers%5C12414%5CDesktop%5Chexo%5Csource_posts%5C%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8.assets%5Cimage-20230410224210507.png)">题</a></p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">ReverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* pHead )</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>pHead;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">temp</span>=</span>cur-&gt;next;<br>        cur-&gt;next=pre;<br>        pre=cur;<br>        cur=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>理解</p><ul><li>让<code>temp</code>保存<code>cur-&gt;next</code>的地址</li><li><code>pre</code>第一次要为NULL</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表内指定区域反转</title>
    <link href="/2023/04/10/newcoder/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F%E5%8F%8D%E8%BD%AC/"/>
    <url>/2023/04/10/newcoder/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295">链表内指定区间反转_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param head ListNode类</span><br><span class="hljs-comment">     * @param m int整型</span><br><span class="hljs-comment">     * @param n int整型</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>         ListNode* temHead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//c++的创建方法，0是data域</span><br>        <span class="hljs-comment">//创建虚拟头节点</span><br>        <span class="hljs-comment">//操作头节点方便，比如如果反转第一个元素</span><br>         temHead-&gt;next=head;<br>        <br>        <br>         ListNode* pre=temHead;<br>         ListNode* cur=head;<br>        <span class="hljs-comment">//两个指针用于操作来链表</span><br>        <br>         ListNode* tem=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//用于存放cur-&gt;next</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            pre=pre-&gt;next;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//使节点移动</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n-m;++i) &#123;<br>            tem=cur-&gt;next;<br>            cur-&gt;next=tem-&gt;next;<br>            <span class="hljs-comment">//始终让cur-&gt;next指向的使next-&gt;xext;</span><br>            <br>            <br>            tem-&gt;next=pre-&gt;next;<br>            <span class="hljs-comment">//让反转的指针，指向pre-&gt;next实现反转</span><br>            <br>            pre-&gt;next=tem;<br>            <span class="hljs-comment">//再让pre指向tem保持连接</span><br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> temHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8%E6%8F%90%E7%A4%BA.gif"></p></li><li><p>理解</p><ul><li>先遍历到反转区域</li><li>使用虚拟头节点</li></ul></li><li><p>问题</p><ul><li><p>为什么不用判断<code>cur-&gt;next-&gt;next</code>是不是越界？</p><blockquote><p>因为不会越界</p><p>如果使用的区域刚好是整个链表</p><p>那么当要反转最后一个节点的时候，也就是最后一次</p><p>cur-&gt;next-&gt;next&#x3D;<code>nullptr</code></p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的基本"><a href="#树的基本" class="headerlink" title="树的基本"></a>树的基本</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p><ol><li><p>一个根和若干的子树</p></li><li><p>基本术语</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png"></p></li><li><p>树的类别</p><ul><li><p>有序树</p><p>子树有位置要求</p></li><li><p>无序树</p><p>子树无要求</p><p>意思是：1，2，3，这三颗子树，无论如何排列都是一个树</p></li></ul></li><li><p>森林</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97.png"></p></li><li><p>树和线性结构的比较</p><ul><li>树是一对多</li><li>线性结构是一对一</li></ul></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li><p>每个节点最多有两个度</p></li><li><p>二叉树是个有序树（但是不是树的特殊情况）</p></li><li><p>二叉树可以是一 个空集 </p></li><li><p>二叉树必须要分左子树还是右子树，即使只有一颗子树也要分（但是树可以不分，所以这就是二叉树不是树的原因）</p></li><li><p>二叉树的基本形态</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.png"></p></li><li><p>二叉树的抽象类型定义</p></li><li><p>二叉树的性质</p><ul><li><p>在二叉树的第<code>i</code>层最多有2^i-1^ 个节点，最少有一个</p></li><li><p>深度为<code>k</code>的二叉树最多有2^k^ -1个节点</p></li><li><p>对任何一颗二叉树T如果叶子树为n<del>0</del>&#x3D;n<del>2</del>+1</p></li></ul><p>  <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A83.png"></p><ul><li><p>B&#x3D;n-1</p><p>从下网上看，因为除了根节点每个节点都会产生一条边，所以<code>n-1</code>（除了根节点）个节点会产生<code>n-1</code>个边</p></li><li><p>n<del>2</del> *2 +n<del>1</del>*1</p><p>从上往下看，因为，每一个度为2的节点都会产生两条边，每一度为1的节点会产生一个边</p></li><li><p>满二叉树</p><ul><li>每一层都达到最大的节点数</li><li>叶子节点出现在最后一层</li></ul></li><li><p>完成二叉树</p><ul><li><p>二叉树中有编号的与满二叉树的标号对应</p></li><li><p>在满二叉树中去除立连续的节点，剩下的也是完全二叉树</p></li><li><p>满二叉树一定是完全二叉树</p></li><li><p>完全二叉树的性质</p><p>性质三</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png"></p><p>性质四</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png"></p></li></ul></li></ul></li><li><p>二叉树的存储结构  </p><ul><li>顺序结构</li><li>链式结构<ul><li>二叉链表</li><li>三叉链表</li></ul></li></ul></li><li><p>二叉树的链式存储的储存结构</p><p>二叉链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rChild</span>;</span><br>&#125;BiNode,*BiTree;<br></code></pre></td></tr></table></figure><p>三叉链表(多了一个指向双亲的指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">parent</span>,*<span class="hljs-title">rChild</span>;</span><br>&#125;BiNode,*BiTree;<br><br></code></pre></td></tr></table></figure><ul><li>在<code>n</code>个节点的二叉链表中，必有<code>2n</code>个链域，除了根节点没有双亲，所以一定会有<code>n-1</code>个节点的链域存放指针，指向非空的子女节点。</li></ul><p>  所以一共有<code>n+1</code>个空指针域</p></li><li><p>二叉树的遍历</p></li></ol><ul><li><p>先序遍历</p><p>先访问根节点，再访问左子树，再访问右子树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        visit(T);<br>        PreOrderTraverse(T-&gt;lChild);<br>        PreOrderTraverse(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>中序遍历</p><p>先访问左子树，再访问根节点，再访问右子树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PreOrderTraverse(T-&gt;lChild);<br>        visit(T);<br>        PreOrderTraverse(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>后续遍历</p><p>先访问左子树，在访问右子树，最后访问根节点   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PreOrderTraverse(T-&gt;lChild);<br>        PreOrderTraverse(T-&gt;rChild);<br>        visit(T);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>例题：</p><p>使用二叉树表达算术表达式</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%8D%EF%BC%8C%E4%B8%AD%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.png"></p></li><li><p>递归遍历的算法分析</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.png" alt="img"></p><p>从虚线出发到每一个终点路径每个节点经历3次</p></li><li><p>非递归遍历</p><p>中序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stack&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TElemType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    std::stack&lt;BiTree&gt; stack;<span class="hljs-comment">//申请一个栈</span><br>    BiTree moveNode=T;<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()||moveNode!= <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(moveNode!= <span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(moveNode);<br>            moveNode=moveNode-&gt;lChild;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">auto</span> p=stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//得到栈首的元素</span><br>            std::cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            stack.<span class="hljs-built_in">pop</span>();<br>            moveNode=p-&gt;rChild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">status <span class="hljs-title">LeveIOrder</span><span class="hljs-params">(BiTree&amp; biTree)</span></span>&#123;<br>    std::queue&lt;BiTree&gt; queue;<br>    BiNode* pMove=biTree;<br>    queue.<span class="hljs-built_in">push</span>(biTree);<br>    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(queue.<span class="hljs-built_in">front</span>()-&gt;lChild!= <span class="hljs-literal">nullptr</span>)&#123;<br>            queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;lChild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(queue.<span class="hljs-built_in">front</span>()-&gt;rChild!= <span class="hljs-literal">nullptr</span>)&#123;<br>            queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;rChild);<br>        &#125;<br>        std::cout&lt;&lt;queue.<span class="hljs-built_in">front</span>()-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="11"><li><p>二叉树的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">CreatBitree</span><span class="hljs-params">(BiTree* biTree)</span>&#123;<br>    TElemType ch;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        (*biTree)=(BiNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiNode));<br>        (*biTree)-&gt;lChild=<span class="hljs-literal">NULL</span>;<br>        (*biTree)-&gt;rChild=<span class="hljs-literal">NULL</span>;<br>        (*biTree)-&gt;data=ch;<br>        CreatBitree(&amp;(*biTree)-&gt;lChild);<br>        CreatBitree(&amp;(*biTree)-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>定义：</p><p>‘#’代表没有节点</p></li></ul><p>所以上面代码的实现是，根据符号来确定是否要创建一个二叉树</p></li><li><p>二叉树的复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">Copy</span><span class="hljs-params">(BiTree T, BiTree *newBitree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;<br>        *newBitree = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiNode));<br>        (*newBitree)-&gt;lChild=<span class="hljs-literal">NULL</span>;<br>        (*newBitree)-&gt;rChild=<span class="hljs-literal">NULL</span>;<br>        (*newBitree)-&gt;data=T-&gt;data;<br>        Copy(T-&gt;lChild,&amp;(*newBitree)-&gt;lChild);<br>        Copy(T-&gt;rChild,&amp;(*newBitree)-&gt;rChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算二叉树的深度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Depen</span><span class="hljs-params">(BiTree biTree)</span>&#123;<br>    <span class="hljs-keyword">if</span>(biTree==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        m= Depen(biTree-&gt;lChild);<br>        n= Depen(biTree-&gt;rChild);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;m)&#123;<br>        <span class="hljs-keyword">return</span> (n+<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> m+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算二叉树的节点数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span><span class="hljs-params">(BiTree biTree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (biTree != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NodeCount(biTree-&gt;lChild)+ NodeCount(biTree-&gt;rChild)+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算叶子节点的个数（叶子节点是左右孩子都为<code>NULL</code>的节点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">DestroyBiTree</span><span class="hljs-params">(BiTree *biTree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (*biTree == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*biTree)-&gt;lChild != <span class="hljs-literal">NULL</span>) &#123;<br>        DestroyBiTree(&amp;(*biTree)-&gt;lChild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*biTree)-&gt;rChild != <span class="hljs-literal">NULL</span>) &#123;<br>        DestroyBiTree(&amp;(*biTree)-&gt;rChild);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  %c&quot;</span>, (*biTree)-&gt;data);<br>    <span class="hljs-built_in">free</span>((*biTree));<br>    (*biTree)==<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线索二叉树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png"></p><p> <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%A7%84%E5%88%99.png"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%A4%B4%E7%BB%93%E7%82%B9.png"></p></li></ol><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97.png"></p><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><p>其中A是虚拟的头节点</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    PTNode nodes[BUFSIZ];<br>    <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//存放根节点和节点个数</span><br>&#125;PTree;<br></code></pre></td></tr></table></figure><h4 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png"></p><h4 id="带双亲的孩子链表"><a href="#带双亲的孩子链表" class="headerlink" title="带双亲的孩子链表"></a>带双亲的孩子链表</h4><p>只是在孩子链表的基础上多加了双亲的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png"></p><h4 id="孩子兄弟表示法（二叉树表示法，二叉链表表示法）"><a href="#孩子兄弟表示法（二叉树表示法，二叉链表表示法）" class="headerlink" title="孩子兄弟表示法（二叉树表示法，二叉链表表示法）"></a>孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E6%93%8D.png"></p><ul><li><p>将树转换为二叉树</p><p>兄弟相连留长子</p><p>意思是：将兄弟的连起来，只保留双亲与长子的连线</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B0%86%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%84%E5%BC%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%84%E5%BC%9F%E5%AD%98%E5%82%A8%E6%B3%95%EF%BC%89.png"></p></li><li><p>将兄弟二叉树，转变为普通的树</p><p>左孩子右右连双亲，去掉原来的右孩子线</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E6%A0%91.png"></p></li></ul><h3 id="森林和二叉树的转化"><a href="#森林和二叉树的转化" class="headerlink" title="森林和二叉树的转化"></a>森林和二叉树的转化</h3><ol><li><p>树变二叉树根相连</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E5%8F%98%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p></li><li><p>二叉树变森林</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E6%A3%AE%E6%9E%97.png"></p></li></ol><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ol><li><p>先根</p><p>如树不为空，那么先遍历根然后在遍历各个子树</p></li><li><p>后根</p><p>若树不为空，后根遍历各课子树，然后访问根节点</p></li></ol><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png"></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>和二叉树的遍历方式一致</p><ol><li><p>先序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png"></p></li><li><p>中序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p></li></ol><h2 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h2><h3 id="判断树"><a href="#判断树" class="headerlink" title="判断树"></a>判断树</h3><p>左边是改进的选择判断语句</p><p>右边是普通的选择判断语句</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%88%A4%E6%96%AD%E6%A0%91.png"></p><ol><li><p>基本概念</p><ul><li><p>路径</p><p>从一个结点到另一个结点的分支构成了结点间的路径</p></li><li><p>结点的路径长度</p><p>两结点间的路径上的分支数</p><p>A-&gt;D 的路径长度是  2</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A62.png"></p></li><li><p>树的路径长度</p><p>从根结点到每个结点的路径长度之和</p></li><li><p>权</p><p>将树中的结点赋一个有某种含义的数值，称为<strong>结点的权</strong></p></li><li><p>结点的带权路径长度</p><p>从根到该节点之间的路径长度×该节点权的结果</p></li><li><p>树的带权路径长度</p><p>树中所有的叶子结点的带权路径长度之和</p></li></ul></li></ol><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>最优树，也就是带权路径长度最短的树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png"></p><ol><li>满二叉树不一定是最优二叉树</li></ol><p><strong>哈夫曼树的特点</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9.png"></p><ul><li>只有度（子树个数 ）0为0或2的结点</li><li>一共有<code>2n-1</code>个结点，且新构成的结点都是度为二的结点，原来的结点都是度为一的结点</li><li>一共有n个叶子结点（原来的结点，也就是度为0的结点）</li></ul><h4 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h4><ol><li>权值越大的先构造（贪心算法）</li></ol><p>   步骤</p><ul><li>构造森林全是根</li><li>选用两小造新树</li><li>删除两小添新人</li><li>重复2，3剩单根</li></ul><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0.png"></p><p>   删除两小的意思是：删除原来队列里面的两个小的</p><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B.png"></p><p>   直到剩下一棵树，就是哈夫曼树</p><p>   下面是一个例题</p><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E4%BE%8B%E9%A2%98.png"></p><ol start="2"><li><p>代码实现</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png"></p><p>注意重置min的过程，可以改进算法，但是作者还没有学到遍历，所以并没有采取其他方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HTNode</span> &#123;</span><br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125; HTNode, *HuffmanTree;<br><span class="hljs-comment">//采用双亲表示法，但是会记录左右孩子的位置</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Select</span><span class="hljs-params">(HTNode *htNodes, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *min1, <span class="hljs-type">int</span> *min2)</span> &#123;<br>    <span class="hljs-comment">//以下算法用于去出较次和最次的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((htNodes + i)-&gt;parent == <span class="hljs-number">0</span><br>            &amp;&amp; (htNodes + i)-&gt;weight &lt; (htNodes + *min1)-&gt;weight) &#123;<span class="hljs-comment">//确保每小权的结点已经被选用</span><br><br>            *min2 = *min1;<br>            *min1 = i;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((htNodes + i)-&gt;parent == <span class="hljs-number">0</span><br>                   &amp;&amp; (htNodes + i)-&gt;weight &lt; (htNodes + *min2)-&gt;weight<br>                   &amp;&amp; i != *min1) &#123;<br><br>            *min2 = i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initMin</span><span class="hljs-params">(HTNode* htNodes,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> *min1,<span class="hljs-type">int</span> *min2)</span>&#123;<br>    <span class="hljs-comment">//重置最小值，防止取出来的最小值是已经被选过的</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span>((htNodes+i)-&gt;parent==<span class="hljs-number">0</span>)&#123;<br>            *min1=i++;<span class="hljs-comment">//break使得++i失效</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;i&lt;size;++i)&#123;<br>        <span class="hljs-keyword">if</span>((htNodes+i)-&gt;parent==<span class="hljs-number">0</span>)&#123;<br>            *min2=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">creatNode</span><span class="hljs-params">(HTNode *htNodes, <span class="hljs-type">int</span> *nums, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min1 = <span class="hljs-number">0</span>, min2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> size1;<br>    size1 = size * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">for</span> (; i&lt;size; ++i) &#123;<br>        (htNodes + i)-&gt;weight = *(nums + i);<br>        (htNodes + i)-&gt;lch = <span class="hljs-number">0</span>;<br>        (htNodes + i)-&gt;rch = <span class="hljs-number">0</span>;<br>        (htNodes + i)-&gt;parent = <span class="hljs-number">0</span>;<span class="hljs-comment">//一定要将parent重置为0</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (; i &lt; size1 ; ++i) &#123;<br>        initMin(htNodes,i,&amp;min1,&amp;min2);<br>        Select(htNodes, i, &amp;min1, &amp;min2);<br>        (htNodes + i)-&gt;weight = (htNodes + min1)-&gt;weight + (htNodes + min2)-&gt;weight;<br>        (htNodes + i)-&gt;lch = min1;<br>        (htNodes + i)-&gt;rch = min2;<br>        (htNodes + i)-&gt;parent = <span class="hljs-number">0</span>;<br>        (htNodes + min1)-&gt;parent = i;<br>        (htNodes + min2)-&gt;parent = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> nums[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> tem;<br>    HTNode htNodes[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//注意这里使用变量，不使用指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<span class="hljs-comment">//num最大是5，因为，2n-1留一个0不用</span><br><span class="hljs-comment">/*    if(num&gt;5)&#123;</span><br><span class="hljs-comment">        printf(&quot;num too large&quot;);</span><br><span class="hljs-comment">        exit(-1);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tem);<br>        nums[i] = tem;<br>    &#125;<br>    creatNode(htNodes, nums, num);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*num<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,htNodes[i].weight);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h4 id="哈曼树的运用"><a href="#哈曼树的运用" class="headerlink" title="哈曼树的运用"></a>哈曼树的运用</h4><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><ol><li><p>设计一种任意的编码都不是另一个编码的前缀</p><p>如A(0)是B(00)的前缀</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"></p></li><li><p>通过哈夫曼编码使得电文最短</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E7%94%B5%E6%96%87%E7%9A%84%E6%9C%80%E7%9F%AD.png"></p><p>将要传输的字符出现的频率当作权值</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E7%94%B5%E6%96%87%E7%9A%84%E6%9C%80%E7%9F%AD.png"></p></li><li><p>问题</p><ul><li><p>为什么哈夫曼编码能确保不是前缀编码？</p><blockquote><p>因为每一个字符都是叶子结点，也就是说，没有哪个叶子是另个一个叶子的前缀，也就是没有相同的路径</p></blockquote></li><li><p>为什么哈夫曼树能确保字符编码总长最短？</p><blockquote><p>才用权的方式，权重大的离根节点更近，所以形成的编码最短。换句话说哈夫曼树的加权路径最短</p></blockquote></li></ul></li><li><p>性质</p><ul><li>哈夫曼编码是前缀码</li><li>而且是最有前缀码</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表</title>
    <link href="/2023/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2023/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h1><h2 id="串（字符串string）"><a href="#串（字符串string）" class="headerlink" title="串（字符串string）"></a>串（字符串string）</h2><ol><li><p>是一个内容受限的线性表（只能存放字符）</p></li><li><p>子串</p><p>例如<code>abcd</code>的的子串</p><p>“ ”  “a”  “ab”  ……..</p></li><li><p>子串在主串当中的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%AD%90%E4%B8%B2%E5%9C%A8%E4%B8%BB%E4%B8%B2%E7%9A%84%E4%BD%8D%E7%BD%AE.png"></p></li><li><p>所有的空串都是相等的 </p></li><li><p>一般选用顺序的</p></li></ol><h3 id="串的顺序实现"><a href="#串的顺序实现" class="headerlink" title="串的顺序实现"></a>串的顺序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SString</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[MAXSIZE];<br>    <span class="hljs-type">int</span> Length;<br>&#125;SString;<br></code></pre></td></tr></table></figure><h3 id="串的链式实现"><a href="#串的链式实现" class="headerlink" title="串的链式实现"></a>串的链式实现</h3><ol><li><p>优点</p><blockquote><p>操作方便</p></blockquote></li><li><p>缺点</p><blockquote><p>存储密度较低 </p></blockquote><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%B2%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9.png"></p></li><li><p>块链的是实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>* <span class="hljs-title">next</span>;</span><br>&#125;Chunk;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LString</span>&#123;</span><br>    Chunk *head,*tail;<br>    <span class="hljs-type">int</span> curlen;<br>&#125;LString;<br></code></pre></td></tr></table></figure></li></ol><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><ol><li><p>时间复杂度为<code>O(n*m)</code></p></li><li><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SString</span> &#123;</span><br>    <span class="hljs-type">char</span> ch[MAXSIZE];<br>    <span class="hljs-type">int</span> Length;<br>&#125; SString;<br><br>status <span class="hljs-title function_">InitString</span><span class="hljs-params">(SString *<span class="hljs-built_in">string</span>)</span> &#123;<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">string</span>-&gt;ch, <span class="hljs-number">0</span>, MAXSIZE);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-built_in">string</span>-&gt;ch);<br>    <span class="hljs-built_in">string</span>-&gt;Length = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>-&gt;ch);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BFMatchingAlorithm</span><span class="hljs-params">(SString *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">string</span>-&gt;Length;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">string</span>-&gt;Length &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(str)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>-&gt;ch[i] == str[j]) &#123;<br>            ++i;<br>            ++j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i - j + <span class="hljs-number">1</span>;<br>            j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(str)) &#123;<br>        <span class="hljs-keyword">return</span> i - j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">/*    for (int i = 0,j=0; i &lt; len; ++i) &#123;</span><br><span class="hljs-comment">        if(string-&gt;ch[i]==str[j])&#123;</span><br><span class="hljs-comment">            while(j&lt; strlen(str)&amp;&amp;string-&gt;ch[i]!=&#x27;\0&#x27;)&#123;</span><br><span class="hljs-comment">                if(string-&gt;ch[i]!=str[j])&#123;</span><br><span class="hljs-comment">                    i=i-j+1;</span><br><span class="hljs-comment">                    j=0;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                i++;</span><br><span class="hljs-comment">                j++;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            if(j== strlen(str))&#123;</span><br><span class="hljs-comment">                return i-j;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return -1;*/</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    SString <span class="hljs-built_in">string</span>;<br>    <span class="hljs-type">int</span> sub = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">10</span>];<br>    InitString(&amp;<span class="hljs-built_in">string</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    sub = BFMatchingAlorithm(&amp;<span class="hljs-built_in">string</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sub);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>注意回溯的<code>i</code>的计算公式</li></ul></li></ol><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ol><li><p>计算<code>next</code>的值</p><ul><li>第一个元素<code>next</code>为<code>0</code></li><li>第二个元素<code>next</code>比较前面一个元素，就是<code>1</code></li><li>其他元素比较前缀的子串</li></ul><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/KMP%E7%AE%97%E6%B3%95%E7%9A%84next%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97.png"></p></li><li></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>定长的线性表</p></li><li><p>相同的元素</p></li><li></li><li><p>结构是固定</p></li><li><p>三维数组的存储</p><p>例如<code>arr[i][j][k]</code></p><ul><li><p><code>arr[x][y][z]</code></p><p>意思就是说，第<code>z</code>页的第<code>x,y</code>号元素</p><p>内存为<code>arr+z*x*y+x*y+y</code></p></li></ul></li><li><p>稀疏矩阵的存储</p><p>采用三元法(i,j,元素)</p><p>既是只存放有元素的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E5%85%83%E7%BB%84%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p></li><li><p>三角矩阵</p><p>采用的是存一边的方法</p></li><li><p>对称矩阵</p><p>采用三角矩阵的存法</p></li></ol><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p><ol><li><p>每个元素可以不同</p></li><li><p>一般用大写的字母表示广义表，小写的字母表示表的元素</p></li><li><p>递归的广义表</p></li><li><p>广义表的深度</p><p>可以大概理解为，完整括号的个数</p></li><li><p>广义表的性质</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p></li><li><p>广义表的种类</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p></li></ol><h2 id="案例分析与实现"><a href="#案例分析与实现" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h2><ol><li><p>病毒感染检测</p><ul><li><p>将病毒的遗传物质变成复制一份（考虑到病毒的遗传物质是环状的）</p></li><li><p>代码示例（病毒DNA是线状的）</p><p>使用BF</p><p>[代码](<a href="https://github.com/TSY244/cpp_test/commit/82838186490cbdfacb47899ecf70487a44ab4e53">病毒匹配bf · TSY244&#x2F;cpp_test@8283818 (github.com)</a>)</p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2023/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈定义和特点"><a href="#栈定义和特点" class="headerlink" title="栈定义和特点"></a>栈定义和特点</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9.png"></p><ol><li>栈：先进后出</li><li>队列：先进先出（排队的问题）</li></ol><h3 id="顺序栈的表示和操作实现"><a href="#顺序栈的表示和操作实现" class="headerlink" title="顺序栈的表示和操作实现"></a>顺序栈的表示和操作实现</h3><ol><li>约定<code>an</code>端为栈顶，<code>a1</code>端为栈底</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li><p>初始化   制造一个空栈</p><p><code>InitStack(&amp;S)</code></p></li><li><p>销毁栈   </p><p><code>DestroyStack(&amp;S)</code></p></li><li><p>判断是否为空</p><p><code>StackEmpty(S)</code></p></li><li><p>求栈的长度</p><p><code>StackLength(S)</code></p></li><li><p>取栈顶的元素</p><p><code>GetTop(S,&amp;e)</code></p></li><li><p>栈的置空操作</p><p><code>ClearStack(&amp;S)</code></p></li><li><p>入栈操作</p><p><code>Push(&amp;S,e)</code></p></li><li><p>出栈操作</p><p><code>Pop(&amp;S,&amp;e)</code></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png"></p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol><li><p>两个指针，一个<code>top</code>指向的是真正的栈顶的上面一个指针，一个<code>base</code>指向的是栈底的地址</p></li><li><p>空栈的标志</p><p><code>top</code>和<code>base</code>都指向的是<code>0</code> </p></li><li><p>栈满的标志</p><p><code>top</code>-<code>base</code>&#x3D;&#x3D;<code>stacksize</code> </p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA.png"></p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    ElemType* base;<br>    ElemType* top;<br>    <span class="hljs-type">int</span> stackSize;<br>&#125;SqStack;<br><br>status <span class="hljs-title function_">destroyStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(sqStack-&gt;base);<br>    sqStack-&gt;stackSize=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">initStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    sqStack-&gt;base=(ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (ElemType)*MAXSIZE);<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    &#125;<br>    sqStack-&gt;top=sqStack-&gt;base;<br>    sqStack-&gt;stackSize=MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==sqStack.top)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">StackLength</span><span class="hljs-params">(SqStack sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sqStack.top-sqStack.base;<br>&#125;<br><br>status <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack sqStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=*sqStack.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">ClearStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    sqStack-&gt;base=sqStack-&gt;top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* sqStack,ElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>||sqStack-&gt;top-sqStack-&gt;base==sqStack-&gt;stackSize)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *sqStack-&gt;top++=e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* sqStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>|| sqStack-&gt;base==sqStack-&gt;top)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=*--sqStack-&gt;top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">CreatSqStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        Push(sqStack,i+<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">printfStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> tem;<br>    <span class="hljs-keyword">while</span>(StackLength(*sqStack)&gt;<span class="hljs-number">0</span>)&#123;<br>        Pop(sqStack,&amp;tem);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, tem);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    SqStack sqStack;<br>    sqStack.base=<span class="hljs-literal">NULL</span>;<br>    initStack(&amp;sqStack);<br>    CreatSqStack(&amp;sqStack);<br>    printfStack(&amp;sqStack);<br>    destroyStack(&amp;sqStack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="栈链的表示和实现"><a href="#栈链的表示和实现" class="headerlink" title="栈链的表示和实现"></a>栈链的表示和实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>* <span class="hljs-title">next</span>;</span><br>&#125;StackNode,*LinkStack;<br><br><br>status <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-comment">//构造空栈</span><br>    *linkStack=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkStack linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>status <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack* linkStack,ElemType e)</span>&#123;<br>    StackNode* temNode=(StackNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(StackNode));<br>    temNode-&gt;data=e;<br>    <span class="hljs-comment">//如果是第一个元素，下面代码指向的NULL</span><br>    temNode-&gt;next=(*linkStack);<br>    (*linkStack)=temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">Pop</span><span class="hljs-params">(LinkStack* linkStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=(*linkStack)-&gt;data;<br>    (*linkStack)=(*linkStack)-&gt;next;<br><br>&#125;<br>status <span class="hljs-title function_">DestroyStack</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    StackNode* deleteNode=(*linkStack);<br>    <span class="hljs-keyword">while</span>(deleteNode!=<span class="hljs-literal">NULL</span>)&#123;<br>        (*linkStack)=(*linkStack)-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode=<span class="hljs-literal">NULL</span>;<br>        deleteNode=(*linkStack);<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>ElemType <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>((*linkStack)==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (*linkStack)-&gt;data;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    LinkStack linkStack=<span class="hljs-literal">NULL</span>;<br>    InitStack(&amp;linkStack);<br>    <span class="hljs-type">int</span> e1=<span class="hljs-number">244</span>,e2=<span class="hljs-number">0</span>;<br>    Push(&amp;linkStack,e1);<br>    Pop(&amp;linkStack,&amp;e2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,e2);<br>    Push(&amp;linkStack,<span class="hljs-number">24</span>);<br>    e1= GetTop(&amp;linkStack);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,e1);<br>    DestroyStack(&amp;linkStack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><ol><li><p>主调函数和被调函数</p><p>如：<code>main</code>函数就是主调函数，在里面调用的函数被称为被调函数</p></li><li><p>函数的嵌套调用的方式</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86.png"></p></li></ol><h2 id="队列的表示和操作原理"><a href="#队列的表示和操作原理" class="headerlink" title="队列的表示和操作原理"></a>队列的表示和操作原理</h2><ol><li>只能在表尾经行插入操作，在表头进行删除操作的线性表</li><li>先进先出的线性表</li><li>有顺序结构和链式结构（常用的是顺序结构）</li></ol><h3 id="队列的相关操作"><a href="#队列的相关操作" class="headerlink" title="队列的相关操作"></a>队列的相关操作</h3><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.png"></p><h3 id="队列的顺序表示和实现"><a href="#队列的顺序表示和实现" class="headerlink" title="队列的顺序表示和实现"></a>队列的顺序表示和实现</h3><p> <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.png"></p><ol><li><p>对空的表示</p><p><code>front</code>&#x3D;<code>rear</code>&#x3D;<code>0</code></p></li><li><p>队列的特殊情况</p><p><img src="C:\Users\12414\Desktop\hexo\source_posts\栈和队列.assets\image-20230402182219032.png"></p></li><li><p>假溢出和真溢出</p><ul><li><p>假溢出</p><p><code>rear</code>!&#x3D;<code>0</code></p><p><code>rear</code>&#x3D;<code>MAXQSIZE</code> 但是队列中还有空余的存储空间</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%81%87%E6%BA%A2%E5%87%BA.png"></p></li><li><p>真溢出</p><p><code>rear</code>&#x3D;<code>0</code></p><p><code>fear</code>&#x3D;<code>MAXQSIZE</code></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E7%9C%9F%E6%BA%A2%E5%87%BA.png"></p></li></ul></li><li><p>循环队列的处理逻辑</p><ul><li><p>使用<code>%</code>运算，将数组变成循环 </p></li><li><p>但是用循环队列的是时候，我们面对的是对空和对满是一种判断条件，所以我们使用标志经行判断</p><p>一下提出三种解决办法</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.png"></p></li></ul></li><li><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><span class="hljs-keyword">using</span> ElemType=<span class="hljs-type">int</span>;<br><span class="hljs-keyword">using</span> status=<span class="hljs-type">int</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ERROR=<span class="hljs-number">-1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXSIZE=<span class="hljs-number">10</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Que</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br>    ElemType* base;<br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">//地址更小的指针</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">//地址更大的指针</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Que</span>();<br>    ~<span class="hljs-built_in">Que</span>();<br>    <span class="hljs-function">status <span class="hljs-title">ClearQueue</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(ElemType&amp; e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(ElemType e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(ElemType &amp;e)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>类的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>Que::<span class="hljs-built_in">Que</span>() &#123;<br>    base= <span class="hljs-literal">nullptr</span>;<br>    base=<span class="hljs-keyword">new</span> ElemType [MAXSIZE];<br>    <span class="hljs-keyword">if</span>(base== <span class="hljs-literal">nullptr</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;base new ERROR&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    front=<span class="hljs-number">0</span>;<br>    rear=<span class="hljs-number">0</span>;<br>&#125;<br><br>Que::~<span class="hljs-built_in">Que</span>() &#123;<br>    <span class="hljs-keyword">delete</span>[] base;<br>    front=<span class="hljs-number">0</span>;<br>    rear=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Que::status Que::ClearQueue() &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    return 0;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">//这个算法需要想清楚</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Que::QueueLength</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (rear-front+MAXSIZE)%MAXSIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::GetHead</span><span class="hljs-params">(ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(rear==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e=*(base+front);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::EnQueue</span><span class="hljs-params">(ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>((rear+<span class="hljs-number">1</span>)%MAXSIZE==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *(base+rear)=e;<br>    rear=(rear+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::DeQueue</span><span class="hljs-params">(ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(rear==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e=*(base+front);<br>    front=(front+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myClass.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatQ</span><span class="hljs-params">(Que &amp;que)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXSIZE; ++i) &#123;<br>        que.<span class="hljs-built_in">EnQueue</span>(i + <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(Que &amp;que)</span> </span>&#123;<br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">GetHead</span>(e)) &#123;<br>        std::cout &lt;&lt;<span class="hljs-string">&quot;Get: &quot;</span>&lt;&lt; e &lt;&lt; std::endl;<br>        que.<span class="hljs-built_in">DeQueue</span>(e);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;delete: &quot;</span>&lt;&lt;e&lt;&lt;std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Que queue;<br>    ElemType elemType = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> e;<br>    queue.<span class="hljs-built_in">EnQueue</span>(<span class="hljs-number">244</span>);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">QueueLength</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">GetHead</span>(e) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; e &lt;&lt; std::endl;<br>    <span class="hljs-built_in">creatQ</span>(queue);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">QueueLength</span>() &lt;&lt; std::endl;<br>    <span class="hljs-built_in">printQueue</span>(queue);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">DeQueue</span>(elemType) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="队列链式实现"><a href="#队列链式实现" class="headerlink" title="队列链式实现"></a>队列链式实现</h3><ol><li><p>节点的实现</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E7%9A%84%E8%8A%82%E7%82%B9.png"></p></li><li><p>基本定义</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p></li><li><p>代码实例（注意win上面竟然过不了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkQueue</span> &#123;</span><br>    QueuePtr rear;<br>    QueuePtr front;<br>&#125; LinkQueue, *LinkQNode;<br><br>status <span class="hljs-title function_">InitNode</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    QueuePtr queuePtr = (QNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    queuePtr-&gt;next = <span class="hljs-literal">NULL</span>;<br>    queuePtr-&gt;data = <span class="hljs-number">0</span>;<br>    (*linkQueue)-&gt;front = queuePtr;<br>    (*linkQueue)-&gt;rear = queuePtr;<br>&#125;<br><br>status <span class="hljs-title function_">DestroyNode</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    <span class="hljs-keyword">if</span> (*linkQueue == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    QNode *deleteNode = (*linkQueue)-&gt;front;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (deleteNode != <span class="hljs-literal">NULL</span>) &#123;<br>        (*linkQueue)-&gt;front = (*linkQueue)-&gt;front-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>        deleteNode = (*linkQueue)-&gt;front;<br>        num++;<br>    &#125;<br>    (*linkQueue)-&gt;rear = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">free</span>(*linkQueue);<br>    (*linkQueue)=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">CreatLinkQueue</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    (*linkQueue) = (LinkQueue *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkQueue));<br>    <span class="hljs-keyword">if</span> ((*linkQueue) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    (*linkQueue)-&gt;front = <span class="hljs-literal">NULL</span>;<br>    (*linkQueue)-&gt;rear = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">GetHead</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType *e)</span> &#123;<br>    *e = (*linkQNode)-&gt;front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType e)</span> &#123;<br>    QNode *qNode = (QNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (qNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    qNode-&gt;data = e;<br>    qNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((*linkQNode)-&gt;front == (*linkQNode)-&gt;rear) &#123;<br>        (*linkQNode)-&gt;front-&gt;next = qNode;<br>    &#125;<br>    (*linkQNode)-&gt;rear-&gt;next = qNode;<br>    (*linkQNode)-&gt;rear = qNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType *e)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((*linkQNode) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    QNode *qNode;<br>    *e = (*linkQNode)-&gt;front-&gt;next-&gt;data;<br>    qNode = (*linkQNode)-&gt;front-&gt;next;<br>    (*linkQNode)-&gt;front-&gt;next = (*linkQNode)-&gt;front-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(qNode);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    LinkQNode linkQNode;<br>    ElemType e;<br>    CreatLinkQueue(&amp;linkQNode);<br>    InitNode(&amp;linkQNode);<br>    EnQueue(&amp;linkQNode, <span class="hljs-number">1</span>);<br>    EnQueue(&amp;linkQNode, <span class="hljs-number">244</span>);<br>    GetHead(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    DeQueue(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    GetHead(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    DestroyNode(&amp;linkQNode);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322151152567.png" alt="image-20230322151152567"></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322151451180.png" alt="image-20230322151451180"></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ol><li><p>使用big O计数法</p></li><li><p>实例</p><ul><li><p>O(1)  常量级的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<br>a=b;<br>a=c;<br>b=c;<br><span class="hljs-comment">//就算重复1000000+都是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>O(n)   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    <span class="hljs-comment">//代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>O(logN) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>    i*=<span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322182248288.png" alt="image-20230322182248288" style="zoom:50%;" /></li><li><p>O(NM)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ol><li><p>实例</p><ul><li><p>O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>O(n)  new 一个维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    newArray[i]=i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>O(n*n)  new 二个维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> [][] newArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][n];<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="线性表（案例分析）"><a href="#线性表（案例分析）" class="headerlink" title="线性表（案例分析）"></a>线性表（案例分析）</h3><ol><li><p>线性表具有同一种特性的数据元素的一个有限的序列</p><p>![image-20230322183519529](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322183519529.png)</p></li><li><p>注意</p><ul><li>下标由1开始</li></ul></li><li><p>基本代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX =<span class="hljs-number">100</span>;<br><span class="hljs-comment">//顺序结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&#123;<br>    ELETMENT List[MAX];<br>    <span class="hljs-type">int</span> listLenth;<br>&#125;List;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322155844508.png" alt="image-20230322155844508"></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322155956690.png" alt="image-20230322155956690"></p></li><li><p>缺点</p><ul><li>存储空间分配不灵活</li><li>空间复杂度高</li></ul></li></ol><h3 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h3><ol><li>线性表的操作<ul><li><p>线性表的初始化（<code>IniList</code>）![image-20230322191953037](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191953037.png)</p></li><li><p>线性表的销毁（<code>DestroyList</code>）</p><p>连本身都没有了</p><p>![image-20230322192004208](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192004208.png)</p></li><li><p>线性表的清楚（<code>ClearList</code>）</p><p>还存在，但是是一个空表</p><p>![image-20230322192014702](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192014702.png)</p></li><li><p>判断线性表是否为空（<code>ListEmpty</code>）</p><p>![image-20230322192029109](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192029109.png)</p></li><li><p>求线性表的长度（<code>ListLength</code>）</p><p>![image-20230322192050448](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192050448.png)</p></li><li><p>获取元素(<code>GetElem</code>)</p><p>![image-20230322190529314](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190529314.png)</p></li><li><p>查找元素（<code>LocateElem</code>）</p><p>![image-20230322190615757](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190615757.png)</p></li><li><p>求一个元素的前驱（<code>PrioElem</code>）</p><p>![image-20230322190742641](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190742641.png)</p></li><li><p>获得一个元素的后继（<code>NextElem</code>）</p><p>![image-20230322190833997](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190833997.png)</p></li><li><p>插入一个元素（<code>ListInsert</code>）</p><p>![image-20230322191334889](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191334889.png)</p></li><li><p>删除一个元素（<code>ListDelete</code>）</p><p>![image-20230322191749620](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191749620.png)</p></li><li><p>遍历线性表（<code>LIstTraverse</code>）</p><p>![image-20230322191844657](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191844657.png)</p></li></ul></li></ol><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><ol><li><p>定义：把逻辑上相邻的数据元素存储在物理相邻的存储单元</p><p>![image-20230322192505711](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192505711.png)</p></li></ol><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><ol><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">//基本模板</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define  SIZE 100</span><br><span class="hljs-comment">typedef struct&#123;</span><br><span class="hljs-comment">    ElemType elem[SIZE];</span><br><span class="hljs-comment">    int length;</span><br><span class="hljs-comment">&#125;SqList;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//int 型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> intElem[SIZE];<br>    <span class="hljs-type">int</span> length;<br>&#125;intList;<br><br><span class="hljs-comment">//int double</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> intElem;<br>    <span class="hljs-type">double</span> doubleElem;<br>&#125;Polynomial;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    Polynomial * PPolynomial;<br>    <span class="hljs-type">int</span> length;<br>&#125;PolynomialList;<br><br><br><span class="hljs-comment">//struct</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">char</span>* author;<br>    <span class="hljs-type">float</span> price;<br>    <span class="hljs-type">int</span> num;<br>&#125;Book;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    Book* pBook;<br>    <span class="hljs-type">int</span> length;<br>&#125;BookList;<br><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="类C语言相关操作"><a href="#类C语言相关操作" class="headerlink" title="类C语言相关操作"></a>类C语言相关操作</h3><ol><li><p><code>ElemType</code> 元素</p></li><li><p>C语言动态内存分配</p></li></ol><ul><li><p><code>malloc</code>: 开辟连续的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">intList *pIntList=(intList*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (intList)*SIZE);<br><span class="hljs-built_in">free</span>(pIntList);<br></code></pre></td></tr></table></figure></li></ul><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>![image-20230323091558306](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230323091558306.png)</p><ol><li><p>代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125; IntList;<br><br><span class="hljs-function">status <span class="hljs-title">initList_Sq</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">destroyList</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">clearList</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">getListLength</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">getElem</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> i, ElemType *e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">isEmpty</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">locateElem</span><span class="hljs-params">(IntList *list, ElemType e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">listInsert</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">listDelete</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType *e)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ElemType *e;<br>    IntList *list = (IntList *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(IntList));<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">initList_Sq</span>(list) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(ERROR);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        list-&gt;elem[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        list-&gt;length++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, list-&gt;elem[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">clearList</span>(list);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s\n&quot;</span>, <span class="hljs-built_in">isEmpty</span>(list) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        list-&gt;elem[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        list-&gt;length++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, <span class="hljs-built_in">getListLength</span>(list));<br>    <span class="hljs-built_in">getElem</span>(list, <span class="hljs-number">4</span>, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c\n&quot;</span>, *e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">locateElem</span>(list, <span class="hljs-string">&#x27;d&#x27;</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">locateElem</span>(list, <span class="hljs-string">&#x27;D&#x27;</span>));<br>    <span class="hljs-built_in">listInsert</span>(list, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;5&#x27;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, list-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">listDelete</span>(list,<span class="hljs-number">5</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>,*e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,list-&gt;elem);<br><br>    <span class="hljs-built_in">listDelete</span>(list,<span class="hljs-number">26</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c\n&quot;</span>,*e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,list-&gt;elem);<br><br>    <span class="hljs-built_in">destroyList</span>(list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//删除</span><br><span class="hljs-function">status <span class="hljs-title">listDelete</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType *e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span> || s &gt; list-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=list-&gt;elem[s<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s - <span class="hljs-number">1</span>; i &lt; list-&gt;length - <span class="hljs-number">1</span>; ++i) &#123;<br>        list-&gt;elem[i] = list-&gt;elem[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    list-&gt;elem[--list-&gt;length] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function">status <span class="hljs-title">listInsert</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s &gt; SIZE || s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list-&gt;length - <span class="hljs-number">1</span>; i &gt;= s - <span class="hljs-number">1</span>; --i) &#123;<br>        list-&gt;elem[i + <span class="hljs-number">1</span>] = list-&gt;elem[i];<br>    &#125;<br>    list-&gt;elem[s - <span class="hljs-number">1</span>] = e;<br>    list-&gt;length++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序查找空间复杂度为  O(n)</span><br><span class="hljs-function">status <span class="hljs-title">locateElem</span><span class="hljs-params">(IntList *list, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e == list-&gt;elem[i]) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">getElem</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> i, ElemType *e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; list-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e = list-&gt;elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">getListLength</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!list) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list-&gt;length;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">isEmpty</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">clearList</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(list-&gt;elem, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(list-&gt;elem));<br>    list-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">destroyList</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list) <span class="hljs-built_in">free</span>(list);<br>    <span class="hljs-keyword">if</span> (!list) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">initList_Sq</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    list-&gt;elem = (ElemType *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * SIZE);<br>    <span class="hljs-keyword">if</span> (!list) <span class="hljs-keyword">return</span> ERROR;<br>    list-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="线性表的链式储存"><a href="#线性表的链式储存" class="headerlink" title="线性表的链式储存"></a>线性表的链式储存</h3><ol><li><p>指针的组成：数据域和指针域（指向下一个）</p></li><li><p>链表的类型</p><ul><li><p>单链表：</p><p>只有一个指针域的链表</p></li><li><p>双链表：</p><p>有两个指针域的链表</p></li><li><p>循环链表：</p><p>首尾相连的链表</p></li></ul></li><li><p>空表的判断：</p><blockquote><p>看一下头指针的是否为NULL,如果为NULL则是空链表</p></blockquote></li><li><p>设置头节点的好处：</p><blockquote><ol><li>便于首元节点的处理</li><li>处理空表和非空表就一样了</li></ol></blockquote><p>![image-20230324170004103](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230324170004103.png)</p></li><li><p>存取元素的方法叫做顺序存取法</p><p>![image-20230324170213582](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230324170213582.png)</p><p>顺序表是随机存取 </p></li><li><p>链表的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><span class="hljs-comment">//使用node表示节点</span><br><span class="hljs-comment">//使用linkList表示链表的</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">clearList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">listLength</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElemSub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> e)</span>;<br><br>status <span class="hljs-title function_">getElemBySub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sub, ElemType *e)</span>;<br><br>node *<span class="hljs-title function_">getElemPoint</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> e)</span>;<br><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub, ElemType e)</span>;<br><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList charListHead = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> e;<br>    <span class="hljs-type">int</span> sub;<br>    <span class="hljs-comment">//创建头节点</span><br>    charListHead = (linkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    charListHead-&gt;next = <span class="hljs-literal">NULL</span>;<br>    charListHead-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-comment">//初始化链表</span><br>    initList(charListHead);<br><br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s&quot;</span>, isEmpty(charListHead) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    <span class="hljs-comment">//清空链表</span><br>    clearList(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s\n&quot;</span>, isEmpty(charListHead) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    initList(charListHead);<br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, listLength(charListHead));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;e&#x27;</span>));<br><br>    getElemBySub(charListHead, <span class="hljs-number">5</span>, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c&quot;</span>, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%p&quot;</span>, getElemPoint(charListHead, <span class="hljs-string">&#x27;e&#x27;</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, insertNode(charListHead, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;a&#x27;</span>));<br>    getElemBySub(charListHead, <span class="hljs-number">2</span>, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c&quot;</span>, e);<br><br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, listLength(charListHead));<br>    printfNode(charListHead);<br><br>    sub = <span class="hljs-number">28</span>;<br>    deleteNode(charListHead, sub);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;Z&#x27;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//删除</span><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span> &#123;<br>    node *moveNode = headNode;<br>    node* temNode=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;sub&amp;&amp;moveNode-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        moveNode=moveNode-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;=sub||moveNode==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    temNode=moveNode-&gt;next;<br>    moveNode-&gt;next=moveNode-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(temNode);<br>    <span class="hljs-keyword">return</span> OK;<br><br>&#125;<br><br><span class="hljs-comment">//插入元素</span><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub, ElemType e)</span> &#123;<br>    node *moveNode = headNode;<br>    node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    temNode-&gt;date = e;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &gt;= listLength(headNode)) &#123;<br>        <span class="hljs-built_in">free</span>(temNode);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> tem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tem != sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    temNode-&gt;next = moveNode-&gt;next;<br>    moveNode-&gt;next = temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//取出元素返回地址</span><br>node *<span class="hljs-title function_">getElemPoint</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> ElemType e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span> &amp;&amp; moveNode-&gt;date != e) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> moveNode;<br>&#125;<br><br><br><span class="hljs-comment">//通过下标取出元素</span><br>status <span class="hljs-title function_">getElemBySub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sub, ElemType *e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-type">int</span> tem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tem != sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>        tem++;<br>    &#125;<br>    *e = moveNode-&gt;date;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//取出元素通过下标</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElemSub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> ElemType e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-type">int</span> sub = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (moveNode &amp;&amp; moveNode-&gt;date != e) &#123;<br>        moveNode = moveNode-&gt;next;<br>        sub++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (moveNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> sub;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//求链表的长度</span><br>status <span class="hljs-title function_">listLength</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        i++;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<span class="hljs-number">-1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//清空链表</span><br>status <span class="hljs-title function_">clearList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = <span class="hljs-literal">NULL</span>;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next = <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    headNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//判断是否为空</span><br>status <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *nextNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        nextNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        nextNode-&gt;date = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        moveNode-&gt;next = nextNode;<br>        moveNode = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>链表操作的时间和空间复杂度</p><ul><li><p>查找  O(n)</p></li><li><p>插入和删除 O(1)</p><p>理由是，插入和删除都是在一瞬间发生的事，不包括前面的查找</p><p>所以在查找的时间复杂度为 O(n);</p></li></ul></li><li><p>链表初始化的方式</p><ul><li><p>头插法</p><p>意思是每次都是从头节点后面一位插入数据</p><p>这个是反循序的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node* temNode=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        <span class="hljs-keyword">if</span>(temNode==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        temNode-&gt;date=<span class="hljs-string">&#x27;a&#x27;</span>+i;<br>        temNode-&gt;next=headNode-&gt;next;<br>        headNode-&gt;next=temNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>尾插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//初始化</span><br>status <span class="hljs-title function_">initList2</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *nextNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        nextNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        nextNode-&gt;date = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        moveNode-&gt;next = nextNode;<br>        moveNode = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>问题代码</p><ul><li>为什么将头节点放进函数<code>malloc</code>,在main函数中，头节点却是空？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode = <span class="hljs-literal">NULL</span>;<br>    initList(headNode);<br>    printfNode(headNode);<br>    destroyList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    headNode = (linkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    headNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    headNode-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;date = <span class="hljs-string">&#x27;a&#x27;</span> + i;<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        moveNode-&gt;next = temNode;<br>        moveNode = temNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><p>C语言的传参本质上都是传值，也就是拷贝传参，普通变量拷贝的普通的值，指针变量拷贝的是指针</p><p>具体参考：<a href="%5B(21%E6%9D%A1%E6%B6%88%E6%81%AF">深入理解C语言函数传参方式</a> 深入理解C语言函数传参方式_c 为什么是一个一个传参的_amcomputer的博客-CSDN博客](<a href="https://blog.csdn.net/qq_39463175/article/details/115566613">https://blog.csdn.net/qq_39463175/article/details/115566613</a>))</p><p>所以修改后的代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode = <span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode);<br>    printfNode(headNode);<br>    destroyList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList* headNode)</span> &#123;<br>    (*headNode)=(linkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span>((*headNode)==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    (*headNode)-&gt;next=<span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;date=<span class="hljs-string">&#x27;0&#x27;</span>;<br>    node* moveNode=(*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node* temNode=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>        temNode-&gt;date=<span class="hljs-string">&#x27;A&#x27;</span>+i;<br>        moveNode-&gt;next=temNode;<br>        moveNode=moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        num++;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    headNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ol><li><p>最后一个节点指向首节点</p></li><li><p>因为没有最后一个节点为空，所以我们在遍历的时候，我们需要判断等不等于头节点</p></li><li><p>使用尾指针更加的方便（更快的操作末节点，头节点和<code>a1</code>）</p></li><li><p>简单的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *circularLinkList;<br><br>circularLinkList <span class="hljs-title function_">initList</span><span class="hljs-params">(circularLinkList *headNode)</span>;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(circularLinkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(circularLinkList headNode)</span>;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(circularLinkList tailNode1, circularLinkList tailNode2)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    circularLinkList headNode1 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList headNode2 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList tailNode1 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList tailNode2 = <span class="hljs-literal">NULL</span>;<br>    tailNode1 = initList(&amp;headNode1);<br>    tailNode2 = initList(&amp;headNode2);<br>    printfList(headNode1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    combineList(tailNode1,tailNode2);<br>    printfList(headNode1);<br>    destroyList(headNode1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//将链表2接在链表一的后面，且保留链表一的头节点</span><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(circularLinkList tailNode1, circularLinkList tailNode2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tailNode1 == <span class="hljs-literal">NULL</span> || tailNode1 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = tailNode1-&gt;next;<br>    tailNode1-&gt;next = tailNode2-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(tailNode2-&gt;next);<br>    tailNode2-&gt;next=<span class="hljs-literal">NULL</span>;<br>    tailNode2-&gt;next = temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(circularLinkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(circularLinkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(headNode);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>circularLinkList <span class="hljs-title function_">initList</span><span class="hljs-params">(circularLinkList *headNode)</span> &#123;<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    getchar();<br>    node *moveNode = (*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;date = a + i;<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        moveNode-&gt;next = temNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next = (*headNode);<br>    <span class="hljs-keyword">return</span> moveNode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ol><li><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prior</span>;</span><br>&#125; node, *linkList;<br><br><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, ElemType data, <span class="hljs-type">int</span> sub)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    temNode-&gt;data = data;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (--sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next-&gt;prior = temNode;<br>    temNode-&gt;next = moveNode-&gt;next;<br>    temNode-&gt;prior = moveNode;<br>    moveNode-&gt;next = moveNode-&gt;next-&gt;prior;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLinkLength</span><span class="hljs-params">(linkList headNode)</span>&#123;<br>    <span class="hljs-keyword">if</span>(headNode==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    node* moveNode=headNode-&gt;next;<br>    <span class="hljs-keyword">while</span>(moveNode!=headNode)&#123;<br>        moveNode=moveNode-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &lt; <span class="hljs-number">1</span>||sub%getLinkLength(headNode)==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;deleteNode ERROR\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (--sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next-&gt;prior = moveNode-&gt;prior;<br>    moveNode-&gt;prior-&gt;next = moveNode-&gt;next;<br>    <span class="hljs-built_in">free</span>(moveNode);<br>    moveNode=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">insertLink</span><span class="hljs-params">(linkList headNode, linkList insertHeadNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || insertHeadNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = headNode;<br>    headNode-&gt;prior-&gt;next = insertHeadNode-&gt;next;<br>    insertHeadNode-&gt;next-&gt;prior = headNode-&gt;prior;<br>    headNode-&gt;prior = insertHeadNode-&gt;prior;<br>    headNode-&gt;prior-&gt;next = headNode;<br>    <span class="hljs-built_in">free</span>(insertHeadNode);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">destroyLink</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    node *deleteNode = moveNode;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num);<br>    headNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">initLinkList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span> ((*headNode) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">char</span> a;<br>    (*headNode)-&gt;data = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    node *moveNode = (*headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    getchar();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;data = a + i;<br>        moveNode-&gt;next = temNode;<br>        moveNode-&gt;next-&gt;prior = moveNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next = (*headNode);<br>    moveNode-&gt;next-&gt;prior = moveNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">printNodeACW</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;prior;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;data);<br>        moveNode = moveNode-&gt;prior;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">printNodeCW</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;data);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode;<br>    linkList headNode2;<br>    initLinkList(&amp;headNode);<br>    initLinkList(&amp;headNode2);<br>    printNodeCW(headNode);<br>    printNodeACW(headNode);<br><br>    insertLink(headNode, headNode2);<br>    printNodeCW(headNode);<br><br>    insertNode(headNode, <span class="hljs-string">&#x27;&amp;&#x27;</span>, <span class="hljs-number">54</span>);<br>    printNodeCW(headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, getLinkLength(headNode));<br><br>    deleteNode(headNode,<span class="hljs-number">55</span>);<br>    printNodeCW(headNode);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, getLinkLength(headNode));<br><br>    destroyLink(headNode);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="不同链表的比较"><a href="#不同链表的比较" class="headerlink" title="不同链表的比较"></a>不同链表的比较</h3><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E7%A7%8D%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="多种链表的比较"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%82%B9.png" alt="链式存储的优点"></p><p>  <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png"></p></li></ol><h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><ol><li><p>有序表的合并</p><ul><li><p>线性表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; headNode-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, headNode-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;length = num;<br>    (*headNode)-&gt;elem = (ElemType *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType) * num);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*headNode)-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(linkList *headNode1, linkList headNode2)</span> &#123;<br>    <span class="hljs-type">int</span> subLa = <span class="hljs-number">0</span>, subLb = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l1 = (*headNode1)-&gt;length, l2 = headNode2-&gt;length;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    ElemType *temC = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (l1 + l2));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; subLa &lt; l1 &amp;&amp; subLb &lt; l2; ++i) &#123;<br>        temC[i] = (*headNode1)-&gt;elem[subLa] &lt; headNode2-&gt;elem[subLb] ? (*headNode1)-&gt;elem[subLa++]<br>                                                                     : headNode2-&gt;elem[subLb++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; l1 + l2) &#123;<br>        *(temC + i) = subLb &lt; l2 ? (headNode2)-&gt;elem[subLb++] : (*headNode1)-&gt;elem[subLa++];<br>        i++;<br>    &#125;<br>    (*headNode1)-&gt;elem = temC;<br>    (*headNode1)-&gt;length = l1 + l2;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">destroyLink</span><span class="hljs-params">(linkList pDel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pDel == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(pDel-&gt;elem);<br>    <span class="hljs-built_in">free</span>(pDel);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode1 = <span class="hljs-literal">NULL</span>;<br>    linkList headNode2 = <span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode1);<br>    initList(&amp;headNode2);<br>    combineList(&amp;headNode1, headNode2);<br>    printfList(headNode1);<br>    destroyLink(headNode1);<br>    destroyLink(headNode2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType elem;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br><br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;elem = <span class="hljs-number">0</span>;<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    node *moveNode = (*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;temNode-&gt;elem);<br>        moveNode-&gt;next = temNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(linkList *headNode, linkList headNode2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || headNode2 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode1 = (*headNode)-&gt;next, *moveNode2 = headNode2-&gt;next, *moveNodeC = (*headNode);<br>    <span class="hljs-keyword">while</span> (moveNode1 != <span class="hljs-literal">NULL</span> &amp;&amp; moveNode2 != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (moveNode1-&gt;elem &gt; moveNode2-&gt;elem) &#123;<br>            moveNodeC-&gt;next = moveNode2;<br>            moveNode2 = moveNode2-&gt;next;<br>            moveNodeC=moveNodeC-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            moveNodeC-&gt;next = moveNode1;<br>            moveNode1 = moveNode1-&gt;next;<br>            moveNodeC=moveNodeC-&gt;next;<br>        &#125;<br>    &#125;<br>    moveNodeC-&gt;next = moveNode1==<span class="hljs-literal">NULL</span> ? moveNode2 : moveNode1;<br>    <span class="hljs-built_in">free</span>(headNode2);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, moveNode-&gt;elem);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode1=<span class="hljs-literal">NULL</span>;<br>    linkList headNode2=<span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode1);<br>    initList(&amp;headNode2);<br>    printfNode(headNode1);<br>    combineList(&amp;headNode1,headNode2);<br>    printfNode(headNode1);<br>    destroyList(headNode1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda高级使用</title>
    <link href="/2023/03/26/c++/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/26/c++/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="lambda高级使用"><a href="#lambda高级使用" class="headerlink" title="lambda高级使用"></a>lambda高级使用</h1><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的 this <a href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><ol><li>没有捕获的时候，我们将该lambda变量可以看成函数指针</li><li>有捕获的时候，我们将该lambda表达式堪称仿函数</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>使用<code>function</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; func&#123;[](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;&#125;;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>使用<code>bind</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>([](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/03/26/c++/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/26/c++/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li><p>通过类里函数可以给私有成员赋值，同时也可以通过函数return 出值</p></li><li><p>特殊的成员函数，主要用于创建对象时初始化对象-&gt;给对象成员赋予初值</p></li><li><p>构造函数的特点</p><ul><li>构造函数的函数名与类名相同</li><li>构造函数没有返回值类型，也没有返回值</li><li>构造函数可以重载</li></ul></li><li><p>没有写构造函数，自己会生成，由于内联函数，牺牲时间换效率</p><ul><li><p>系统给的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Myclass</span>()&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>系统给的构造函数相当于低保</p></li><li><p>构造函数，在创建时系统就会调用，不能通过对象调用构造函数</p></li><li><p>默认给的构造函数，是<code>public</code>类型</p></li><li><p><code>const</code>:改变性质，将变量变成常量</p><ul><li><p>对<code>const</code>修饰的变量在函数创建时进行赋值：</p></li><li><p>是在初始化的时候赋初值，不是在声明的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostram&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">chg</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num2;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num3;<br>    <span class="hljs-built_in">chg</span>();<br>  <span class="hljs-keyword">private</span>:  <br>&#125;;<br><br>chg::<span class="hljs-built_in">chg</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i):<span class="hljs-built_in">num1</span>(n),<span class="hljs-built_in">num2</span>(i),<span class="hljs-built_in">num3</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//括号里面可以是变量也可以是常量</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol><li>一种特殊的函数，作用是在对象的生命周期结束时进行清理，系统可以自动调用析构函数</li><li>函数名与类名一致，在前面加上<code>~</code></li><li>没有返回值，也没有参数，但必须有参数表也就是（）</li><li>有低保，没写的话，系统自动分配</li><li>可以通过外部访问到析构函数</li><li>在类创建时，自动使用一次，构造，和析构（在生命周期结束时，会自动调用析构函数）</li><li>先构造的后析构</li></ol><h2 id="拷贝构造，-函数"><a href="#拷贝构造，-函数" class="headerlink" title="拷贝构造， 函数"></a>拷贝构造， 函数</h2><ol><li><p>先是构造函数，才可能是拷贝构造函数</p></li><li><p>有低保，系统会统一给</p></li><li><p>第一个参数是，该类的对象</p><p>操作实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//构造函数</span><br>    ~<span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//析构函数</span><br>    <span class="hljs-built_in">Myclass</span>(Myclass&amp; obj);<span class="hljs-comment">//拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用时机</p><ul><li><p>使用一个对象给另一个对象进行初始化</p></li><li><p>使用一个对象构造另一个对象</p></li><li><p>函数的参数是类的对象</p></li><li><p>返回值是类</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zjy2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    zjy zjy3;<span class="hljs-comment">//进行无参构造</span><br>    <br>    <span class="hljs-keyword">return</span> zjy3;<span class="hljs-comment">//由于zjy3存在于栈区，所以函数结束会被回收，因此返回值是zjy3的复制体，此时调用了拷贝构造</span><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> chg;<br>     <span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n);<br>     <span class="hljs-built_in">zjy</span>();<br>     ~<span class="hljs-built_in">zjy</span>();<br>     <span class="hljs-built_in">zjy</span>(zjy&amp;obj);<br>&#125;;<br> zjy::<span class="hljs-built_in">zjy</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;无参构造&quot;</span>&lt;&lt;endl;<br>&#125;<br> zjy::<span class="hljs-built_in">zjy</span>(zjy &amp;obj)<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br> zjy::~<span class="hljs-built_in">zjy</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><br> zjy::<span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n)<br>&#123;<br>     chg=<span class="hljs-number">520</span>;<br>     n=chg;<br>     cout&lt;&lt;n&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;带参构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     zjy obj;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-function">zjy <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二个代码运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201151814859.png" alt="image-20221201151814859"></p><ul><li>无参构造：<code>func</code>里面的<code>obj</code></li><li>析构函数：函数调用完会释放内存，这里释放的是第一个obj，所以调用析构函数</li><li>带参构造：43行代码</li><li>无参构造：是因为用了chg来接收</li></ul><p>由于上面结果不一致，重点参考下面的</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201152314605.png" alt="image-20221201152314605"></p><ul><li>无参构造：调用<code>test_func_2()</code>，从主调函数，进入被调函数，创建<code>Monster obj</code>采用的是无参构造</li><li>拷贝构造1号：因为需要函数返回<code>obj</code>,但是函数里面的数据在函数完成时，会被释放，所以采用拷贝构造创建的副本<code>obj</code></li><li>析构（1）：当函数完成时，释放内存，调用析构函数释放原本的<code>obj</code></li><li>析构（2）：由于没有接收<code>obj</code>,所以会在执行完76行释放返回的<code>obj</code>副本</li><li>无参构造：78行调用函数（如上的无参构造）</li><li>拷贝构造1号：如上</li><li>析构（3）：如上，第一个析构</li><li>析构（4）：这里的析构和第二个析构不一样，这里的析构是因为，<code>main</code>完成了，释放<code>monster</code>接收的<code>obj</code></li></ul></li><li><p>问题1：为什么第78行<code>Monster monster=test_func_2()</code>这里没有拷贝构造？</p><ul><li>没有东西去接收复制体时，系统会创建一个临时的对象，再用拷贝构造，将返回的<code>obj</code>，拷贝构造给临时变量</li><li>由于78行，有一个<code>monster</code>接收返回的<code>obj</code>，系统优化，直接复制给<code>monster</code>,所以不会调用拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201154807685.png" alt="image-20221201154807685"></p><ul><li>无参构造：因为这里在<code>return </code>后面创建了一个<code>zjy（匿名对象）</code>，相当于在函数外边创建了一个对象，这里不会采用拷贝构造，所以时无参构造</li><li>析构函数：因为没有接收对象，所以在49行的时候析构掉了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//func();</span><br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201155016536.png" alt="image-20221201155016536"></p><ul><li>无参构造：因为调用<code>test_func_2()</code>，创建了一个匿名对象，采用无参构造（和上面的无参构造一样）</li><li>析构：因为main函数结束，调用析构函数</li></ul></li></ul></li><li><p>对于指针的构造：不能直接将指针指向那个地址，而是，创建一个新的内存用于存放原有的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *q=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        p[i]=i;<span class="hljs-comment">//可以相当于创建了一个数组，对于数组的存储可以用arr[i]=int类型</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        q[i]=p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>浅拷贝和深拷贝</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202094645975.png" alt="image-20221202094645975"></p></li><li><p>如何防止默认拷贝的发生（浅拷贝）？</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202095003679.png" alt="image-20221202095003679"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>右值和左值</title>
    <link href="/2023/03/26/c++/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/"/>
    <url>/2023/03/26/c++/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="右值和左值"><a href="#右值和左值" class="headerlink" title="右值和左值"></a>右值和左值</h1><h2 id="右值左值的区分"><a href="#右值左值的区分" class="headerlink" title="右值左值的区分"></a>右值左值的区分</h2><ol><li><p>能取地址的是左值，不能取地址的是右值</p></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//左值</span><br>    <span class="hljs-type">int</span> lvalue=<span class="hljs-number">244</span>;<br>    <span class="hljs-comment">//左值引用</span><br>    <span class="hljs-type">int</span> &amp;lvalueCite=lvalue;<br>    <span class="hljs-comment">//右值</span><br>    <span class="hljs-comment">//右值引用</span><br>    <span class="hljs-type">int</span> &amp;&amp;rvalueCite=<span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用右值引用延长生命周期</p></li></ol><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><ol><li><p>作用： 复用其他对象的资源（堆内存）</p></li><li><p>实现浅拷贝 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参构造</span><br>    <span class="hljs-built_in">name1</span>()&#123;<br>        mPtr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-built_in">name1</span>(<span class="hljs-type">const</span> name1 &amp;tem)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mPtr=tem.mPtr;<br>    &#125;<br>    <span class="hljs-comment">//移动构造</span><br>    <span class="hljs-built_in">name1</span>(name1&amp;&amp; tem):<span class="hljs-built_in">mPtr</span>(tem.mPtr)<br>    &#123;<br>        tem.mPtr=<span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> * mPtr;<br>&#125;;<br><br><span class="hljs-function">name1 <span class="hljs-title">getObj</span><span class="hljs-params">()</span></span>&#123;<br>    name1 name11;<br>    *name11.mPtr=<span class="hljs-number">2</span>;<br>    std::cout&lt;&lt;name11.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> name11;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//要求右侧是个临时对象，才会调用移动拷贝构造函数</span><br>    <span class="hljs-comment">//如果没有移动拷贝构造函数，就会调用拷贝构造函数</span><br>    name1 obj=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj.mPtr&lt;&lt;std::endl;<br>    name1&amp;&amp; obj2=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj2.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj2.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用 C++11 提供的 std::forward () 函数，该函数实现的功能称之为完美转发。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可调用对象包装器</title>
    <link href="/2023/03/26/c++/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <url>/2023/03/26/c++/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h1><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可以按照函数的方法进行调用</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>函数指针</p><blockquote><p>使用<code>using</code>进行定义函数指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>);<br></code></pre></td></tr></table></figure></li><li><p>仿函数</p></li><li><p>可以转换为函数的类对象</p></li><li><p>类成员的函数指针</p></li><li><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*这段代码定义了一个名为name1的类，其中包含两个函数testFunc和testFunc2。testFunc是静态函数，可以通过指针调用，而testFunc2是实例方法，只能通过对象调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此外，代码还定义了一个名为callBack的函数指针类型，它接受一个int类型和一个double类型的参数，并且没有返回值。在类定义中，将operator callBack()定义为转换运算符，它返回testFunc的指针，使得对象也可以像函数一样被调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在main函数中，首先使用obj.operator callBack()将obj对象转换为callBack类型的函数指针，并将其赋值给func。然后，使用&amp;name1::testFunc将testFunc的地址赋值给func2，使用&amp;name1::testFunc2将testFunc2的地址赋值给func3。最后，使用func(1,2)调用testFunc函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">整体来说，此代码演示了如何定义和使用函数指针以及转换运算符的概念。*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">using</span> callBack=<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//callBack是定义的函数指针变量名,这一步是想将类名当作函数使用</span><br>     <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">return</span> testFunc;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">testFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testFunc2</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> callBack2=<span class="hljs-built_in">void</span>(name1::*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br>    name1 obj;<br>    <span class="hljs-comment">//通过转换运算符</span><br>    callBack func=obj.<span class="hljs-keyword">operator</span> <span class="hljs-built_in">callBack</span>();<br>    <span class="hljs-comment">//通过函数指针</span><br>    callBack func2=&amp;name1::testFunc;<br>    <span class="hljs-comment">//callBack2是限定了作用域的函数指针，注意此处必须要有&amp;</span><br>    callBack2 func3=&amp;name1::testFunc2;<br><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="function的使用"><a href="#function的使用" class="headerlink" title="function的使用"></a><code>function</code>的使用</h2><ul><li><p>作用：说是可调用对象当作函数使用</p></li><li><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> a,std::string s);<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;this is func&quot;</span>&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">testStruct</span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is testStruct&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">classFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>          <span class="hljs-keyword">return</span> classFunc;<br>      &#125;<br>  <br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classOperator()&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>      <span class="hljs-comment">//调用function</span><br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          <span class="hljs-built_in">tem</span>(a,s);<br>      &#125;<br>  <span class="hljs-keyword">private</span>:<br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>  &#125;;<br>  <br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-comment">//通过函数包装器调用普通函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f1=func;<br>      <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//伪函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f2=<span class="hljs-built_in">testStruct</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-comment">//类里面的静态函数</span><br>      f2=name1::classFunc;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;tsy&quot;</span>);<br>      <span class="hljs-comment">//通过转换运算符，将类变成了可调用对象</span><br>      name1 name;<br>      f2=name;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<br>  <br>      <span class="hljs-comment">//尝试将function当成参数，调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint</span><span class="hljs-params">(f1)</span></span>;<br>      objPrint.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;jc&quot;</span>);<br>      <span class="hljs-comment">//因为我们的类是可调用的对象所以可以当作function</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint2</span><span class="hljs-params">(name)</span></span>;<br>      objPrint2.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;wr&quot;</span>);<br>      <span class="hljs-comment">//调用类的静态</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint3</span><span class="hljs-params">(name.classFunc)</span></span>;<br>      objPrint3.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;01&quot;</span>);<br>      <span class="hljs-comment">//普通函数调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint4</span><span class="hljs-params">(func)</span></span>;<br>      objPrint4.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;gzx&quot;</span>);<br>      <span class="hljs-comment">//使用伪函数时需要创建对象</span><br>      testStruct testStruct;<br>      <span class="hljs-function">print <span class="hljs-title">objPrint5</span><span class="hljs-params">(testStruct)</span></span>;<br>      objPrint5.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&quot;tcx&quot;</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>## 可调用对象绑定器<br><br>- 作用：<br>  - 将可调用对象绑定成仿函数<br>  - 将多元参数函数绑定成参数为<span class="hljs-number">1</span>，或者（n<span class="hljs-number">-1</span>）的可调用对象<br><br>- 绑定非类的实例：<br><br>  ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot; a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; s = &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,std::placeholders::_2);<br>      <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//注意如果在bind的时候初始化了a和s则在f2(),的括号中添加的参数，没有效果</span><br>      <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(print,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-built_in">f2</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<span class="hljs-comment">//无效果</span><br>      <span class="hljs-keyword">auto</span> f3= std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,<span class="hljs-string">&quot;xxp&quot;</span>);<br>      <span class="hljs-built_in">f3</span>(<span class="hljs-number">3</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>绑定类里的成员函数和成员变量的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>    &#125;<br>    std::string s;<br>&#125;;<br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>    <span class="hljs-comment">//调用function</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        <span class="hljs-built_in">tem</span>(a,s);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//类的成员函数的绑定</span><br>    myClass myclassObj1;<br>    <span class="hljs-keyword">auto</span> f1= std::<span class="hljs-built_in">bind</span>(&amp;myClass::test,&amp;myclassObj1,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-function">print <span class="hljs-title">frintObj1</span><span class="hljs-params">(f1)</span></span>;<br>    frintObj1.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-comment">//绑定类的成员变量</span><br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(&amp;myClass::s,&amp;myclassObj1);<br>    <span class="hljs-built_in">f2</span>()=<span class="hljs-string">&quot;chg&quot;</span>;<span class="hljs-comment">//对类成员赋值</span><br>    std::cout&lt;&lt;<span class="hljs-built_in">f2</span>()&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
