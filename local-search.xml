<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用指令</title>
    <link href="/2023/04/17/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/04/17/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ol><li><p><code>LInux</code>的根目录是树形结构</p><p>Linux没有盘符（C盘等）的概念，只有一个根目录<code>/</code></p><p><img src="https://linux-1317182407.cos.ap-nanjing.myqcloud.com/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p></li><li><p>文件路径的描述方式</p><p>使用<code>/</code></p><p><code>windows</code>使用<code>\</code></p><ul><li>注意文件路径的开始必须是<code>/</code>,第一个是根目录，后面的是层级关系</li></ul></li></ol><h2 id="LInux命令入门"><a href="#LInux命令入门" class="headerlink" title="LInux命令入门"></a>LInux命令入门</h2><ol><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux初始</title>
    <link href="/2023/04/17/linux%E5%88%9D%E5%A7%8B/"/>
    <url>/2023/04/17/linux%E5%88%9D%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux初-识"><a href="#Linux初-识" class="headerlink" title="Linux初  识"></a>Linux初  识</h1><h2 id="Linux初始"><a href="#Linux初始" class="headerlink" title="Linux初始"></a>Linux初始</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>Linux系统内核</li><li>系统级应用程序</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概述</title>
    <link href="/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>计算机由哪两个部分组成</p><p>软件和硬件</p></li><li><p>操作系统是什么？</p><p>操作系统是软件的一种</p><p>主要作用是协助用户调度硬件工作充当用户和计算机硬件之间的桥梁</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效括号序列</title>
    <link href="/2023/04/17/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    <url>/2023/04/17/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">有效括号序列_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>                stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;item: s) &#123;<br>            <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;[&#x27;</span> || item == <span class="hljs-string">&#x27;(&#x27;</span> || item == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack.<span class="hljs-built_in">push</span>(item);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;]&#x27;</span> || item == <span class="hljs-string">&#x27;)&#x27;</span> || item == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-comment">//防止栈区为empty，还取出top</span><br>                <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//防止出现只有右开口符号的请情况</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>改进代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item:s)&#123;<br>            <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-comment">//防止空取top</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item==stack.<span class="hljs-built_in">top</span>())&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//提高执行效率，如果不对应，就直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">empty</span>();<br>        <span class="hljs-comment">//当true,则说明一一对应</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E6%8F%90%E7%A4%BA.gif"></p></li><li><p>理解</p><ul><li>整体只会遍历一次，遇到开口向右的符号就存进<code>stack</code>，反之对比出栈</li></ul></li><li><p>问题</p><ul><li><p>为什么返回<code>stack.empty()</code></p><blockquote><p>有且仅当，一一对应时才能返回</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp代码规范</title>
    <link href="/2023/04/14/cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2023/04/14/cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="c-代码规范"><a href="#c-代码规范" class="headerlink" title="c++代码规范"></a>c++代码规范</h1><h2 id="基本代码规范"><a href="#基本代码规范" class="headerlink" title="基本代码规范"></a>基本代码规范</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>方法一</strong></p><ol><li>包括两个文件一个是<code>inc</code>这个目录放<code>.h</code>文件，还有一个<code>src</code>目录，放置<code>.cpp</code>文件。</li></ol><p><strong>方法二</strong></p><ol><li>按照功能分文件</li></ol><h3 id="头文件结构"><a href="#头文件结构" class="headerlink" title="头文件结构"></a>头文件结构</h3><p><strong>处理方式一</strong></p><ol><li>使用<code>ifndef</code>&#x2F;<code>define</code>&#x2F;<code>endif</code></li></ol><p><strong>处理方式二</strong></p><ol><li>使用<code>#pragma once</code></li></ol><h3 id="头文件的包含"><a href="#头文件的包含" class="headerlink" title="头文件的包含"></a>头文件的包含</h3><ol><li>使用路径包括</li></ol><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><ol><li>建议使用二级命名空间，第一个命名空间是项目名称，第二个是模块名称</li></ol><h3 id="代码行的使用"><a href="#代码行的使用" class="headerlink" title="代码行的使用"></a>代码行的使用</h3><ol><li><p>一行代码只做一件事</p></li><li><p>在定义变量的时候初始化变量</p><img src="https://pictuures-1317182407.cos.ap-chengdu.myqcloud.com/%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81.png?q-sign-algorithm=sha1&q-ak=AKID62gNbIugj-rlltKDtx9qQ0_NXvaVQ5eNhwwxGkulFmHBe0ryycrOgtLN1PJ48AwE&q-sign-time=1681488019;1681491619&q-key-time=1681488019;1681491619&q-header-list=host&q-url-param-list=&q-signature=e4a689d272023a355d0531e4c2a8e304b91e3f84&x-cos-security-token=0TXuI2oo8Sb5JGse9bsw7agND0rUgf7ab53099746c0362b69c92e54403bee6c1Ar87iX4JGt_CJ_4-yiOqn5qq0oYOzq5Mvx5tZYU4UMH4CzPOLXAXckkgflDKpLF8EFsMkPbIaiZBHDbuZKO7M7wuhqklRkTpvoysQC3p_jlBgtUCJW9hscAxiDk_3qQDgHzlDrdCKzHaDdduRuoDolrxPPI9XoPQLvaqMiBwujWJDhXsHm8ruOPtekvK2ev8" style="zoom:150%;" /></li></ol><h3 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h3><ol><li>版本，版权的说明</li><li>函数接口的说明</li><li>重要代码</li><li>代码即注释</li></ol><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li><p><code>class</code></p><p>采取大驼峰命名法</p><p>例如<code>MyClass</code></p></li><li><p>函数</p><p>采取驼峰命名</p></li><li><p>也可以在中间添加<code>_</code></p><p><code>creat_func</code>前后都是小写</p></li><li><p>变量命名</p><p>变量的意思</p></li></ol><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ol><li>添加<code>()</code></li><li>不编写太复杂的表达式</li></ol><h2 id="概念抽象与命名"><a href="#概念抽象与命名" class="headerlink" title="概念抽象与命名"></a>概念抽象与命名</h2><ol><li>类的命名是名词</li><li>函数是动词</li></ol><h2 id="大道至简"><a href="#大道至简" class="headerlink" title="大道至简"></a>大道至简</h2><ol><li>模块复用</li><li>化繁为简</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的压入和弹出序列</title>
    <link href="/2023/04/13/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2023/04/13/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.png"></p><ol><li><p>代码</p><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV, vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, n = pushV.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : popV) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; (stack.<span class="hljs-built_in">empty</span>() || stack.<span class="hljs-built_in">top</span>() != item)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(pushV[j++]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>() == item) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二（自写）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV, vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pushV.<span class="hljs-built_in">size</span>() != popV.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; pushV.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; pushV.<span class="hljs-built_in">size</span>() &amp;&amp;i &gt;= <span class="hljs-number">0</span>&amp;&amp; pushV[i] == popV[j] ) &#123;<br>                pushV.<span class="hljs-built_in">erase</span>(pushV.<span class="hljs-built_in">begin</span>() + i);<br>                i--;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (popV.<span class="hljs-built_in">size</span>() == j) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>提示</p><p>方法一：</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E6%A0%88/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.gif"></p><p>方法二：</p><ol><li>遍历<code>push</code>，如果当发现<code>push</code>的元素与<code>pop</code>的元素相等的话，我们就选择将这个<code>push</code>元素<code>erase</code>,并且将下标往前移动一，也就是<code>i--</code></li><li>如果发现<code>pop</code>也都遍历完了，我们就<code>return</code>成功。如果<code>push</code>的下标超过了<code>push.size()</code>我们就选择<code>return false</code></li></ol></li><li><p>理解</p><p>方法一</p><ul><li><p>确保push遍历完时，还可以遍历pop，所以采取遍历pop的方式</p></li><li><p>借助辅助栈，对比是否出栈的顺序是否一致</p></li><li><p>整体的思路如下</p><p>当push没有遍历完，且栈是空或者栈顶不和pop一致，应该往栈push</p><p>如果发现栈顶的值与pop的一致，应该跳出循环，并将栈顶的元素弹出</p><p>如果当push走完时，栈顶元素不和pop相等则说明不相等</p></li><li><p>当两个vector都遍历完时，则说明序列一致</p></li></ul><p>方法二</p><ul><li>将<code>push</code>拿来遍历，如果push都走完了，我们的<code>pop</code>还没走完就选择<code>return false</code></li><li>如果<code>size</code>都不相等，就像应该直接返回<code>false</code></li></ul></li><li><p>问题</p><p>方法一</p><ul><li><p>如何确保push完全走完</p><blockquote><p>循环遍历pop</p></blockquote></li></ul><p>方法二</p><ul><li><p>如何防止<code>popV</code>越界</p><blockquote><p>使用i&gt;&#x3D;0，如果该条件不满足，则说明已经遍历完成</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表结点</title>
    <link href="/2023/04/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/"/>
    <url>/2023/04/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=308&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/company">删除链表的节点_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> *  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param head ListNode类</span><br><span class="hljs-comment">     * @param val int整型</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* moveNode=dummy;<br>        <span class="hljs-keyword">while</span>(moveNode-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(moveNode-&gt;next-&gt;val==val)<br>            &#123;<br>                moveNode-&gt;next=moveNode-&gt;next-&gt;next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            moveNode=moveNode-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>        <span class="hljs-comment">/*        ListNode* moveNode = head;</span><br><span class="hljs-comment">                ListNode* pre=head;</span><br><span class="hljs-comment">                if(head-&gt;val==val)&#123;</span><br><span class="hljs-comment">                    return head-&gt;next;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                while (moveNode != nullptr) &#123;</span><br><span class="hljs-comment">                    if (moveNode-&gt;val == val) &#123;</span><br><span class="hljs-comment">                        pre-&gt;next=moveNode-&gt;next;</span><br><span class="hljs-comment">                        moveNode = moveNode-&gt;next;</span><br><span class="hljs-comment">                        break;</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                    pre=moveNode;</span><br><span class="hljs-comment">                    moveNode = moveNode-&gt;next;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                return head;*/</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注释是自己的方法</p></li><li><p>提示</p><ul><li>对来链表操作，或者返回链表的使用虚拟头节点</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随记</title>
    <link href="/2023/04/12/java%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/04/12/java%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>java的初始化</p><p>Java的初始化是指在创建对象时为其成员变量设定初值的过程。Java中的所有对象在创建时，其成员变量都会被默认初始化为其对应类型的默认值（如int类型的默认值为0，引用类型的默认值为null）。如果需要对成员变量进行显式初始化，可以通过构造函数、代码块或直接赋值的方式实现。</p><p>构造函数是一种特殊的方法，用于在创建对象时执行一些初始化操作。在Java中，每个类都有一个与之同名的构造函数，可以通过这个构造函数来初始化对象的成员变量。如果没有定义构造函数，Java会提供一个默认构造函数，但是默认构造函数不会做任何事情。</p><p>除了构造函数，Java还提供了代码块的概念。<strong>代码块分为静态代码块和非静态代码块。静态代码块在类加载时执行，非静态代码块在每次创建对象时都会执行。代码块中的语句可以用来初始化成员变量。</strong></p></li><li><p><code>java</code>获得数组的长度使用<code>arr.length</code></p><p>在Java中，数组有一个属性 length，用于表示数组的长度。在本题中，数组 arr 的长度为 10，可以使用 <code>arr.length</code> 来获得数组的长度。注意，这里的 length 不是方法，而是成员变量，因此无需使用括号表示。</p></li><li><p><code>string.concat()</code> 将两个字符串连在一起，返回新的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str1.concat(str2);<br>System.out.println(str3);<br></code></pre></td></tr></table></figure></li><li><p>java什么时候传形参，什么时候传引用？</p><p>在Java中，所有基本类型（如 int、double、boolean 等）都是按值传递的，也就是说，在将基本类型作为参数传递给方法时，实际上传递的是该基本类型的值的副本。任何对这个副本的修改都不会影响到原始的基本类型变量。</p><p>而对于对象类型，Java传递的则是对象引用的副本。对象引用是一个存储在栈内存中的值，它指向堆内存中的一个对象。当将一个对象作为参数传递给方法时，实际上传递的是该对象引用的副本，也就是说，传递的是一个指向原始对象的副本。这种方式称为按引用传递。</p><p>虽然 Java 使用的是按值传递的机制，但因为对象引用传递的实现方式，使得在方法内部可以修改该对象的状态，例如通过调用对象的 setter 方法改变其属性值，或通过调用对象的方法改变其内部状态等。此时，由于传递的是对象的引用，方法内部的修改也会影响原始对象。</p><p>需要注意的是，在 Java 中不支持传递引用的方式，如果想要实现类似 C++ 中的传递引用，则需要使用 Java 的封装类型（例如 Integer、Double、Boolean 等）。这些类型都是对象类型，因此在传递这些类型的变量时，实际上是传递了对象引用的副本，因此也可以在方法内部修改其状态。</p></li><li><p><code>substring(1,5)</code></p><p>获取字符串中第1个元素到到5前一个元素</p></li><li><p>构造方法不能是静态的</p></li><li><p>使用<code>javac</code>将<code>java</code>文件编译成<code>.class</code>文件</p><p>使用<code>java</code> 运行文件</p></li><li><p><code>java</code>代码块</p><ul><li><p>静态代码块</p><p>只在类的加载时执行一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <span class="hljs-comment">//初始化static 变量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-comment">//每次类的加载都会执行</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>局部代码块</p><p>用于限定生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> func&#123;<br>    &#123;<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-comment">//限制num的生命周期</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步代码块</p><p>确保线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 同步方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步代码块，保证线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Math类</p><ol><li><code>abs()</code>：返回一个数的绝对值。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>ceil()</code>：返回大于或等于参数的最小整数，即向上取整。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>floor()</code>：返回小于或等于参数的最大整数，即向下取整。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>round()</code>：返回四舍五入后的最接近的整数。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>max()</code>：返回两个值中较大的那个。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>min()</code>：返回两个值中较小的那个。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>pow(double a, double b)</code>：返回a的b次幂。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>sqrt()</code>：返回一个数的平方根。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li><li><code>sin()</code>：返回一个角度的正弦值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/sin">2</a>]</li><li><code>cos()</code>：返回一个角度的余弦值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/cos">2</a>]</li><li><code>tan()</code>：返回一个角度的正切值。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/tan">2</a>]</li><li><code>asin()</code>：返回一个数值的反正弦值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/asin">2</a>]</li><li><code>acos()</code>：返回一个数值的反余弦值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/acos">2</a>]</li><li><code>atan()</code>：返回一个数值的反正切值（单位为弧度）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/atan">2</a>]</li><li><code>exp()</code>：返回 <code>Math.E</code>（自然对数的底数）的指数。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/exp">2</a>]</li><li><code>log()</code>：返回一个数的自然对数（以e为底数）。[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/log">2</a>]</li><li><code>random()</code>：返回一个随机数，范围为0到1。[<a href="https://www.w3schools.com/java/ref_math.asp">1</a>]</li></ol></li><li><p><code>java</code>使用代码块对static变量进行赋值和直接赋值的区别？</p></li><li><p>执行时机</p></li></ol><p>   直接给static变量赋值时，赋值操作会在类加载时执行，也就是说，当 JVM 加载该类时，就会把static变量的初始值存储到内存中。</p><p>   而代码块则需要等到该类被实例化时才会执行。也就是说，当该类被使用时，代码块中的语句才会执行，从而给static变量赋值。</p><ol start="2"><li>赋值方式</li></ol><p>   直接给static变量赋值是一种简单的方式，它可以直接在变量后跟一个等号，然后紧接着赋值的表达式。</p><p>   而代码块提供了更多灵活的赋值方式，我们可以在代码块中编写任意复杂的逻辑来计算出static变量的值，更加符合面向对象的设计思想。</p><p>   综合来看，我们可以根据具体的场景选择不同的方式对static变量进行赋值。如果我们需要简单地给变量赋一个常量值，那么可以直接使用赋值操作；如果我们需要进行一些特殊的计算，或者需要依赖其他变量的值来计算static变量的值，那么可以使用代码块来进行赋值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AB9[模板]链表</title>
    <link href="/2023/04/11/AB9-%E6%A8%A1%E6%9D%BF-%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/04/11/AB9-%E6%A8%A1%E6%9D%BF-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/97dc1ac2311046618fd19960041e3c6f?tpId=308&tqId=2372688&ru=/exam/company&qru=/ta/algorithm-start/question-ranking&sourceUrl=/exam/company">【模板】链表_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/AB9%5B%E6%A8%A1%E6%9D%BF%5D%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x&#123;<span class="hljs-number">0</span>&#125;,y&#123;<span class="hljs-number">0</span>&#125;,num&#123;<span class="hljs-number">0</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list;<br>    std::string str&#123;&#125;;<br>    std::cin&gt;&gt;num;<br>    <span class="hljs-keyword">auto</span> item=list.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(num--)&#123;<br>        std::cin&gt;&gt;str;<br><br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;insert&quot;</span>)&#123;<br>            std::cin&gt;&gt;x&gt;&gt;y;<br>            <span class="hljs-comment">//下面两行如果不存在将返回最后一个迭代器，也就是实现了如果不存在插入到最后一个</span><br>            <span class="hljs-keyword">auto</span> item1=std::<span class="hljs-built_in">find</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>(),x);<br>            list.<span class="hljs-built_in">insert</span>(item1,y);<br>          <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;delete&quot;</span>)&#123;<br>            std::cin&gt;&gt;y;<br>            <span class="hljs-keyword">auto</span> item1=std::<span class="hljs-built_in">find</span>(list.<span class="hljs-built_in">begin</span>(),list.<span class="hljs-built_in">end</span>(),y);<br>            <br>            <span class="hljs-comment">//下面的if-else 实现的是如果有重复的删除一个</span><br>            <span class="hljs-comment">//如果使用remove(value)将会删除所有的与value相同的</span><br>            <span class="hljs-keyword">if</span>(item1!=list.<span class="hljs-built_in">end</span>()) &#123;<br>                <br>                list.<span class="hljs-built_in">erase</span>(item1);<span class="hljs-comment">//参数必须是迭代器</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <br>                list.<span class="hljs-built_in">remove</span>(y);<span class="hljs-comment">//不能是迭代器</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">empty</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item1: list)&#123;<br>            std::cout&lt;&lt;item1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><ul><li><p><code>int x&#123;0&#125;,y&#123;0&#125;,num&#123;0&#125;</code></p><p>这只是一种初始化方式</p></li><li><p><code>list</code>是一个双向的链表</p><ul><li><p><code>insert()</code></p><p>插入元素，有两个参数，有4个重载函数</p><p>但是第一个元素只能是迭代器</p></li><li><p><code>erase()</code></p><p>删除迭代器的元素</p></li><li><p><code>remove(value)</code></p><p>删除所有的与<code>value</code>相等的节点</p></li></ul></li><li><p><code>find()</code></p><p>返回迭代器，如何存在法返回该元素的迭代器，不存在返回最后一个迭代器</p></li></ul></li><li><p>理解</p><p>因为<code>list</code>封装了双向链表，所以直接拿来用</p><p>但是使用<code>find</code>可以查找有没有元素</p></li><li><p>问题</p><ul><li><p>c++封装的链表调用起来会不会时间复杂度很大？</p><blockquote><p>一般情况下，C++ STL 的 <code>list</code> 库的效率要优于手写的链表。这是因为 std::list 不仅实现了常见的操作，例如在任意位置插入&#x2F;删除元素、遍历&#x2F;查找列表、反转&#x2F;排序列表等等，而且还通常采用指针来实现，比手写链表更加高效。</p><p>另外，在 STL 的 list 中，封装程序员带来的好处是程序员不需要设计和编写具体的数据结构，也无需理解底层实现细节。所有 STL 集合类都已经实现了大量的算法和数据结构以及相应的纠错代码，因此能够保证高效、稳定和安全。</p><p>当然，对于一些特殊情况和特定应用场景，手写链表可能会比 C++ STL 的 list 更有效率。但这需要根据具体的实际情况来进行评估和验证。</p><p>总之，在大多数情况下，使用 C++ STL 的 <code>list</code> 库更方便、更高效、更容易维护和调试。</p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective</title>
    <link href="/2023/04/11/Effective/"/>
    <url>/2023/04/11/Effective/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="改程序和设计程序的55个具体做法"><a href="#改程序和设计程序的55个具体做法" class="headerlink" title="改程序和设计程序的55个具体做法"></a>改程序和设计程序的55个具体做法</h1><h3 id="条款-04"><a href="#条款-04" class="headerlink" title="条款 04"></a>条款 04</h3><p><strong>确保对象在使用中之前被初始化</strong></p><ol><li>使用初始化列表<ul><li>最好初始化列表与变量声明一一对应，也就是说与变量的声明顺序一致</li></ul></li></ol><h2 id="构造-x2F-析构-x2F-赋值"><a href="#构造-x2F-析构-x2F-赋值" class="headerlink" title="构造&#x2F;析构&#x2F;赋值"></a>构造&#x2F;析构&#x2F;赋值</h2><h3 id="条款-05"><a href="#条款-05" class="headerlink" title="条款  05"></a>条款  05</h3><p><strong>了解c++默默写了哪些函数</strong></p><ol><li>构造函数，拷贝构造函数，析构函数</li></ol><h3 id="条款-06"><a href="#条款-06" class="headerlink" title="条款  06"></a>条款  06</h3><p><strong>若不想使用编译器自动生成的函数，就该明确拒绝</strong></p><ol><li>为驳回编译器自动提供的机能，可以将相对应的函数声明为<code>private</code>并且不实现</li></ol><h3 id="条款-07"><a href="#条款-07" class="headerlink" title="条款  07"></a>条款  07</h3><p><strong>为多态基类声明<code>virtual</code>析构函数</strong></p><ol><li><code>vitrual</code>的基类一定要有一个虚析构函数</li><li>普通的类不应该使用<code>vitrual</code>（不当作base class或者不使用多态）</li></ol><h3 id="条款-08"><a href="#条款-08" class="headerlink" title="条款 08"></a>条款 08</h3><ol><li><p>不建议在析构函数里面使用捕获异常的代码</p><p><code>try</code> <code>catch</code></p></li><li><p>最好不要让析构函数吐出异常，如果吐出异常应该吞下（不提供处理）</p></li><li><p>如果需要处理此问题，应该提供一个普通函数，处理异常</p></li></ol><h3 id="条款-09"><a href="#条款-09" class="headerlink" title="条款 09"></a>条款 09</h3><p><strong>绝不在构造和析构函数里调用<code>virtual</code></strong></p><ol><li>因为父类的构造函数会比基类的更早运行，如果在构造函数里面调用，调用的是父类的函数</li><li>使用静态函数得到信息返回给父类的构造函数</li></ol><h3 id="条款-10"><a href="#条款-10" class="headerlink" title="条款 10"></a>条款 10</h3><p><strong>operator&#x3D;返回自身引用</strong></p><ol><li>令赋值操作返回的是引用的<code>* this</code></li></ol><h3 id="条款-11"><a href="#条款-11" class="headerlink" title="条款 11"></a>条款 11</h3><p><strong>operator&#x3D; 返回自身</strong></p><p><img src="https://effective-1317182407.cos.ap-nanjing.myqcloud.com/%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%3D.png?q-sign-algorithm=sha1&q-ak=AKIDIJnjtxFUCUqaAowDd-ITYULKypVpUES8sWaey3CQp_ns0CHbvrJmWzFH7Ie0DF15&q-sign-time=1681708749;1681712349&q-key-time=1681708749;1681712349&q-header-list=host&q-url-param-list=&q-signature=850ff8e56d95557c23e52e7cd8e59cc8b3657fc5&x-cos-security-token=E3kqUWLeRKkjezyhiWfLZ7axiiwNH9Tad224e4c6048773c82221d35a9a1db952rpP9gCmN9161-sBNWtpK5XZaZHZdg15x_XM5S_2jOf5JUwjFrF8zV7IGduKcH7SUzz46nh7zI0md7utqtPCeO_iFzVKsamTI2c7d1GyRCqlY8et0n73-7XFsO6Mj_JAVn7E5fe4cCscuCmQ4210uDc_u41j5y1gdbBfahmBnZ39nZk8VgmVJolGYUSLx7JpD"></p><ol><li><p>解决对于自己赋值自己的情况</p><p>在经行操作的时候判断，是否是自己，如果是的话就直接返回</p></li><li><p>如果不考虑自己赋值自己的情况</p><p>应该使用临时变量保存原来的地址，如果<code>new</code>失败了，指向的地址也不会出错</p></li></ol><h3 id="条款-12"><a href="#条款-12" class="headerlink" title="条款 12"></a>条款 12</h3><p><strong>operator&#x3D; 赋值对象时勿忘每一个成分</strong></p><ol><li>在使用复制构造函数或者移动构造函数时，我们需要调用父类的构造函数</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款-13"><a href="#条款-13" class="headerlink" title="条款 13"></a>条款 13</h3><ol><li><code>auto_ptr</code>使用有big,所以选择c++11的智能指针</li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Effective</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++随记</title>
    <link href="/2023/04/11/%E5%B9%B3%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/11/%E5%B9%B3%E5%B8%B8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="平常笔记"><a href="#平常笔记" class="headerlink" title="平常笔记"></a>平常笔记</h1><ol><li><p>初始化数组需要定义大小才能被<code>cin</code></p></li><li><p><code>cin</code>和<code>scanf</code>一样，都跳过空格</p></li><li><p><code>public</code>和<code>private</code>:用于类的封装</p></li><li><p><code>new </code>和 <code>malloc</code>的主要区别:<code>new</code>调用构造函数，<code>malloc</code>不会</p></li><li><p>int *<code>p1</code> &#x3D; new int[10]，int *<code>p2</code> &#x3D; new int[10]()区别：<code>p1</code>申请的空间里的值是随机值，<code>p2</code>申请的空间里的值已经初始化</p></li><li><p>引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b=a;<br><span class="hljs-type">int</span> c=<span class="hljs-number">20</span>;<br>b=c;<span class="hljs-comment">//这个意思就是说，将c的值赋值给a,因为b是啊的别名</span><br></code></pre></td></tr></table></figure><p>本质为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> b = &amp;a;<span class="hljs-comment">//所以在引用后，不能改变空间</span><br>*b = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<br>*b = c;<br></code></pre></td></tr></table></figure></li><li><p>左值，右值：（但凡能去地址，就是一个左值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x++;<span class="hljs-comment">//把x的值取出来，放进临时变量里面，再让临时变量++，此时x的值是临时变量的是，也就是右值</span><br>++x;<span class="hljs-comment">//自增，然后把自己返回，也就是说是左值</span><br></code></pre></td></tr></table></figure><ul><li><p>左值经过函数返回会变成右值，因为会发生拷贝</p></li><li><p>函数里，定义的参数，是个左值</p></li><li><p>用引用写交换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tem =b;<br>    b=a;<br>    a=tem;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>int &amp;a:左值引用</p></li><li><p>int &amp;&amp;a:右值引用</p></li></ul></li><li><p>对输出小数的控制</p><ul><li>不引入头文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> e=<span class="hljs-number">1</span>;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">4</span>);<br>    cout&lt;&lt;fixed&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    cout&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//将输出4位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>引入头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> e=<span class="hljs-number">1</span>;<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;e/<span class="hljs-number">3</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//输出4位小数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>string.at(n)</code>:用于获取指定字符，n就是获取字符的下标</p></li><li><p>使用new,创建的指针p,用法和数组一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *q=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        p[i]=i;<span class="hljs-comment">//可以相当于创建了一个数组，对于数组的存储可以用arr[i]=int类型</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        q[i]=p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>打印16进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;hex&lt;&lt;<span class="hljs-string">&quot;类容&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//可用于打印地址</span><br></code></pre></td></tr></table></figure></li><li><p><code>public</code>成员最好不要在类中赋值,而是使用成员初始化列表</p></li><li><p>在使用继承释放内存时，注意父类使用虚析构</p></li><li><p>构造函数的技巧：在声明的时候参数缺省</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_class</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">My_class</span>(<span class="hljs-type">double</span> num1=<span class="hljs-number">0.0</span>,<span class="hljs-type">double</span> num2=<span class="hljs-number">0.0</span>);<br>    ~<span class="hljs-built_in">My_class</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> m_num1;<br>    <span class="hljs-type">double</span> m_num2;<br><br>&#125;;<br><br><span class="hljs-comment">//构造</span><br>My_class::<span class="hljs-built_in">My_class</span>(<span class="hljs-type">double</span> num1,<span class="hljs-type">double</span> num2) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;My_class::My_class() &quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在声明的时候对参数缺省，在定义的时候不需要（会报错）</p><p><img src="C:\Users\12414\Desktop\笔记\c++\平常笔记.assets\image-20221210113213961.png" alt="image-20221210113213961"></p></li><li><p>引用做函数返回值</p><ul><li><p>不要将局部变量作为返回值</p></li><li><p>函数的返回值可以作为左值存在</p></li><li><p>如果函数的返回值，是左值必须是引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int a=10;//这么写会报错</span><br>    <span class="hljs-type">static</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>&amp; a = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在c++里面，有时候打印不一定需要，<code>string</code>类,特可以用字符指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_1,<span class="hljs-keyword">typename</span> Type_2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Cout</span><span class="hljs-params">(Type_1 a=<span class="hljs-number">0</span>,Type_2 b=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Cout</span>&lt;<span class="hljs-type">char</span>*,string&gt;(<span class="hljs-string">&quot;char*&quot;</span>,<span class="hljs-string">&quot;string&quot;</span>);<br><span class="hljs-comment">/*    cout&lt;&lt;add&lt;int,int&gt;(a,b)&lt;&lt;endl;</span><br><span class="hljs-comment">    cout&lt;&lt;add&lt;int&gt;(a,b)&lt;&lt;endl;</span><br><span class="hljs-comment">    cout&lt;&lt;add&lt;&gt;(a,b)&lt;&lt;endl;*/</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20221211212205234.png" alt="image-20221211212205234"></p></li><li><p>c++中读取字符串的函数</p><ul><li><p><code>getline()</code>     <code>string类</code></p><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\学\笔记\c++\平常笔记.assets\平常笔记.assets\image-20221227225137590.png" alt="image-20221227225137590"></p></li><li><p><code>cin.getline()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">cin</span>.getline(str, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-comment">//cin.getline()里面三个参数，第一个是要储存的字符串数组，第二个是最大长度 + 1，最后一个位置用来存储&#x27;\0&#x27;，也就是说你填20，但是只能存前19个字符，第三个是结束符，可省略，默认是换行符</span><br></code></pre></td></tr></table></figure><p>当第二个参数大于数组本身的长度时，只会读取数组这么长</p></li></ul></li><li><p>使用指针遍历时，不能使用数组名，必须重新创建一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>&#125;,*P=arr;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;arr[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">6</span>;i&gt;<span class="hljs-number">0</span>;--i)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;*P++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字符串的输入</p><ul><li><p>string类</p><p>使用<code>getline(cin,string名称)</code></p></li><li><p>字符数组类</p><p>使用<code>cin.getline(str,sizeof(str))</code>;</p></li></ul></li><li><p>c++的强制类型转换方式</p><p>使用<code>static_cast&lt;强制传换成的类型&gt;(被转变量名)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a =<span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> b=<span class="hljs-number">3</span>;<br>b=<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;a;<br></code></pre></td></tr></table></figure></li><li><p><code>using</code>的三个用处</p><ul><li><p>引入命名空间</p></li><li><p>指定别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ModuleType = ClassOne;<br></code></pre></td></tr></table></figure></li><li><p>在子类中引入基类的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ClassType::ModuleType;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>noexcept</code>关键字的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadEntry</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>default</code>是c++11的标准，它的作用是告诉编译器声明一个无参的默认构造函数</p><ul><li>与手动写的无参构造有什么区别<ul><li>多文件的编程中，使用<code>default</code>声明的不需要再写实现</li><li>代码执行的效率很高</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">test</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-built_in">test</span>(<span class="hljs-type">int</span> a)&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>explict</code>这个关键字的作用是用于修饰只有一个参数的构造函数，并要求为显示的，也就是防止用户做可能会发生隐式转换的事情，会报错</p></li><li><p><code>noexcept</code>这是c++11增加的函数，目的是为了提升函数效率，即告诉编译器这个函数不会产生异常。</p></li><li><p><code>=delete</code>表示不能被调用</p></li><li><p><code>decltype </code></p><p><code>auto</code>根据<code>=</code>右边的初始值 <code>value</code> 推导出变量的类型，而 <code>decltype</code> 根据 <code>exp</code> 表达式推导出变量的类型，跟<code>=</code>右边的 <code>value</code> 没有关系。</p></li><li><p><code>lambda</code>表达式</p><p>[见这个](<a href="https://tsy244.github.io/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/">lambda高级使用 - chg (tsy244.github.io)</a>)</p></li><li><p>c++ 父类构造函数声明<code>vitual</code>的作用</p><p>在C++中，当我们派生一个子类时，子类的构造函数会默认调用父类的构造函数以初始化父类的成员变量。而在某些情况下，我们希望能够在父类的构造函数中调用子类重写的虚函数，此时就需要在父类的构造函数声明为<code>virtual</code>。</p><p>具体来说，当父类的构造函数声明为<code>virtual</code>时，如果我们通过子类的指针或引用调用这个构造函数，那么实际被调用的将是子类的构造函数，而不是父类的构造函数。这样可以保证在父类中调用子类的虚函数时，已经完成了子类对象的初始化，避免出现未定义行为的情况。</p><p>需要注意的是，对于同一对象，构造函数的调用顺序是按照继承层次由上至下的，也就是从基类到派生类。因此，在子类的构造函数中，父类的构造函数已经执行完毕，可以调用虚函数，无需再将父类的构造函数声明为<code>virtual</code>。</p></li><li><p>c++父类里使用<code>vitual</code>的函数子类还会继承嘛？</p><p>在 C++ 中，如果一个父类声明了一个虚函数，那么子类继承这个虚函数并且在子类中可以进行重写（override）。当然，如果子类不想重写这个虚函数，也可以直接继承父类中的实现。</p><p>需要注意的是，在父类的构造函数中调用虚函数时，子类的版本不会被调用。这是因为在子类的构造函数执行之前，父类的构造函数已经执行完毕了，此时子类还没有初始化完成。如果在父类的构造函数中调用子类的函数，就有可能出现未定义行为的情况，因此编译器会强制执行父类版本的虚函数。</p><p>总之，如果一个虚函数在父类中已经声明，子类无论是否重写它，在概念上都是继承了这个虚函数，即子类对象拥有这个虚函数的 vtable（虚函数表） 和 vptr（虚指针），可以通过指针或引用来使用这个虚函数。</p></li><li><p>在使用多态的时候应该将父类的析构函数声明<code>vitrual</code></p></li><li><p>在使用<code>virtual</code>的时候体积的增大，是因为携带了很多信息，如虚函数表，虚指针</p></li><li><p>纯虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">testFunc</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>含有纯虚函数的class不能声明的对象，只能被派生</p></li><li><p>在初始化列表中调用父类的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> fat &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">son</span>();<br><br>    ~<span class="hljs-built_in">son</span>();<br>&#125;;<br><br><span class="hljs-comment">//构造</span><br>son::<span class="hljs-built_in">son</span>(): <span class="hljs-built_in">fat</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son::son()&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>move()</code>的使用</p><p>于在不进行复制或赋值操作的情况下将对象的所有权从一个对象转移到另一个对象。通过使用move，可以避免对资源进行复制和销毁的昂贵开销，从而提高代码效率。</p><p>在构造函数中可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fat::<span class="hljs-built_in">fat</span>(std::string str):<span class="hljs-built_in">str</span>(std::<span class="hljs-built_in">move</span>(str)) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name::name()&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>final</code>关键字的使用</p><ul><li>在类上面的使用</li></ul><p>  类的声明中使用final关键字，可以指示该类不能被继承</p><ul><li><p>在虚函数上面的使用</p><p>在虚函数的声明中使用final关键字，可以阻止子类对该虚函数进行覆盖</p></li></ul><p>需要注意的是，final关键字只能用于类或虚函数的声明中，而不能用于变量、函数或其它类型的声明中。</p></li><li><p><code>const</code>和<code>constexpr</code></p><ul><li><p><code>const</code> 只是将变量标记为“只读”，并非编译期常量，而 <code>constexpr</code> 则需要在编译时求值，生成编译期常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> constInt=<span class="hljs-number">10</span>;<span class="hljs-comment">//只读</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> constNum=<span class="hljs-number">10</span>;<span class="hljs-comment">//编译期常量</span><br></code></pre></td></tr></table></figure></li><li><p>被声明为 <code>constexpr</code> 的变量或函数，必须要满足编译器的常量表达式要求，可以在编译时进行求值。</p></li><li><p><code>constexpr</code> 变量应该使用特定的类型，如整数类型、枚举类型以及一些简单的浮点类型。</p></li><li><p><code>constexpr</code> 函数具有与普通函数类似的语法，但是其参数和返回值类型也必须是可求值的。在调用 <code>constexpr</code> 函数时，所有参数必须是编译期常量。</p></li></ul></li><li><p><code>const</code>修饰函数</p><p>在C++中，<code>const</code> 关键字可以作用于成员函数、非成员函数、指针和引用等对象上。如果将 <code>const</code> 应用于成员函数，则该函数被视为只读函数（read-only function），即在该函数内不能修改成员变量的值，也不能调用非<code> const</code> 成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fat::test</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p><code>constexpr</code>修饰函数</p><ol><li>函数必须是类的一部分；</li><li>函数有返回类型，而且返回类型必须为字面值类型；</li><li>函数体中只能包含诸如 <code>return</code>、<code>static_assert</code> 和 <code>typedef</code> 等语句，不能有分支语句（例如 <code>if</code>、<code>while</code>）和循环语句（例如 <code>for</code>、<code>do-while</code>）；</li><li>函数的参数列表中只能有字面值类型、引用和指针，而且参数都必须是 <code>constexpr</code> 的；</li><li>将函数声明为 <code>constexpr</code> 时，函数体内的所有函数调用都必须是 <code>constexpr</code> 的，这也意味着被调用的函数必须是 <code>constexpr</code> 的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">fat::test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>void(*)(int,int)</code>和<code>void(int,int)</code>区别</p><p>一个是函数指针，一个是函数</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++随记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective</title>
    <link href="/2023/04/11/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/04/11/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230315194353315.png" alt="image-20230315194353315"></p><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> tem;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myClass</span>()&#123;<br>        tem=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">myClass</span>(<span class="hljs-type">int</span> a):<span class="hljs-built_in">tem</span>(a)&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::shared_ptr的初始化</span><br>    <span class="hljs-comment">//第一种使用以下方法</span><br>    <span class="hljs-type">int</span> *pInt=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(pInt,[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;delete[] pInt1&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.1</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">sharedPtr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>)</span></span>;<br>    *sharedPtr1=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;*sharedPtr1= &quot;</span>&lt;&lt;*sharedPtr1&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr1.use_count():&quot;</span>&lt;&lt;sharedPtr1.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.2</span><br>    <span class="hljs-type">int</span> intSize=<span class="hljs-number">0</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;intSize:&quot;</span>;<br>    std::cin&gt;&gt;intSize;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[intSize],[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;this lambda&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2.use_count():&quot;</span>&lt;&lt;sharedPtr2.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<span class="hljs-comment">//输出1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intSize; ++i) &#123;<br>        sharedPtr2[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intSize; ++i) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2:&quot;</span>&lt;&lt;sharedPtr2[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.3  //无参构造</span><br>    std::shared_ptr&lt;<span class="hljs-type">char</span>&gt; sharedPtr3;<span class="hljs-comment">//无参构造1</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr3.use_count():&quot;</span>&lt;&lt;sharedPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <span class="hljs-comment">//1.4 //直接负值</span><br>    sharedPtr3=sharedPtr1;<br><br>    <span class="hljs-comment">//第二种通过拷贝构造和移动构造</span><br>    <span class="hljs-comment">//2.1 //通过move</span><br>    sharedPtr3= std::<span class="hljs-built_in">move</span>(sharedPtr1);<span class="hljs-comment">//通过move实现资源的转移</span><br><br>    <span class="hljs-comment">//第三种 通过make_shared</span><br>    <span class="hljs-comment">//3.1</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * explain: use a fundamental type</span><br><span class="hljs-comment">     */</span><br>    std::shared_ptr&lt;<span class="hljs-type">int</span> &gt; sharedPtr4=std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);<span class="hljs-comment">//520是对该堆内存的初始化</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr4:&quot;</span>&lt;&lt;*sharedPtr4&lt;&lt;std::endl;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * explain: use a class</span><br><span class="hljs-comment">     */</span><br><br>    std::shared_ptr&lt;myClass&gt; sharedPtr5= std::<span class="hljs-built_in">make_shared</span>&lt;myClass&gt;(<span class="hljs-number">1314</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    sharedPtr5= std::<span class="hljs-built_in">make_shared</span>&lt;myClass&gt;(<span class="hljs-number">244</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5.use_count():&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//第四种 //reseet()</span><br>    <span class="hljs-comment">//reset的两个功能：1.接触该内存的控制  2.接触该内存的控制，并控制其他的内存</span><br>    <span class="hljs-comment">//4.1 接触控制</span><br>    sharedPtr5.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    sharedPtr2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//注意此处，reset的地址应该和原来管理的一样</span><br>    sharedPtr5.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> myClass&#123;<span class="hljs-number">8989</span>&#125;);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5.use_count():&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">use_count</span>()&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr5:&quot;</span>&lt;&lt;sharedPtr5.<span class="hljs-built_in">get</span>()-&gt;tem&lt;&lt; std::endl;<span class="hljs-comment">//get返回普通变量的指针</span><br><br>    <span class="hljs-comment">//操作智能指针</span><br>    <span class="hljs-comment">//删除器函数</span><br>    <span class="hljs-comment">//lambda</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,[](<span class="hljs-type">int</span>* pInt1)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;this is deleting sharedPtr6&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt1;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr6:&quot;</span>&lt;&lt;*sharedPtr6.<span class="hljs-built_in">get</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*(sharedPtr6.<span class="hljs-built_in">get</span>()+<span class="hljs-number">1</span>)&lt;&lt;std::endl;<br>    <span class="hljs-comment">//c++自带的</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sharedPtr7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125;,std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        std::cout&lt;&lt;*(sharedPtr7.<span class="hljs-built_in">get</span>()+i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="unique-ptrc"><a href="#unique-ptrc" class="headerlink" title="unique_ptrc"></a>unique_ptrc</h2><h3 id="操作实例-1"><a href="#操作实例-1" class="headerlink" title="操作实例"></a>操作实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//一，初始化</span><br>    <span class="hljs-comment">//1.1 使用构造函数</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">uniquePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">25</span>&#125;)</span></span>;<br>    std::cout&lt;&lt;*uniquePtr&lt;&lt;std::endl;<br>    *uniquePtr.<span class="hljs-built_in">get</span>()=<span class="hljs-number">100</span>;<br>    std::cout&lt;&lt;*uniquePtr&lt;&lt;std::endl;<br>    std::cout&lt;&lt;uniquePtr.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    <span class="hljs-comment">//1.2 使用移动构造</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uniquePtr1= std::<span class="hljs-built_in">move</span>(uniquePtr);<br>    std::cout&lt;&lt;*uniquePtr1&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//1.3 使用reset</span><br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr1.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> &#123;<span class="hljs-number">959</span>&#125;);<br>    std::cout&lt;&lt;uniquePtr1.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br>    uniquePtr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>&#125;);<br>    std::cout&lt;&lt;uniquePtr.<span class="hljs-built_in">get</span>()&lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//unique_ptr 删除器</span><br>    <span class="hljs-comment">//函数指针实例  lambda在没有捕获的时候，可以看成函数指针</span><br>    <span class="hljs-comment">/*using funcPtr=void(*)(int*);*/</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[],<span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>&gt; <span class="hljs-title">uniquePtr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,[](<span class="hljs-type">int</span> * pInt)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout&lt;&lt;<span class="hljs-string">&quot;delete uniquePtr2&quot;</span>&lt;&lt;std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">delete</span>[] pInt;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    uniquePtr2[<span class="hljs-number">0</span>]=<span class="hljs-number">244</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[0]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">0</span>]&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[1]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br><br>    <span class="hljs-comment">//仿函数实例 lambda在有捕获的时候，只能看成函数仿函数</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>,std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt; <span class="hljs-built_in">uniquePtr3</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">244</span>&#125;,[&amp;uniquePtr2](<span class="hljs-type">int</span>* pInt)&#123;<br>        uniquePtr2[<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;delete uniquePtr3&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">delete</span> pInt;<br>    &#125;);<br>    uniquePtr3.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;uniquePtr2[1]:&quot;</span>&lt;&lt;uniquePtr2[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br><br><br>    <span class="hljs-comment">//std::unique_ptr 类型可以对数组指针自动管理 不需要想shared的那样的指定删除器函数</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ol><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//weak_ptr的初始化</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">233</span>&#125;)</span></span>;<br>    <span class="hljs-comment">//无参构造</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr;<br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weakPtr1</span><span class="hljs-params">(weakPtr)</span></span>;<br>    <span class="hljs-comment">//通过shared_ptr</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weakPtr2</span><span class="hljs-params">(sharedPtr)</span></span>;<br>    <span class="hljs-comment">//使用=</span><br>     std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr3;<br>     weakPtr3=weakPtr2;<br>     std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr3.use_count:&quot;</span>&lt;&lt;weakPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>     <br>     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>expired</code> 判断所指的对象是否析构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">244</span>&#125;)</span></span>;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">weakPtr</span>(sharedPtr);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.use_count():&quot;</span>&lt;&lt;weakPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.expired():&quot;</span>&lt;&lt;(weakPtr.<span class="hljs-built_in">expired</span>()?<span class="hljs-string">&quot;is&quot;</span>:<span class="hljs-string">&quot;not&quot;</span>)&lt;&lt; std::endl;<br><br>    sharedPtr.<span class="hljs-built_in">reset</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.use_count():&quot;</span>&lt;&lt;weakPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;weakPtr.expired():&quot;</span>&lt;&lt;(weakPtr.<span class="hljs-built_in">expired</span>()?<span class="hljs-string">&quot;is&quot;</span>:<span class="hljs-string">&quot;not&quot;</span>)&lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>不能使用同一个堆内存初始化智能指针</p><p>![image-20230319185006853](C:\Users\12414\OneDrive - cuit.edu.cn\桌面\智能指针.assets\image-20230319185006853.png)</p><p>但是可以使用”&#x3D;” 进行赋值操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test* test=<span class="hljs-keyword">new</span> Test;<br>std::shared_ptr&lt;Test&gt;<span class="hljs-built_in">sharedPtr</span>(test);<br>std::shared_ptr sharedPtr1=sharedPtr;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>std::shared_ptr&lt;Test&gt; sharedPtr2= std::<span class="hljs-built_in">move</span>(sharedPtr);<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr2.use_count():&quot;</span>&lt;&lt;sharedPtr2.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>std::shared_ptr&lt;Test&gt; sharedPtr3=sharedPtr;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr3.use_count():&quot;</span>&lt;&lt;sharedPtr3.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br><span class="hljs-comment">//此时sharedPtr已经move,所以结果为0</span><br></code></pre></td></tr></table></figure></li><li><p>对智能指针使用’.’操作的智能指针的api,如果使用’-&gt;’操作的是，对应的类的成员方法</p></li><li><p>正确的返回<code>this</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span>:<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test&gt;&#123;<br>    <span class="hljs-built_in">Test</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Test()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;~Test()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr.use_count():&quot;</span>&lt;&lt;sharedPtr.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    std::shared_ptr&lt;Test&gt; sharedPtr1=sharedPtr-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sharedPtr1.use_count():&quot;</span>&lt;&lt;sharedPtr1.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>共享智能指针不能循环引用</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转整个链表</title>
    <link href="/2023/04/10/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/04/10/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="!%5Bimage-20230410224210507%5D(C:%5CUsers%5C12414%5CDesktop%5Chexo%5Csource_posts%5C%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8.assets%5Cimage-20230410224210507.png)">题</a></p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">ReverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* pHead )</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>pHead;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">temp</span>=</span>cur-&gt;next;<br>        cur-&gt;next=pre;<br>        pre=cur;<br>        cur=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>理解</p><ul><li>让<code>temp</code>保存<code>cur-&gt;next</code>的地址</li><li><code>pre</code>第一次要为NULL</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表内指定区域反转</title>
    <link href="/2023/04/10/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F%E5%8F%8D%E8%BD%AC/"/>
    <url>/2023/04/10/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>[题](<a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295">链表内指定区间反转_牛客题霸_牛客网 (nowcoder.com)</a>)</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8%E9%A2%98.png"></p><ol><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param head ListNode类</span><br><span class="hljs-comment">     * @param m int整型</span><br><span class="hljs-comment">     * @param n int整型</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>         ListNode* temHead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//c++的创建方法，0是data域</span><br>        <span class="hljs-comment">//创建虚拟头节点</span><br>        <span class="hljs-comment">//操作头节点方便，比如如果反转第一个元素</span><br>         temHead-&gt;next=head;<br>        <br>        <br>         ListNode* pre=temHead;<br>         ListNode* cur=head;<br>        <span class="hljs-comment">//两个指针用于操作来链表</span><br>        <br>         ListNode* tem=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//用于存放cur-&gt;next</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            pre=pre-&gt;next;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//使节点移动</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n-m;++i) &#123;<br>            tem=cur-&gt;next;<br>            cur-&gt;next=tem-&gt;next;<br>            <span class="hljs-comment">//始终让cur-&gt;next指向的使next-&gt;xext;</span><br>            <br>            <br>            tem-&gt;next=pre-&gt;next;<br>            <span class="hljs-comment">//让反转的指针，指向pre-&gt;next实现反转</span><br>            <br>            pre-&gt;next=tem;<br>            <span class="hljs-comment">//再让pre指向tem保持连接</span><br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> temHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>提示</p><p><img src="https://newcode-1317182407.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8%E6%8F%90%E7%A4%BA.gif"></p></li><li><p>理解</p><ul><li>先遍历到反转区域</li><li>使用虚拟头节点</li></ul></li><li><p>问题</p><ul><li><p>为什么不用判断<code>cur-&gt;next-&gt;next</code>是不是越界？</p><blockquote><p>因为不会越界</p><p>如果使用的区域刚好是整个链表</p><p>那么当要反转最后一个节点的时候，也就是最后一次</p><p>cur-&gt;next-&gt;next&#x3D;<code>nullptr</code></p></blockquote></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>newcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/2023/04/05/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/04/05/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的基本"><a href="#树的基本" class="headerlink" title="树的基本"></a>树的基本</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p><ol><li><p>一个根和若干的子树</p></li><li><p>基本术语</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png"></p></li><li><p>树的类别</p><ul><li><p>有序树</p><p>子树有位置要求</p></li><li><p>无序树</p><p>子树无要求</p><p>意思是：1，2，3，这三颗子树，无论如何排列都是一个树</p></li></ul></li><li><p>森林</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97.png"></p></li><li><p>树和线性结构的比较</p><ul><li>树是一对多</li><li>线性结构是一对一</li></ul></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li><p>每个节点最多有两个度</p></li><li><p>二叉树是个有序树（但是不是树的特殊情况）</p></li><li><p>二叉树可以是一 个空集 </p></li><li><p>二叉树必须要分左子树还是右子树，即使只有一颗子树也要分（但是树可以不分，所以这就是二叉树不是树的原因）</p></li><li><p>二叉树的基本形态</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.png"></p></li><li><p>二叉树的抽象类型定义</p></li><li><p>二叉树的性质</p><ul><li><p>在二叉树的第<code>i</code>层最多有2^i-1^ 个节点，最少有一个</p></li><li><p>深度为<code>k</code>的二叉树最多有2^k^ -1个节点</p></li><li><p>对任何一颗二叉树T如果叶子树为n<del>0</del>&#x3D;n<del>2</del>+1</p></li></ul><p>  <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A83.png"></p><ul><li><p>B&#x3D;n-1</p><p>从下网上看，因为除了根节点每个节点都会产生一条边，所以<code>n-1</code>（除了根节点）个节点会产生<code>n-1</code>个边</p></li><li><p>n<del>2</del> *2 +n<del>1</del>*1</p><p>从上往下看，因为，每一个度为2的节点都会产生两条边，每一度为1的节点会产生一个边</p></li><li><p>满二叉树</p><ul><li>每一层都达到最大的节点数</li><li>叶子节点出现在最后一层</li></ul></li><li><p>完成二叉树</p><ul><li><p>二叉树中有编号的与满二叉树的标号对应</p></li><li><p>在满二叉树中去除立连续的节点，剩下的也是完全二叉树</p></li><li><p>满二叉树一定是完全二叉树</p></li><li><p>完全二叉树的性质</p><p>性质三</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png"></p><p>性质四</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png"></p></li></ul></li></ul></li><li><p>二叉树的存储结构  </p><ul><li>顺序结构</li><li>链式结构<ul><li>二叉链表</li><li>三叉链表</li></ul></li></ul></li><li><p>二叉树的链式存储的储存结构</p><p>二叉链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rChild</span>;</span><br>&#125;BiNode,*BiTree;<br></code></pre></td></tr></table></figure><p>三叉链表(多了一个指向双亲的指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">parent</span>,*<span class="hljs-title">rChild</span>;</span><br>&#125;BiNode,*BiTree;<br><br></code></pre></td></tr></table></figure><ul><li>在<code>n</code>个节点的二叉链表中，必有<code>2n</code>个链域，除了根节点没有双亲，所以一定会有<code>n-1</code>个节点的链域存放指针，指向非空的子女节点。</li></ul><p>  所以一共有<code>n+1</code>个空指针域</p></li><li><p>二叉树的遍历</p></li></ol><ul><li><p>先序遍历</p><p>先访问根节点，再访问左子树，再访问右子树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        visit(T);<br>        PreOrderTraverse(T-&gt;lChild);<br>        PreOrderTraverse(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>中序遍历</p><p>先访问左子树，再访问根节点，再访问右子树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PreOrderTraverse(T-&gt;lChild);<br>        visit(T);<br>        PreOrderTraverse(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>后续遍历</p><p>先访问左子树，在访问右子树，最后访问根节点   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br><br>status <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PreOrderTraverse(T-&gt;lChild);<br>        PreOrderTraverse(T-&gt;rChild);<br>        visit(T);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>例题：</p><p>使用二叉树表达算术表达式</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%8D%EF%BC%8C%E4%B8%AD%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.png"></p></li><li><p>递归遍历的算法分析</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.png" alt="img"></p><p>从虚线出发到每一个终点路径每个节点经历3次</p></li><li><p>非递归遍历</p><p>中序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stack&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TElemType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    std::stack&lt;BiTree&gt; stack;<span class="hljs-comment">//申请一个栈</span><br>    BiTree moveNode=T;<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()||moveNode!= <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(moveNode!= <span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(moveNode);<br>            moveNode=moveNode-&gt;lChild;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">auto</span> p=stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//得到栈首的元素</span><br>            std::cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            stack.<span class="hljs-built_in">pop</span>();<br>            moveNode=p-&gt;rChild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">status <span class="hljs-title">LeveIOrder</span><span class="hljs-params">(BiTree&amp; biTree)</span></span>&#123;<br>    std::queue&lt;BiTree&gt; queue;<br>    BiNode* pMove=biTree;<br>    queue.<span class="hljs-built_in">push</span>(biTree);<br>    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(queue.<span class="hljs-built_in">front</span>()-&gt;lChild!= <span class="hljs-literal">nullptr</span>)&#123;<br>            queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;lChild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(queue.<span class="hljs-built_in">front</span>()-&gt;rChild!= <span class="hljs-literal">nullptr</span>)&#123;<br>            queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;rChild);<br>        &#125;<br>        std::cout&lt;&lt;queue.<span class="hljs-built_in">front</span>()-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="11"><li><p>二叉树的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">CreatBitree</span><span class="hljs-params">(BiTree* biTree)</span>&#123;<br>    TElemType ch;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        (*biTree)=(BiNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiNode));<br>        (*biTree)-&gt;lChild=<span class="hljs-literal">NULL</span>;<br>        (*biTree)-&gt;rChild=<span class="hljs-literal">NULL</span>;<br>        (*biTree)-&gt;data=ch;<br>        CreatBitree(&amp;(*biTree)-&gt;lChild);<br>        CreatBitree(&amp;(*biTree)-&gt;rChild);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>定义：</p><p>‘#’代表没有节点</p></li></ul><p>所以上面代码的实现是，根据符号来确定是否要创建一个二叉树</p></li><li><p>二叉树的复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">Copy</span><span class="hljs-params">(BiTree T, BiTree *newBitree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;<br>        *newBitree = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiNode));<br>        (*newBitree)-&gt;lChild=<span class="hljs-literal">NULL</span>;<br>        (*newBitree)-&gt;rChild=<span class="hljs-literal">NULL</span>;<br>        (*newBitree)-&gt;data=T-&gt;data;<br>        Copy(T-&gt;lChild,&amp;(*newBitree)-&gt;lChild);<br>        Copy(T-&gt;rChild,&amp;(*newBitree)-&gt;rChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算二叉树的深度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Depen</span><span class="hljs-params">(BiTree biTree)</span>&#123;<br>    <span class="hljs-keyword">if</span>(biTree==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        m= Depen(biTree-&gt;lChild);<br>        n= Depen(biTree-&gt;rChild);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;m)&#123;<br>        <span class="hljs-keyword">return</span> (n+<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> m+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算二叉树的节点数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span><span class="hljs-params">(BiTree biTree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (biTree != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NodeCount(biTree-&gt;lChild)+ NodeCount(biTree-&gt;rChild)+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算叶子节点的个数（叶子节点是左右孩子都为<code>NULL</code>的节点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">DestroyBiTree</span><span class="hljs-params">(BiTree *biTree)</span> &#123;<br>    <span class="hljs-keyword">if</span> (*biTree == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*biTree)-&gt;lChild != <span class="hljs-literal">NULL</span>) &#123;<br>        DestroyBiTree(&amp;(*biTree)-&gt;lChild);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*biTree)-&gt;rChild != <span class="hljs-literal">NULL</span>) &#123;<br>        DestroyBiTree(&amp;(*biTree)-&gt;rChild);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  %c&quot;</span>, (*biTree)-&gt;data);<br>    <span class="hljs-built_in">free</span>((*biTree));<br>    (*biTree)==<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线索二叉树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png"></p><p> <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%A7%84%E5%88%99.png"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%A4%B4%E7%BB%93%E7%82%B9.png"></p></li></ol><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97.png"></p><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><p>其中A是虚拟的头节点</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span>&#123;</span><br>    TElemType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    PTNode nodes[BUFSIZ];<br>    <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//存放根节点和节点个数</span><br>&#125;PTree;<br></code></pre></td></tr></table></figure><h4 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png"></p><h4 id="带双亲的孩子链表"><a href="#带双亲的孩子链表" class="headerlink" title="带双亲的孩子链表"></a>带双亲的孩子链表</h4><p>只是在孩子链表的基础上多加了双亲的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png"></p><h4 id="孩子兄弟表示法（二叉树表示法，二叉链表表示法）"><a href="#孩子兄弟表示法（二叉树表示法，二叉链表表示法）" class="headerlink" title="孩子兄弟表示法（二叉树表示法，二叉链表表示法）"></a>孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E6%93%8D.png"></p><ul><li><p>将树转换为二叉树</p><p>兄弟相连留长子</p><p>意思是：将兄弟的连起来，只保留双亲与长子的连线</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B0%86%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%84%E5%BC%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%84%E5%BC%9F%E5%AD%98%E5%82%A8%E6%B3%95%EF%BC%89.png"></p></li><li><p>将兄弟二叉树，转变为普通的树</p><p>左孩子右右连双亲，去掉原来的右孩子线</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E6%A0%91.png"></p></li></ul><h3 id="森林和二叉树的转化"><a href="#森林和二叉树的转化" class="headerlink" title="森林和二叉树的转化"></a>森林和二叉树的转化</h3><ol><li><p>树变二叉树根相连</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E5%8F%98%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p></li><li><p>二叉树变森林</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E6%A3%AE%E6%9E%97.png"></p></li></ol><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ol><li><p>先根</p><p>如树不为空，那么先遍历根然后在遍历各个子树</p></li><li><p>后根</p><p>若树不为空，后根遍历各课子树，然后访问根节点</p></li></ol><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png"></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>和二叉树的遍历方式一致</p><ol><li><p>先序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png"></p></li><li><p>中序遍历</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p></li></ol><h2 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h2><h3 id="判断树"><a href="#判断树" class="headerlink" title="判断树"></a>判断树</h3><p>左边是改进的选择判断语句</p><p>右边是普通的选择判断语句</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%88%A4%E6%96%AD%E6%A0%91.png"></p><ol><li><p>基本概念</p><ul><li><p>路径</p><p>从一个结点到另一个结点的分支构成了结点间的路径</p></li><li><p>结点的路径长度</p><p>两结点间的路径上的分支数</p><p>A-&gt;D 的路径长度是  2</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A62.png"></p></li><li><p>树的路径长度</p><p>从根结点到每个结点的路径长度之和</p></li><li><p>权</p><p>将树中的结点赋一个有某种含义的数值，称为<strong>结点的权</strong></p></li><li><p>结点的带权路径长度</p><p>从根到该节点之间的路径长度×该节点权的结果</p></li><li><p>树的带权路径长度</p><p>树中所有的叶子结点的带权路径长度之和</p></li></ul></li></ol><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>最优树，也就是带权路径长度最短的树</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png"></p><ol><li>满二叉树不一定是最优二叉树</li></ol><p><strong>哈夫曼树的特点</strong></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9.png"></p><ul><li>只有度（子树个数 ）0为0或2的结点</li><li>一共有<code>2n-1</code>个结点，且新构成的结点都是度为二的结点，原来的结点都是度为一的结点</li><li>一共有n个叶子结点（原来的结点，也就是度为0的结点）</li></ul><h4 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h4><ol><li>权值越大的先构造（贪心算法）</li></ol><p>   步骤</p><ul><li>构造森林全是根</li><li>选用两小造新树</li><li>删除两小添新人</li><li>重复2，3剩单根</li></ul><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0.png"></p><p>   删除两小的意思是：删除原来队列里面的两个小的</p><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B.png"></p><p>   直到剩下一棵树，就是哈夫曼树</p><p>   下面是一个例题</p><p>   <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E4%BE%8B%E9%A2%98.png"></p><ol start="2"><li><p>代码实现</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png"></p><p>注意重置min的过程，可以改进算法，但是作者还没有学到遍历，所以并没有采取其他方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HTNode</span> &#123;</span><br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125; HTNode, *HuffmanTree;<br><span class="hljs-comment">//采用双亲表示法，但是会记录左右孩子的位置</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Select</span><span class="hljs-params">(HTNode *htNodes, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> *min1, <span class="hljs-type">int</span> *min2)</span> &#123;<br>    <span class="hljs-comment">//以下算法用于去出较次和最次的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((htNodes + i)-&gt;parent == <span class="hljs-number">0</span><br>            &amp;&amp; (htNodes + i)-&gt;weight &lt; (htNodes + *min1)-&gt;weight) &#123;<span class="hljs-comment">//确保每小权的结点已经被选用</span><br><br>            *min2 = *min1;<br>            *min1 = i;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((htNodes + i)-&gt;parent == <span class="hljs-number">0</span><br>                   &amp;&amp; (htNodes + i)-&gt;weight &lt; (htNodes + *min2)-&gt;weight<br>                   &amp;&amp; i != *min1) &#123;<br><br>            *min2 = i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initMin</span><span class="hljs-params">(HTNode* htNodes,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> *min1,<span class="hljs-type">int</span> *min2)</span>&#123;<br>    <span class="hljs-comment">//重置最小值，防止取出来的最小值是已经被选过的</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span>((htNodes+i)-&gt;parent==<span class="hljs-number">0</span>)&#123;<br>            *min1=i++;<span class="hljs-comment">//break使得++i失效</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;i&lt;size;++i)&#123;<br>        <span class="hljs-keyword">if</span>((htNodes+i)-&gt;parent==<span class="hljs-number">0</span>)&#123;<br>            *min2=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">creatNode</span><span class="hljs-params">(HTNode *htNodes, <span class="hljs-type">int</span> *nums, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min1 = <span class="hljs-number">0</span>, min2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> size1;<br>    size1 = size * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">for</span> (; i&lt;size; ++i) &#123;<br>        (htNodes + i)-&gt;weight = *(nums + i);<br>        (htNodes + i)-&gt;lch = <span class="hljs-number">0</span>;<br>        (htNodes + i)-&gt;rch = <span class="hljs-number">0</span>;<br>        (htNodes + i)-&gt;parent = <span class="hljs-number">0</span>;<span class="hljs-comment">//一定要将parent重置为0</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (; i &lt; size1 ; ++i) &#123;<br>        initMin(htNodes,i,&amp;min1,&amp;min2);<br>        Select(htNodes, i, &amp;min1, &amp;min2);<br>        (htNodes + i)-&gt;weight = (htNodes + min1)-&gt;weight + (htNodes + min2)-&gt;weight;<br>        (htNodes + i)-&gt;lch = min1;<br>        (htNodes + i)-&gt;rch = min2;<br>        (htNodes + i)-&gt;parent = <span class="hljs-number">0</span>;<br>        (htNodes + min1)-&gt;parent = i;<br>        (htNodes + min2)-&gt;parent = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> nums[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> tem;<br>    HTNode htNodes[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//注意这里使用变量，不使用指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<span class="hljs-comment">//num最大是5，因为，2n-1留一个0不用</span><br><span class="hljs-comment">/*    if(num&gt;5)&#123;</span><br><span class="hljs-comment">        printf(&quot;num too large&quot;);</span><br><span class="hljs-comment">        exit(-1);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tem);<br>        nums[i] = tem;<br>    &#125;<br>    creatNode(htNodes, nums, num);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*num<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,htNodes[i].weight);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h4 id="哈曼树的运用"><a href="#哈曼树的运用" class="headerlink" title="哈曼树的运用"></a>哈曼树的运用</h4><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><ol><li><p>设计一种任意的编码都不是另一个编码的前缀</p><p>如A(0)是B(00)的前缀</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"></p></li><li><p>通过哈夫曼编码使得电文最短</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E7%94%B5%E6%96%87%E7%9A%84%E6%9C%80%E7%9F%AD.png"></p><p>将要传输的字符出现的频率当作权值</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E7%94%B5%E6%96%87%E7%9A%84%E6%9C%80%E7%9F%AD.png"></p></li><li><p>问题</p><ul><li><p>为什么哈夫曼编码能确保不是前缀编码？</p><blockquote><p>因为每一个字符都是叶子结点，也就是说，没有哪个叶子是另个一个叶子的前缀，也就是没有相同的路径</p></blockquote></li><li><p>为什么哈夫曼树能确保字符编码总长最短？</p><blockquote><p>才用权的方式，权重大的离根节点更近，所以形成的编码最短。换句话说哈夫曼树的加权路径最短</p></blockquote></li></ul></li><li><p>性质</p><ul><li>哈夫曼编码是前缀码</li><li>而且是最有前缀码</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表</title>
    <link href="/2023/04/04/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2023/04/04/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h1><h2 id="串（字符串string）"><a href="#串（字符串string）" class="headerlink" title="串（字符串string）"></a>串（字符串string）</h2><ol><li><p>是一个内容受限的线性表（只能存放字符）</p></li><li><p>子串</p><p>例如<code>abcd</code>的的子串</p><p>“ ”  “a”  “ab”  ……..</p></li><li><p>子串在主串当中的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%AD%90%E4%B8%B2%E5%9C%A8%E4%B8%BB%E4%B8%B2%E7%9A%84%E4%BD%8D%E7%BD%AE.png"></p></li><li><p>所有的空串都是相等的 </p></li><li><p>一般选用顺序的</p></li></ol><h3 id="串的顺序实现"><a href="#串的顺序实现" class="headerlink" title="串的顺序实现"></a>串的顺序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SString</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[MAXSIZE];<br>    <span class="hljs-type">int</span> Length;<br>&#125;SString;<br></code></pre></td></tr></table></figure><h3 id="串的链式实现"><a href="#串的链式实现" class="headerlink" title="串的链式实现"></a>串的链式实现</h3><ol><li><p>优点</p><blockquote><p>操作方便</p></blockquote></li><li><p>缺点</p><blockquote><p>存储密度较低 </p></blockquote><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%B2%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9.png"></p></li><li><p>块链的是实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>* <span class="hljs-title">next</span>;</span><br>&#125;Chunk;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LString</span>&#123;</span><br>    Chunk *head,*tail;<br>    <span class="hljs-type">int</span> curlen;<br>&#125;LString;<br></code></pre></td></tr></table></figure></li></ol><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><ol><li><p>时间复杂度为<code>O(n*m)</code></p></li><li><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SString</span> &#123;</span><br>    <span class="hljs-type">char</span> ch[MAXSIZE];<br>    <span class="hljs-type">int</span> Length;<br>&#125; SString;<br><br>status <span class="hljs-title function_">InitString</span><span class="hljs-params">(SString *<span class="hljs-built_in">string</span>)</span> &#123;<br>    <span class="hljs-built_in">memset</span>(<span class="hljs-built_in">string</span>-&gt;ch, <span class="hljs-number">0</span>, MAXSIZE);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-built_in">string</span>-&gt;ch);<br>    <span class="hljs-built_in">string</span>-&gt;Length = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>-&gt;ch);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BFMatchingAlorithm</span><span class="hljs-params">(SString *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">string</span>-&gt;Length;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">string</span>-&gt;Length &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(str)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>-&gt;ch[i] == str[j]) &#123;<br>            ++i;<br>            ++j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i - j + <span class="hljs-number">1</span>;<br>            j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(str)) &#123;<br>        <span class="hljs-keyword">return</span> i - j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">/*    for (int i = 0,j=0; i &lt; len; ++i) &#123;</span><br><span class="hljs-comment">        if(string-&gt;ch[i]==str[j])&#123;</span><br><span class="hljs-comment">            while(j&lt; strlen(str)&amp;&amp;string-&gt;ch[i]!=&#x27;\0&#x27;)&#123;</span><br><span class="hljs-comment">                if(string-&gt;ch[i]!=str[j])&#123;</span><br><span class="hljs-comment">                    i=i-j+1;</span><br><span class="hljs-comment">                    j=0;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                i++;</span><br><span class="hljs-comment">                j++;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            if(j== strlen(str))&#123;</span><br><span class="hljs-comment">                return i-j;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return -1;*/</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    SString <span class="hljs-built_in">string</span>;<br>    <span class="hljs-type">int</span> sub = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">10</span>];<br>    InitString(&amp;<span class="hljs-built_in">string</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    sub = BFMatchingAlorithm(&amp;<span class="hljs-built_in">string</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sub);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>注意回溯的<code>i</code>的计算公式</li></ul></li></ol><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ol><li><p>计算<code>next</code>的值</p><ul><li>第一个元素<code>next</code>为<code>0</code></li><li>第二个元素<code>next</code>比较前面一个元素，就是<code>1</code></li><li>其他元素比较前缀的子串</li></ul><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/KMP%E7%AE%97%E6%B3%95%E7%9A%84next%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97.png"></p></li><li></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>定长的线性表</p></li><li><p>相同的元素</p></li><li></li><li><p>结构是固定</p></li><li><p>三维数组的存储</p><p>例如<code>arr[i][j][k]</code></p><ul><li><p><code>arr[x][y][z]</code></p><p>意思就是说，第<code>z</code>页的第<code>x,y</code>号元素</p><p>内存为<code>arr+z*x*y+x*y+y</code></p></li></ul></li><li><p>稀疏矩阵的存储</p><p>采用三元法(i,j,元素)</p><p>既是只存放有元素的位置</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E5%85%83%E7%BB%84%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p></li><li><p>三角矩阵</p><p>采用的是存一边的方法</p></li><li><p>对称矩阵</p><p>采用三角矩阵的存法</p></li></ol><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p><ol><li><p>每个元素可以不同</p></li><li><p>一般用大写的字母表示广义表，小写的字母表示表的元素</p></li><li><p>递归的广义表</p></li><li><p>广义表的深度</p><p>可以大概理解为，完整括号的个数</p></li><li><p>广义表的性质</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p></li><li><p>广义表的种类</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8.png"></p></li></ol><h2 id="案例分析与实现"><a href="#案例分析与实现" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h2><ol><li><p>病毒感染检测</p><ul><li><p>将病毒的遗传物质变成复制一份（考虑到病毒的遗传物质是环状的）</p></li><li><p>代码示例（病毒DNA是线状的）</p><p>使用BF</p><p>[代码](<a href="https://github.com/TSY244/cpp_test/commit/82838186490cbdfacb47899ecf70487a44ab4e53">病毒匹配bf · TSY244&#x2F;cpp_test@8283818 (github.com)</a>)</p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2023/03/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈定义和特点"><a href="#栈定义和特点" class="headerlink" title="栈定义和特点"></a>栈定义和特点</h2><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9.png"></p><ol><li>栈：先进后出</li><li>队列：先进先出（排队的问题）</li></ol><h3 id="顺序栈的表示和操作实现"><a href="#顺序栈的表示和操作实现" class="headerlink" title="顺序栈的表示和操作实现"></a>顺序栈的表示和操作实现</h3><ol><li>约定<code>an</code>端为栈顶，<code>a1</code>端为栈底</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li><p>初始化   制造一个空栈</p><p><code>InitStack(&amp;S)</code></p></li><li><p>销毁栈   </p><p><code>DestroyStack(&amp;S)</code></p></li><li><p>判断是否为空</p><p><code>StackEmpty(S)</code></p></li><li><p>求栈的长度</p><p><code>StackLength(S)</code></p></li><li><p>取栈顶的元素</p><p><code>GetTop(S,&amp;e)</code></p></li><li><p>栈的置空操作</p><p><code>ClearStack(&amp;S)</code></p></li><li><p>入栈操作</p><p><code>Push(&amp;S,e)</code></p></li><li><p>出栈操作</p><p><code>Pop(&amp;S,&amp;e)</code></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png"></p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol><li><p>两个指针，一个<code>top</code>指向的是真正的栈顶的上面一个指针，一个<code>base</code>指向的是栈底的地址</p></li><li><p>空栈的标志</p><p><code>top</code>和<code>base</code>都指向的是<code>0</code> </p></li><li><p>栈满的标志</p><p><code>top</code>-<code>base</code>&#x3D;&#x3D;<code>stacksize</code> </p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA.png"></p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    ElemType* base;<br>    ElemType* top;<br>    <span class="hljs-type">int</span> stackSize;<br>&#125;SqStack;<br><br>status <span class="hljs-title function_">destroyStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(sqStack-&gt;base);<br>    sqStack-&gt;stackSize=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">initStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    sqStack-&gt;base=(ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (ElemType)*MAXSIZE);<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    &#125;<br>    sqStack-&gt;top=sqStack-&gt;base;<br>    sqStack-&gt;stackSize=MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==sqStack.top)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">StackLength</span><span class="hljs-params">(SqStack sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sqStack.top-sqStack.base;<br>&#125;<br><br>status <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack sqStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack.base==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=*sqStack.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">ClearStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    sqStack-&gt;base=sqStack-&gt;top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* sqStack,ElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>||sqStack-&gt;top-sqStack-&gt;base==sqStack-&gt;stackSize)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *sqStack-&gt;top++=e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* sqStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sqStack-&gt;base==<span class="hljs-literal">NULL</span>|| sqStack-&gt;base==sqStack-&gt;top)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=*--sqStack-&gt;top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">CreatSqStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        Push(sqStack,i+<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">printfStack</span><span class="hljs-params">(SqStack* sqStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*sqStack-&gt;base==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> tem;<br>    <span class="hljs-keyword">while</span>(StackLength(*sqStack)&gt;<span class="hljs-number">0</span>)&#123;<br>        Pop(sqStack,&amp;tem);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, tem);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    SqStack sqStack;<br>    sqStack.base=<span class="hljs-literal">NULL</span>;<br>    initStack(&amp;sqStack);<br>    CreatSqStack(&amp;sqStack);<br>    printfStack(&amp;sqStack);<br>    destroyStack(&amp;sqStack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="栈链的表示和实现"><a href="#栈链的表示和实现" class="headerlink" title="栈链的表示和实现"></a>栈链的表示和实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>* <span class="hljs-title">next</span>;</span><br>&#125;StackNode,*LinkStack;<br><br><br>status <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-comment">//构造空栈</span><br>    *linkStack=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkStack linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>status <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack* linkStack,ElemType e)</span>&#123;<br>    StackNode* temNode=(StackNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(StackNode));<br>    temNode-&gt;data=e;<br>    <span class="hljs-comment">//如果是第一个元素，下面代码指向的NULL</span><br>    temNode-&gt;next=(*linkStack);<br>    (*linkStack)=temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">Pop</span><span class="hljs-params">(LinkStack* linkStack,ElemType* e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=(*linkStack)-&gt;data;<br>    (*linkStack)=(*linkStack)-&gt;next;<br><br>&#125;<br>status <span class="hljs-title function_">DestroyStack</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*linkStack==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    StackNode* deleteNode=(*linkStack);<br>    <span class="hljs-keyword">while</span>(deleteNode!=<span class="hljs-literal">NULL</span>)&#123;<br>        (*linkStack)=(*linkStack)-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode=<span class="hljs-literal">NULL</span>;<br>        deleteNode=(*linkStack);<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>ElemType <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LinkStack* linkStack)</span>&#123;<br>    <span class="hljs-keyword">if</span>((*linkStack)==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (*linkStack)-&gt;data;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    LinkStack linkStack=<span class="hljs-literal">NULL</span>;<br>    InitStack(&amp;linkStack);<br>    <span class="hljs-type">int</span> e1=<span class="hljs-number">244</span>,e2=<span class="hljs-number">0</span>;<br>    Push(&amp;linkStack,e1);<br>    Pop(&amp;linkStack,&amp;e2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,e2);<br>    Push(&amp;linkStack,<span class="hljs-number">24</span>);<br>    e1= GetTop(&amp;linkStack);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,e1);<br>    DestroyStack(&amp;linkStack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><ol><li><p>主调函数和被调函数</p><p>如：<code>main</code>函数就是主调函数，在里面调用的函数被称为被调函数</p></li><li><p>函数的嵌套调用的方式</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86.png"></p></li></ol><h2 id="队列的表示和操作原理"><a href="#队列的表示和操作原理" class="headerlink" title="队列的表示和操作原理"></a>队列的表示和操作原理</h2><ol><li>只能在表尾经行插入操作，在表头进行删除操作的线性表</li><li>先进先出的线性表</li><li>有顺序结构和链式结构（常用的是顺序结构）</li></ol><h3 id="队列的相关操作"><a href="#队列的相关操作" class="headerlink" title="队列的相关操作"></a>队列的相关操作</h3><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.png"></p><h3 id="队列的顺序表示和实现"><a href="#队列的顺序表示和实现" class="headerlink" title="队列的顺序表示和实现"></a>队列的顺序表示和实现</h3><p> <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.png"></p><ol><li><p>对空的表示</p><p><code>front</code>&#x3D;<code>rear</code>&#x3D;<code>0</code></p></li><li><p>队列的特殊情况</p><p><img src="C:\Users\12414\Desktop\hexo\source_posts\栈和队列.assets\image-20230402182219032.png"></p></li><li><p>假溢出和真溢出</p><ul><li><p>假溢出</p><p><code>rear</code>!&#x3D;<code>0</code></p><p><code>rear</code>&#x3D;<code>MAXQSIZE</code> 但是队列中还有空余的存储空间</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%81%87%E6%BA%A2%E5%87%BA.png"></p></li><li><p>真溢出</p><p><code>rear</code>&#x3D;<code>0</code></p><p><code>fear</code>&#x3D;<code>MAXQSIZE</code></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E7%9C%9F%E6%BA%A2%E5%87%BA.png"></p></li></ul></li><li><p>循环队列的处理逻辑</p><ul><li><p>使用<code>%</code>运算，将数组变成循环 </p></li><li><p>但是用循环队列的是时候，我们面对的是对空和对满是一种判断条件，所以我们使用标志经行判断</p><p>一下提出三种解决办法</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.png"></p></li></ul></li><li><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><span class="hljs-keyword">using</span> ElemType=<span class="hljs-type">int</span>;<br><span class="hljs-keyword">using</span> status=<span class="hljs-type">int</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ERROR=<span class="hljs-number">-1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXSIZE=<span class="hljs-number">10</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Que</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br>    ElemType* base;<br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">//地址更小的指针</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">//地址更大的指针</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Que</span>();<br>    ~<span class="hljs-built_in">Que</span>();<br>    <span class="hljs-function">status <span class="hljs-title">ClearQueue</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(ElemType&amp; e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(ElemType e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(ElemType &amp;e)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>类的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>Que::<span class="hljs-built_in">Que</span>() &#123;<br>    base= <span class="hljs-literal">nullptr</span>;<br>    base=<span class="hljs-keyword">new</span> ElemType [MAXSIZE];<br>    <span class="hljs-keyword">if</span>(base== <span class="hljs-literal">nullptr</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;base new ERROR&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    front=<span class="hljs-number">0</span>;<br>    rear=<span class="hljs-number">0</span>;<br>&#125;<br><br>Que::~<span class="hljs-built_in">Que</span>() &#123;<br>    <span class="hljs-keyword">delete</span>[] base;<br>    front=<span class="hljs-number">0</span>;<br>    rear=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Que::status Que::ClearQueue() &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    return 0;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">//这个算法需要想清楚</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Que::QueueLength</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (rear-front+MAXSIZE)%MAXSIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::GetHead</span><span class="hljs-params">(ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(rear==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e=*(base+front);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::EnQueue</span><span class="hljs-params">(ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>((rear+<span class="hljs-number">1</span>)%MAXSIZE==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *(base+rear)=e;<br>    rear=(rear+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Que::DeQueue</span><span class="hljs-params">(ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(rear==front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e=*(base+front);<br>    front=(front+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myClass.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatQ</span><span class="hljs-params">(Que &amp;que)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXSIZE; ++i) &#123;<br>        que.<span class="hljs-built_in">EnQueue</span>(i + <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(Que &amp;que)</span> </span>&#123;<br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">GetHead</span>(e)) &#123;<br>        std::cout &lt;&lt;<span class="hljs-string">&quot;Get: &quot;</span>&lt;&lt; e &lt;&lt; std::endl;<br>        que.<span class="hljs-built_in">DeQueue</span>(e);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;delete: &quot;</span>&lt;&lt;e&lt;&lt;std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Que queue;<br>    ElemType elemType = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> e;<br>    queue.<span class="hljs-built_in">EnQueue</span>(<span class="hljs-number">244</span>);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">QueueLength</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">GetHead</span>(e) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; e &lt;&lt; std::endl;<br>    <span class="hljs-built_in">creatQ</span>(queue);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">QueueLength</span>() &lt;&lt; std::endl;<br>    <span class="hljs-built_in">printQueue</span>(queue);<br>    std::cout &lt;&lt; queue.<span class="hljs-built_in">DeQueue</span>(elemType) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="队列链式实现"><a href="#队列链式实现" class="headerlink" title="队列链式实现"></a>队列链式实现</h3><ol><li><p>节点的实现</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%98%9F%E5%88%97%E9%93%BE%E5%BC%8F%E7%9A%84%E8%8A%82%E7%82%B9.png"></p></li><li><p>基本定义</p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89.png"></p></li><li><p>代码实例（注意win上面竟然过不了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW (-1)</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkQueue</span> &#123;</span><br>    QueuePtr rear;<br>    QueuePtr front;<br>&#125; LinkQueue, *LinkQNode;<br><br>status <span class="hljs-title function_">InitNode</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    QueuePtr queuePtr = (QNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    queuePtr-&gt;next = <span class="hljs-literal">NULL</span>;<br>    queuePtr-&gt;data = <span class="hljs-number">0</span>;<br>    (*linkQueue)-&gt;front = queuePtr;<br>    (*linkQueue)-&gt;rear = queuePtr;<br>&#125;<br><br>status <span class="hljs-title function_">DestroyNode</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    <span class="hljs-keyword">if</span> (*linkQueue == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    QNode *deleteNode = (*linkQueue)-&gt;front;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (deleteNode != <span class="hljs-literal">NULL</span>) &#123;<br>        (*linkQueue)-&gt;front = (*linkQueue)-&gt;front-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>        deleteNode = (*linkQueue)-&gt;front;<br>        num++;<br>    &#125;<br>    (*linkQueue)-&gt;rear = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">free</span>(*linkQueue);<br>    (*linkQueue)=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">CreatLinkQueue</span><span class="hljs-params">(LinkQNode *linkQueue)</span> &#123;<br>    (*linkQueue) = (LinkQueue *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkQueue));<br>    <span class="hljs-keyword">if</span> ((*linkQueue) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    (*linkQueue)-&gt;front = <span class="hljs-literal">NULL</span>;<br>    (*linkQueue)-&gt;rear = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">GetHead</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType *e)</span> &#123;<br>    *e = (*linkQNode)-&gt;front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType e)</span> &#123;<br>    QNode *qNode = (QNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (qNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    qNode-&gt;data = e;<br>    qNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ((*linkQNode)-&gt;front == (*linkQNode)-&gt;rear) &#123;<br>        (*linkQNode)-&gt;front-&gt;next = qNode;<br>    &#125;<br>    (*linkQNode)-&gt;rear-&gt;next = qNode;<br>    (*linkQNode)-&gt;rear = qNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQNode *linkQNode, ElemType *e)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((*linkQNode) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    QNode *qNode;<br>    *e = (*linkQNode)-&gt;front-&gt;next-&gt;data;<br>    qNode = (*linkQNode)-&gt;front-&gt;next;<br>    (*linkQNode)-&gt;front-&gt;next = (*linkQNode)-&gt;front-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(qNode);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    LinkQNode linkQNode;<br>    ElemType e;<br>    CreatLinkQueue(&amp;linkQNode);<br>    InitNode(&amp;linkQNode);<br>    EnQueue(&amp;linkQNode, <span class="hljs-number">1</span>);<br>    EnQueue(&amp;linkQNode, <span class="hljs-number">244</span>);<br>    GetHead(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    DeQueue(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    GetHead(&amp;linkQNode, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e);<br>    DestroyNode(&amp;linkQNode);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2023/03/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/03/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322151152567.png" alt="image-20230322151152567"></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322151451180.png" alt="image-20230322151451180"></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ol><li><p>使用big O计数法</p></li><li><p>实例</p><ul><li><p>O(1)  常量级的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<br>a=b;<br>a=c;<br>b=c;<br><span class="hljs-comment">//就算重复1000000+都是一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>O(n)   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    <span class="hljs-comment">//代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>O(logN) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>    i*=<span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322182248288.png" alt="image-20230322182248288" style="zoom:50%;" /></li><li><p>O(NM)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ol><li><p>实例</p><ul><li><p>O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>O(n)  new 一个维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    newArray[i]=i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>O(n*n)  new 二个维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> [][] newArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n][n];<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="线性表（案例分析）"><a href="#线性表（案例分析）" class="headerlink" title="线性表（案例分析）"></a>线性表（案例分析）</h3><ol><li><p>线性表具有同一种特性的数据元素的一个有限的序列</p><p>![image-20230322183519529](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322183519529.png)</p></li><li><p>注意</p><ul><li>下标由1开始</li></ul></li><li><p>基本代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX =<span class="hljs-number">100</span>;<br><span class="hljs-comment">//顺序结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&#123;<br>    ELETMENT List[MAX];<br>    <span class="hljs-type">int</span> listLenth;<br>&#125;List;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322155844508.png" alt="image-20230322155844508"></p><p><img src="C:\Users\12414\AppData\Roaming\Typora\typora-user-images\image-20230322155956690.png" alt="image-20230322155956690"></p></li><li><p>缺点</p><ul><li>存储空间分配不灵活</li><li>空间复杂度高</li></ul></li></ol><h3 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h3><ol><li>线性表的操作<ul><li><p>线性表的初始化（<code>IniList</code>）![image-20230322191953037](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191953037.png)</p></li><li><p>线性表的销毁（<code>DestroyList</code>）</p><p>连本身都没有了</p><p>![image-20230322192004208](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192004208.png)</p></li><li><p>线性表的清楚（<code>ClearList</code>）</p><p>还存在，但是是一个空表</p><p>![image-20230322192014702](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192014702.png)</p></li><li><p>判断线性表是否为空（<code>ListEmpty</code>）</p><p>![image-20230322192029109](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192029109.png)</p></li><li><p>求线性表的长度（<code>ListLength</code>）</p><p>![image-20230322192050448](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192050448.png)</p></li><li><p>获取元素(<code>GetElem</code>)</p><p>![image-20230322190529314](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190529314.png)</p></li><li><p>查找元素（<code>LocateElem</code>）</p><p>![image-20230322190615757](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190615757.png)</p></li><li><p>求一个元素的前驱（<code>PrioElem</code>）</p><p>![image-20230322190742641](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190742641.png)</p></li><li><p>获得一个元素的后继（<code>NextElem</code>）</p><p>![image-20230322190833997](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322190833997.png)</p></li><li><p>插入一个元素（<code>ListInsert</code>）</p><p>![image-20230322191334889](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191334889.png)</p></li><li><p>删除一个元素（<code>ListDelete</code>）</p><p>![image-20230322191749620](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191749620.png)</p></li><li><p>遍历线性表（<code>LIstTraverse</code>）</p><p>![image-20230322191844657](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322191844657.png)</p></li></ul></li></ol><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><ol><li><p>定义：把逻辑上相邻的数据元素存储在物理相邻的存储单元</p><p>![image-20230322192505711](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230322192505711.png)</p></li></ol><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><ol><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">//基本模板</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define  SIZE 100</span><br><span class="hljs-comment">typedef struct&#123;</span><br><span class="hljs-comment">    ElemType elem[SIZE];</span><br><span class="hljs-comment">    int length;</span><br><span class="hljs-comment">&#125;SqList;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//int 型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> intElem[SIZE];<br>    <span class="hljs-type">int</span> length;<br>&#125;intList;<br><br><span class="hljs-comment">//int double</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> intElem;<br>    <span class="hljs-type">double</span> doubleElem;<br>&#125;Polynomial;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    Polynomial * PPolynomial;<br>    <span class="hljs-type">int</span> length;<br>&#125;PolynomialList;<br><br><br><span class="hljs-comment">//struct</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">char</span>* author;<br>    <span class="hljs-type">float</span> price;<br>    <span class="hljs-type">int</span> num;<br>&#125;Book;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    Book* pBook;<br>    <span class="hljs-type">int</span> length;<br>&#125;BookList;<br><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="类C语言相关操作"><a href="#类C语言相关操作" class="headerlink" title="类C语言相关操作"></a>类C语言相关操作</h3><ol><li><p><code>ElemType</code> 元素</p></li><li><p>C语言动态内存分配</p></li></ol><ul><li><p><code>malloc</code>: 开辟连续的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">intList *pIntList=(intList*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> (intList)*SIZE);<br><span class="hljs-built_in">free</span>(pIntList);<br></code></pre></td></tr></table></figure></li></ul><h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><p>![image-20230323091558306](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230323091558306.png)</p><ol><li><p>代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125; IntList;<br><br><span class="hljs-function">status <span class="hljs-title">initList_Sq</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">destroyList</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">clearList</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">getListLength</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">getElem</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> i, ElemType *e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">isEmpty</span><span class="hljs-params">(IntList *list)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">locateElem</span><span class="hljs-params">(IntList *list, ElemType e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">listInsert</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType e)</span></span>;<br><br><span class="hljs-function">status <span class="hljs-title">listDelete</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType *e)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ElemType *e;<br>    IntList *list = (IntList *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(IntList));<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">initList_Sq</span>(list) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(ERROR);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        list-&gt;elem[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        list-&gt;length++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, list-&gt;elem[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">clearList</span>(list);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s\n&quot;</span>, <span class="hljs-built_in">isEmpty</span>(list) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        list-&gt;elem[i] = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        list-&gt;length++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, <span class="hljs-built_in">getListLength</span>(list));<br>    <span class="hljs-built_in">getElem</span>(list, <span class="hljs-number">4</span>, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c\n&quot;</span>, *e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">locateElem</span>(list, <span class="hljs-string">&#x27;d&#x27;</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">locateElem</span>(list, <span class="hljs-string">&#x27;D&#x27;</span>));<br>    <span class="hljs-built_in">listInsert</span>(list, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;5&#x27;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, list-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">listDelete</span>(list,<span class="hljs-number">5</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>,*e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,list-&gt;elem);<br><br>    <span class="hljs-built_in">listDelete</span>(list,<span class="hljs-number">26</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c\n&quot;</span>,*e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,list-&gt;elem);<br><br>    <span class="hljs-built_in">destroyList</span>(list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//删除</span><br><span class="hljs-function">status <span class="hljs-title">listDelete</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType *e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span> || s &gt; list-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e=list-&gt;elem[s<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s - <span class="hljs-number">1</span>; i &lt; list-&gt;length - <span class="hljs-number">1</span>; ++i) &#123;<br>        list-&gt;elem[i] = list-&gt;elem[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    list-&gt;elem[--list-&gt;length] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function">status <span class="hljs-title">listInsert</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> s, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s &gt; SIZE || s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list-&gt;length - <span class="hljs-number">1</span>; i &gt;= s - <span class="hljs-number">1</span>; --i) &#123;<br>        list-&gt;elem[i + <span class="hljs-number">1</span>] = list-&gt;elem[i];<br>    &#125;<br>    list-&gt;elem[s - <span class="hljs-number">1</span>] = e;<br>    list-&gt;length++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序查找空间复杂度为  O(n)</span><br><span class="hljs-function">status <span class="hljs-title">locateElem</span><span class="hljs-params">(IntList *list, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list-&gt;length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e == list-&gt;elem[i]) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">getElem</span><span class="hljs-params">(IntList *list, <span class="hljs-type">int</span> i, ElemType *e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; list-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    *e = list-&gt;elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">getListLength</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!list) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list-&gt;length;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">isEmpty</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">clearList</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(list-&gt;elem, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(list-&gt;elem));<br>    list-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">destroyList</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list) <span class="hljs-built_in">free</span>(list);<br>    <span class="hljs-keyword">if</span> (!list) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">initList_Sq</span><span class="hljs-params">(IntList *list)</span> </span>&#123;<br>    list-&gt;elem = (ElemType *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * SIZE);<br>    <span class="hljs-keyword">if</span> (!list) <span class="hljs-keyword">return</span> ERROR;<br>    list-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="线性表的链式储存"><a href="#线性表的链式储存" class="headerlink" title="线性表的链式储存"></a>线性表的链式储存</h3><ol><li><p>指针的组成：数据域和指针域（指向下一个）</p></li><li><p>链表的类型</p><ul><li><p>单链表：</p><p>只有一个指针域的链表</p></li><li><p>双链表：</p><p>有两个指针域的链表</p></li><li><p>循环链表：</p><p>首尾相连的链表</p></li></ul></li><li><p>空表的判断：</p><blockquote><p>看一下头指针的是否为NULL,如果为NULL则是空链表</p></blockquote></li><li><p>设置头节点的好处：</p><blockquote><ol><li>便于首元节点的处理</li><li>处理空表和非空表就一样了</li></ol></blockquote><p>![image-20230324170004103](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230324170004103.png)</p></li><li><p>存取元素的方法叫做顺序存取法</p><p>![image-20230324170213582](C:\Users\12414\OneDrive - cuit.edu.cn\学\笔记\数据结构和算法\数据结构和算法.assets\image-20230324170213582.png)</p><p>顺序表是随机存取 </p></li><li><p>链表的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><span class="hljs-comment">//使用node表示节点</span><br><span class="hljs-comment">//使用linkList表示链表的</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">clearList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">listLength</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElemSub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> e)</span>;<br><br>status <span class="hljs-title function_">getElemBySub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sub, ElemType *e)</span>;<br><br>node *<span class="hljs-title function_">getElemPoint</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> e)</span>;<br><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub, ElemType e)</span>;<br><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList charListHead = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> e;<br>    <span class="hljs-type">int</span> sub;<br>    <span class="hljs-comment">//创建头节点</span><br>    charListHead = (linkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    charListHead-&gt;next = <span class="hljs-literal">NULL</span>;<br>    charListHead-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-comment">//初始化链表</span><br>    initList(charListHead);<br><br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s&quot;</span>, isEmpty(charListHead) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    <span class="hljs-comment">//清空链表</span><br>    clearList(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%s\n&quot;</span>, isEmpty(charListHead) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><br>    initList(charListHead);<br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, listLength(charListHead));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;e&#x27;</span>));<br><br>    getElemBySub(charListHead, <span class="hljs-number">5</span>, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c&quot;</span>, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%p&quot;</span>, getElemPoint(charListHead, <span class="hljs-string">&#x27;e&#x27;</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, insertNode(charListHead, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;a&#x27;</span>));<br>    getElemBySub(charListHead, <span class="hljs-number">2</span>, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%c&quot;</span>, e);<br><br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, listLength(charListHead));<br>    printfNode(charListHead);<br><br>    sub = <span class="hljs-number">28</span>;<br>    deleteNode(charListHead, sub);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    printfNode(charListHead);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, getElemSub(charListHead, <span class="hljs-string">&#x27;Z&#x27;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//删除</span><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span> &#123;<br>    node *moveNode = headNode;<br>    node* temNode=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;sub&amp;&amp;moveNode-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        moveNode=moveNode-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;=sub||moveNode==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    temNode=moveNode-&gt;next;<br>    moveNode-&gt;next=moveNode-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(temNode);<br>    <span class="hljs-keyword">return</span> OK;<br><br>&#125;<br><br><span class="hljs-comment">//插入元素</span><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub, ElemType e)</span> &#123;<br>    node *moveNode = headNode;<br>    node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    temNode-&gt;date = e;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &gt;= listLength(headNode)) &#123;<br>        <span class="hljs-built_in">free</span>(temNode);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> tem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tem != sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    temNode-&gt;next = moveNode-&gt;next;<br>    moveNode-&gt;next = temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//取出元素返回地址</span><br>node *<span class="hljs-title function_">getElemPoint</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> ElemType e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span> &amp;&amp; moveNode-&gt;date != e) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> moveNode;<br>&#125;<br><br><br><span class="hljs-comment">//通过下标取出元素</span><br>status <span class="hljs-title function_">getElemBySub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sub, ElemType *e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-type">int</span> tem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tem != sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>        tem++;<br>    &#125;<br>    *e = moveNode-&gt;date;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//取出元素通过下标</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElemSub</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">const</span> ElemType e)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-type">int</span> sub = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (moveNode &amp;&amp; moveNode-&gt;date != e) &#123;<br>        moveNode = moveNode-&gt;next;<br>        sub++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (moveNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> sub;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//求链表的长度</span><br>status <span class="hljs-title function_">listLength</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        i++;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<span class="hljs-number">-1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//清空链表</span><br>status <span class="hljs-title function_">clearList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = <span class="hljs-literal">NULL</span>;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next = <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    headNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//判断是否为空</span><br>status <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *nextNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        nextNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        nextNode-&gt;date = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        moveNode-&gt;next = nextNode;<br>        moveNode = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>链表操作的时间和空间复杂度</p><ul><li><p>查找  O(n)</p></li><li><p>插入和删除 O(1)</p><p>理由是，插入和删除都是在一瞬间发生的事，不包括前面的查找</p><p>所以在查找的时间复杂度为 O(n);</p></li></ul></li><li><p>链表初始化的方式</p><ul><li><p>头插法</p><p>意思是每次都是从头节点后面一位插入数据</p><p>这个是反循序的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node* temNode=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        <span class="hljs-keyword">if</span>(temNode==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        temNode-&gt;date=<span class="hljs-string">&#x27;a&#x27;</span>+i;<br>        temNode-&gt;next=headNode-&gt;next;<br>        headNode-&gt;next=temNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>尾插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//初始化</span><br>status <span class="hljs-title function_">initList2</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *nextNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        nextNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        nextNode-&gt;date = <span class="hljs-string">&#x27;A&#x27;</span> + i;<br>        moveNode-&gt;next = nextNode;<br>        moveNode = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>问题代码</p><ul><li>为什么将头节点放进函数<code>malloc</code>,在main函数中，头节点却是空？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode = <span class="hljs-literal">NULL</span>;<br>    initList(headNode);<br>    printfNode(headNode);<br>    destroyList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    headNode = (linkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    headNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    headNode-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;date = <span class="hljs-string">&#x27;a&#x27;</span> + i;<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        moveNode-&gt;next = temNode;<br>        moveNode = temNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><p>C语言的传参本质上都是传值，也就是拷贝传参，普通变量拷贝的普通的值，指针变量拷贝的是指针</p><p>具体参考：<a href="%5B(21%E6%9D%A1%E6%B6%88%E6%81%AF">深入理解C语言函数传参方式</a> 深入理解C语言函数传参方式_c 为什么是一个一个传参的_amcomputer的博客-CSDN博客](<a href="https://blog.csdn.net/qq_39463175/article/details/115566613">https://blog.csdn.net/qq_39463175/article/details/115566613</a>))</p><p>所以修改后的代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span>;<br><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span>;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode = <span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode);<br>    printfNode(headNode);<br>    destroyList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList* headNode)</span> &#123;<br>    (*headNode)=(linkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span>((*headNode)==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    (*headNode)-&gt;next=<span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;date=<span class="hljs-string">&#x27;0&#x27;</span>;<br>    node* moveNode=(*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node* temNode=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>        temNode-&gt;date=<span class="hljs-string">&#x27;A&#x27;</span>+i;<br>        moveNode-&gt;next=temNode;<br>        moveNode=moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//打印</span><br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (headNode-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除，包括头节点</span><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode;<br>    node *deleteNode;<br>    moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        num++;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    headNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ol><li><p>最后一个节点指向首节点</p></li><li><p>因为没有最后一个节点为空，所以我们在遍历的时候，我们需要判断等不等于头节点</p></li><li><p>使用尾指针更加的方便（更快的操作末节点，头节点和<code>a1</code>）</p></li><li><p>简单的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType date;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *circularLinkList;<br><br>circularLinkList <span class="hljs-title function_">initList</span><span class="hljs-params">(circularLinkList *headNode)</span>;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(circularLinkList headNode)</span>;<br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(circularLinkList headNode)</span>;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(circularLinkList tailNode1, circularLinkList tailNode2)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    circularLinkList headNode1 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList headNode2 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList tailNode1 = <span class="hljs-literal">NULL</span>;<br>    circularLinkList tailNode2 = <span class="hljs-literal">NULL</span>;<br>    tailNode1 = initList(&amp;headNode1);<br>    tailNode2 = initList(&amp;headNode2);<br>    printfList(headNode1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    combineList(tailNode1,tailNode2);<br>    printfList(headNode1);<br>    destroyList(headNode1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//将链表2接在链表一的后面，且保留链表一的头节点</span><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(circularLinkList tailNode1, circularLinkList tailNode2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tailNode1 == <span class="hljs-literal">NULL</span> || tailNode1 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = tailNode1-&gt;next;<br>    tailNode1-&gt;next = tailNode2-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(tailNode2-&gt;next);<br>    tailNode2-&gt;next=<span class="hljs-literal">NULL</span>;<br>    tailNode2-&gt;next = temNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(circularLinkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;date);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(circularLinkList headNode)</span> &#123;<br>    node *moveNode = headNode-&gt;next;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(headNode);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>circularLinkList <span class="hljs-title function_">initList</span><span class="hljs-params">(circularLinkList *headNode)</span> &#123;<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;date = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    getchar();<br>    node *moveNode = (*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;date = a + i;<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        moveNode-&gt;next = temNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next = (*headNode);<br>    <span class="hljs-keyword">return</span> moveNode;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ol><li><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prior</span>;</span><br>&#125; node, *linkList;<br><br><br>status <span class="hljs-title function_">insertNode</span><span class="hljs-params">(linkList headNode, ElemType data, <span class="hljs-type">int</span> sub)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    temNode-&gt;data = data;<br>    node *moveNode = headNode;<br>    <span class="hljs-keyword">while</span> (--sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next-&gt;prior = temNode;<br>    temNode-&gt;next = moveNode-&gt;next;<br>    temNode-&gt;prior = moveNode;<br>    moveNode-&gt;next = moveNode-&gt;next-&gt;prior;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLinkLength</span><span class="hljs-params">(linkList headNode)</span>&#123;<br>    <span class="hljs-keyword">if</span>(headNode==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    node* moveNode=headNode-&gt;next;<br>    <span class="hljs-keyword">while</span>(moveNode!=headNode)&#123;<br>        moveNode=moveNode-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br>status <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(linkList headNode, <span class="hljs-type">int</span> sub)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || sub &lt; <span class="hljs-number">1</span>||sub%getLinkLength(headNode)==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;deleteNode ERROR\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (--sub) &#123;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next-&gt;prior = moveNode-&gt;prior;<br>    moveNode-&gt;prior-&gt;next = moveNode-&gt;next;<br>    <span class="hljs-built_in">free</span>(moveNode);<br>    moveNode=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">insertLink</span><span class="hljs-params">(linkList headNode, linkList insertHeadNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || insertHeadNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *temNode = headNode;<br>    headNode-&gt;prior-&gt;next = insertHeadNode-&gt;next;<br>    insertHeadNode-&gt;next-&gt;prior = headNode-&gt;prior;<br>    headNode-&gt;prior = insertHeadNode-&gt;prior;<br>    headNode-&gt;prior-&gt;next = headNode;<br>    <span class="hljs-built_in">free</span>(insertHeadNode);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">destroyLink</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    node *deleteNode = moveNode;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        deleteNode = <span class="hljs-literal">NULL</span>;<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num);<br>    headNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">initLinkList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span> ((*headNode) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-type">char</span> a;<br>    (*headNode)-&gt;data = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*headNode)-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    node *moveNode = (*headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    getchar();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;data = a + i;<br>        moveNode-&gt;next = temNode;<br>        moveNode-&gt;next-&gt;prior = moveNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    moveNode-&gt;next = (*headNode);<br>    moveNode-&gt;next-&gt;prior = moveNode;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">printNodeACW</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;prior;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;data);<br>        moveNode = moveNode-&gt;prior;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">printNodeCW</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != headNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c &quot;</span>, moveNode-&gt;data);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode;<br>    linkList headNode2;<br>    initLinkList(&amp;headNode);<br>    initLinkList(&amp;headNode2);<br>    printNodeCW(headNode);<br>    printNodeACW(headNode);<br><br>    insertLink(headNode, headNode2);<br>    printNodeCW(headNode);<br><br>    insertNode(headNode, <span class="hljs-string">&#x27;&amp;&#x27;</span>, <span class="hljs-number">54</span>);<br>    printNodeCW(headNode);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, getLinkLength(headNode));<br><br>    deleteNode(headNode,<span class="hljs-number">55</span>);<br>    printNodeCW(headNode);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>, getLinkLength(headNode));<br><br>    destroyLink(headNode);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="不同链表的比较"><a href="#不同链表的比较" class="headerlink" title="不同链表的比较"></a>不同链表的比较</h3><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E7%A7%8D%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="多种链表的比较"></p><p><img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%82%B9.png" alt="链式存储的优点"></p><p>  <img src="https://chg-1317182407.cos.ap-chengdu.myqcloud.com/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png"></p></li></ol><h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><ol><li><p>有序表的合并</p><ul><li><p>线性表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">printfList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; headNode-&gt;length; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, headNode-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;length = num;<br>    (*headNode)-&gt;elem = (ElemType *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType) * num);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(*headNode)-&gt;elem[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(linkList *headNode1, linkList headNode2)</span> &#123;<br>    <span class="hljs-type">int</span> subLa = <span class="hljs-number">0</span>, subLb = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l1 = (*headNode1)-&gt;length, l2 = headNode2-&gt;length;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    ElemType *temC = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (l1 + l2));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; subLa &lt; l1 &amp;&amp; subLb &lt; l2; ++i) &#123;<br>        temC[i] = (*headNode1)-&gt;elem[subLa] &lt; headNode2-&gt;elem[subLb] ? (*headNode1)-&gt;elem[subLa++]<br>                                                                     : headNode2-&gt;elem[subLb++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; l1 + l2) &#123;<br>        *(temC + i) = subLb &lt; l2 ? (headNode2)-&gt;elem[subLb++] : (*headNode1)-&gt;elem[subLa++];<br>        i++;<br>    &#125;<br>    (*headNode1)-&gt;elem = temC;<br>    (*headNode1)-&gt;length = l1 + l2;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br>status <span class="hljs-title function_">destroyLink</span><span class="hljs-params">(linkList pDel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pDel == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(pDel-&gt;elem);<br>    <span class="hljs-built_in">free</span>(pDel);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode1 = <span class="hljs-literal">NULL</span>;<br>    linkList headNode2 = <span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode1);<br>    initList(&amp;headNode2);<br>    combineList(&amp;headNode1, headNode2);<br>    printfList(headNode1);<br>    destroyLink(headNode1);<br>    destroyLink(headNode2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR (-1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType int</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ElemType elem;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node, *linkList;<br><br>status <span class="hljs-title function_">initList</span><span class="hljs-params">(linkList *headNode)</span> &#123;<br><br>    (*headNode) = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    (*headNode)-&gt;elem = <span class="hljs-number">0</span>;<br>    (*headNode)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    node *moveNode = (*headNode);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>        node *temNode = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        temNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;temNode-&gt;elem);<br>        moveNode-&gt;next = temNode;<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>&#125;<br><br>status <span class="hljs-title function_">destroyList</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode;<br>    node *deleteNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        deleteNode = moveNode;<br>        moveNode = moveNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(deleteNode);<br>        num++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>status <span class="hljs-title function_">combineList</span><span class="hljs-params">(linkList *headNode, linkList headNode2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span> || headNode2 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode1 = (*headNode)-&gt;next, *moveNode2 = headNode2-&gt;next, *moveNodeC = (*headNode);<br>    <span class="hljs-keyword">while</span> (moveNode1 != <span class="hljs-literal">NULL</span> &amp;&amp; moveNode2 != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (moveNode1-&gt;elem &gt; moveNode2-&gt;elem) &#123;<br>            moveNodeC-&gt;next = moveNode2;<br>            moveNode2 = moveNode2-&gt;next;<br>            moveNodeC=moveNodeC-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            moveNodeC-&gt;next = moveNode1;<br>            moveNode1 = moveNode1-&gt;next;<br>            moveNodeC=moveNodeC-&gt;next;<br>        &#125;<br>    &#125;<br>    moveNodeC-&gt;next = moveNode1==<span class="hljs-literal">NULL</span> ? moveNode2 : moveNode1;<br>    <span class="hljs-built_in">free</span>(headNode2);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br>status <span class="hljs-title function_">printfNode</span><span class="hljs-params">(linkList headNode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headNode == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    node *moveNode = headNode-&gt;next;<br>    <span class="hljs-keyword">while</span> (moveNode != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, moveNode-&gt;elem);<br>        moveNode = moveNode-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    linkList headNode1=<span class="hljs-literal">NULL</span>;<br>    linkList headNode2=<span class="hljs-literal">NULL</span>;<br>    initList(&amp;headNode1);<br>    initList(&amp;headNode2);<br>    printfNode(headNode1);<br>    combineList(&amp;headNode1,headNode2);<br>    printfNode(headNode1);<br>    destroyList(headNode1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda高级使用</title>
    <link href="/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/26/lambda%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="lambda高级使用"><a href="#lambda高级使用" class="headerlink" title="lambda高级使用"></a>lambda高级使用</h1><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的 this <a href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><ol><li>没有捕获的时候，我们将该lambda变量可以看成函数指针</li><li>有捕获的时候，我们将该lambda表达式堪称仿函数</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>使用<code>function</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; func&#123;[](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;&#125;;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>使用<code>bind</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">10</span>&#125;;<br>    [a,b](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;a+b&lt;&lt;std::endl&lt;&lt;x&lt;&lt;std::endl;<br>    &#125;(<span class="hljs-number">88</span>);<br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>([](<span class="hljs-type">int</span> num,std::string S)-&gt;<span class="hljs-type">void</span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; name= &quot;</span>&lt;&lt;S&lt;&lt;std::endl;<br>    &#125;,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/03/26/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/26/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li><p>通过类里函数可以给私有成员赋值，同时也可以通过函数return 出值</p></li><li><p>特殊的成员函数，主要用于创建对象时初始化对象-&gt;给对象成员赋予初值</p></li><li><p>构造函数的特点</p><ul><li>构造函数的函数名与类名相同</li><li>构造函数没有返回值类型，也没有返回值</li><li>构造函数可以重载</li></ul></li><li><p>没有写构造函数，自己会生成，由于内联函数，牺牲时间换效率</p><ul><li><p>系统给的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Myclass</span>()&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>系统给的构造函数相当于低保</p></li><li><p>构造函数，在创建时系统就会调用，不能通过对象调用构造函数</p></li><li><p>默认给的构造函数，是<code>public</code>类型</p></li><li><p><code>const</code>:改变性质，将变量变成常量</p><ul><li><p>对<code>const</code>修饰的变量在函数创建时进行赋值：</p></li><li><p>是在初始化的时候赋初值，不是在声明的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostram&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">chg</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num2;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num3;<br>    <span class="hljs-built_in">chg</span>();<br>  <span class="hljs-keyword">private</span>:  <br>&#125;;<br><br>chg::<span class="hljs-built_in">chg</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i):<span class="hljs-built_in">num1</span>(n),<span class="hljs-built_in">num2</span>(i),<span class="hljs-built_in">num3</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//括号里面可以是变量也可以是常量</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol><li>一种特殊的函数，作用是在对象的生命周期结束时进行清理，系统可以自动调用析构函数</li><li>函数名与类名一致，在前面加上<code>~</code></li><li>没有返回值，也没有参数，但必须有参数表也就是（）</li><li>有低保，没写的话，系统自动分配</li><li>可以通过外部访问到析构函数</li><li>在类创建时，自动使用一次，构造，和析构（在生命周期结束时，会自动调用析构函数）</li><li>先构造的后析构</li></ol><h2 id="拷贝构造，-函数"><a href="#拷贝构造，-函数" class="headerlink" title="拷贝构造， 函数"></a>拷贝构造， 函数</h2><ol><li><p>先是构造函数，才可能是拷贝构造函数</p></li><li><p>有低保，系统会统一给</p></li><li><p>第一个参数是，该类的对象</p><p>操作实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//构造函数</span><br>    ~<span class="hljs-built_in">Myclass</span>();<span class="hljs-comment">//析构函数</span><br>    <span class="hljs-built_in">Myclass</span>(Myclass&amp; obj);<span class="hljs-comment">//拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用时机</p><ul><li><p>使用一个对象给另一个对象进行初始化</p></li><li><p>使用一个对象构造另一个对象</p></li><li><p>函数的参数是类的对象</p></li><li><p>返回值是类</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zjy2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    zjy zjy3;<span class="hljs-comment">//进行无参构造</span><br>    <br>    <span class="hljs-keyword">return</span> zjy3;<span class="hljs-comment">//由于zjy3存在于栈区，所以函数结束会被回收，因此返回值是zjy3的复制体，此时调用了拷贝构造</span><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">zjy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> chg;<br>     <span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n);<br>     <span class="hljs-built_in">zjy</span>();<br>     ~<span class="hljs-built_in">zjy</span>();<br>     <span class="hljs-built_in">zjy</span>(zjy&amp;obj);<br>&#125;;<br> zjy::<span class="hljs-built_in">zjy</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;无参构造&quot;</span>&lt;&lt;endl;<br>&#125;<br> zjy::<span class="hljs-built_in">zjy</span>(zjy &amp;obj)<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br> zjy::~<span class="hljs-built_in">zjy</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><br> zjy::<span class="hljs-built_in">zjy</span>(<span class="hljs-type">int</span> n)<br>&#123;<br>     chg=<span class="hljs-number">520</span>;<br>     n=chg;<br>     cout&lt;&lt;n&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;带参构造函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     zjy obj;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-function">zjy <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二个代码运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201151814859.png" alt="image-20221201151814859"></p><ul><li>无参构造：<code>func</code>里面的<code>obj</code></li><li>析构函数：函数调用完会释放内存，这里释放的是第一个obj，所以调用析构函数</li><li>带参构造：43行代码</li><li>无参构造：是因为用了chg来接收</li></ul><p>由于上面结果不一致，重点参考下面的</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201152314605.png" alt="image-20221201152314605"></p><ul><li>无参构造：调用<code>test_func_2()</code>，从主调函数，进入被调函数，创建<code>Monster obj</code>采用的是无参构造</li><li>拷贝构造1号：因为需要函数返回<code>obj</code>,但是函数里面的数据在函数完成时，会被释放，所以采用拷贝构造创建的副本<code>obj</code></li><li>析构（1）：当函数完成时，释放内存，调用析构函数释放原本的<code>obj</code></li><li>析构（2）：由于没有接收<code>obj</code>,所以会在执行完76行释放返回的<code>obj</code>副本</li><li>无参构造：78行调用函数（如上的无参构造）</li><li>拷贝构造1号：如上</li><li>析构（3）：如上，第一个析构</li><li>析构（4）：这里的析构和第二个析构不一样，这里的析构是因为，<code>main</code>完成了，释放<code>monster</code>接收的<code>obj</code></li></ul></li><li><p>问题1：为什么第78行<code>Monster monster=test_func_2()</code>这里没有拷贝构造？</p><ul><li>没有东西去接收复制体时，系统会创建一个临时的对象，再用拷贝构造，将返回的<code>obj</code>，拷贝构造给临时变量</li><li>由于78行，有一个<code>monster</code>接收返回的<code>obj</code>，系统优化，直接复制给<code>monster</code>,所以不会调用拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201154807685.png" alt="image-20221201154807685"></p><ul><li>无参构造：因为这里在<code>return </code>后面创建了一个<code>zjy（匿名对象）</code>，相当于在函数外边创建了一个对象，这里不会采用拷贝构造，所以时无参构造</li><li>析构函数：因为没有接收对象，所以在49行的时候析构掉了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">zjy <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">zjy</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//func();</span><br>    zjy chg=<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221201155016536.png" alt="image-20221201155016536"></p><ul><li>无参构造：因为调用<code>test_func_2()</code>，创建了一个匿名对象，采用无参构造（和上面的无参构造一样）</li><li>析构：因为main函数结束，调用析构函数</li></ul></li></ul></li><li><p>对于指针的构造：不能直接将指针指向那个地址，而是，创建一个新的内存用于存放原有的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *q=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        p[i]=i;<span class="hljs-comment">//可以相当于创建了一个数组，对于数组的存储可以用arr[i]=int类型</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        q[i]=p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>浅拷贝和深拷贝</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202094645975.png" alt="image-20221202094645975"></p></li><li><p>如何防止默认拷贝的发生（浅拷贝）？</p><p><img src="C:\Users\12414\Desktop\笔记\c++\函数.assets\image-20221202095003679.png" alt="image-20221202095003679"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>右值和左值</title>
    <link href="/2023/03/26/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/"/>
    <url>/2023/03/26/%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="右值和左值"><a href="#右值和左值" class="headerlink" title="右值和左值"></a>右值和左值</h1><h2 id="右值左值的区分"><a href="#右值左值的区分" class="headerlink" title="右值左值的区分"></a>右值左值的区分</h2><ol><li><p>能取地址的是左值，不能取地址的是右值</p></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//左值</span><br>    <span class="hljs-type">int</span> lvalue=<span class="hljs-number">244</span>;<br>    <span class="hljs-comment">//左值引用</span><br>    <span class="hljs-type">int</span> &amp;lvalueCite=lvalue;<br>    <span class="hljs-comment">//右值</span><br>    <span class="hljs-comment">//右值引用</span><br>    <span class="hljs-type">int</span> &amp;&amp;rvalueCite=<span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用右值引用延长生命周期</p></li></ol><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><ol><li><p>作用： 复用其他对象的资源（堆内存）</p></li><li><p>实现浅拷贝 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参构造</span><br>    <span class="hljs-built_in">name1</span>()&#123;<br>        mPtr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-built_in">name1</span>(<span class="hljs-type">const</span> name1 &amp;tem)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mPtr=tem.mPtr;<br>    &#125;<br>    <span class="hljs-comment">//移动构造</span><br>    <span class="hljs-built_in">name1</span>(name1&amp;&amp; tem):<span class="hljs-built_in">mPtr</span>(tem.mPtr)<br>    &#123;<br>        tem.mPtr=<span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> * mPtr;<br>&#125;;<br><br><span class="hljs-function">name1 <span class="hljs-title">getObj</span><span class="hljs-params">()</span></span>&#123;<br>    name1 name11;<br>    *name11.mPtr=<span class="hljs-number">2</span>;<br>    std::cout&lt;&lt;name11.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> name11;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//要求右侧是个临时对象，才会调用移动拷贝构造函数</span><br>    <span class="hljs-comment">//如果没有移动拷贝构造函数，就会调用拷贝构造函数</span><br>    name1 obj=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj.mPtr&lt;&lt;std::endl;<br>    name1&amp;&amp; obj2=<span class="hljs-built_in">getObj</span>();<br>    std::cout&lt;&lt;obj2.mPtr&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*obj2.mPtr&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用 C++11 提供的 std::forward () 函数，该函数实现的功能称之为完美转发。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可调用对象包装器</title>
    <link href="/2023/03/26/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <url>/2023/03/26/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h1><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可以按照函数的方法进行调用</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>函数指针</p><blockquote><p>使用<code>using</code>进行定义函数指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>);<br></code></pre></td></tr></table></figure></li><li><p>仿函数</p></li><li><p>可以转换为函数的类对象</p></li><li><p>类成员的函数指针</p></li><li><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*这段代码定义了一个名为name1的类，其中包含两个函数testFunc和testFunc2。testFunc是静态函数，可以通过指针调用，而testFunc2是实例方法，只能通过对象调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此外，代码还定义了一个名为callBack的函数指针类型，它接受一个int类型和一个double类型的参数，并且没有返回值。在类定义中，将operator callBack()定义为转换运算符，它返回testFunc的指针，使得对象也可以像函数一样被调用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在main函数中，首先使用obj.operator callBack()将obj对象转换为callBack类型的函数指针，并将其赋值给func。然后，使用&amp;name1::testFunc将testFunc的地址赋值给func2，使用&amp;name1::testFunc2将testFunc2的地址赋值给func3。最后，使用func(1,2)调用testFunc函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">整体来说，此代码演示了如何定义和使用函数指针以及转换运算符的概念。*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">using</span> callBack=<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//callBack是定义的函数指针变量名,这一步是想将类名当作函数使用</span><br>     <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">return</span> testFunc;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">testFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testFunc2</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>         cout&lt;&lt;a+b&lt;&lt;endl;<br>     &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> callBack2=<span class="hljs-built_in">void</span>(name1::*)(<span class="hljs-type">int</span> ,<span class="hljs-type">double</span>);<br>    name1 obj;<br>    <span class="hljs-comment">//通过转换运算符</span><br>    callBack func=obj.<span class="hljs-keyword">operator</span> <span class="hljs-built_in">callBack</span>();<br>    <span class="hljs-comment">//通过函数指针</span><br>    callBack func2=&amp;name1::testFunc;<br>    <span class="hljs-comment">//callBack2是限定了作用域的函数指针，注意此处必须要有&amp;</span><br>    callBack2 func3=&amp;name1::testFunc2;<br><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="function的使用"><a href="#function的使用" class="headerlink" title="function的使用"></a><code>function</code>的使用</h2><ul><li><p>作用：说是可调用对象当作函数使用</p></li><li><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <span class="hljs-keyword">using</span> callBack = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span> a,std::string s);<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;this is func&quot;</span>&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">testStruct</span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is testStruct&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">name1</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">classFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">callBack</span> <span class="hljs-params">()</span></span>&#123;<br>          <span class="hljs-keyword">return</span> classFunc;<br>      &#125;<br>  <br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;this is classOperator()&quot;</span>&lt;&lt;std::endl;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>      <span class="hljs-comment">//调用function</span><br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>          <span class="hljs-built_in">tem</span>(a,s);<br>      &#125;<br>  <span class="hljs-keyword">private</span>:<br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>  &#125;;<br>  <br>  <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-comment">//通过函数包装器调用普通函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f1=func;<br>      <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//伪函数</span><br>      std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; f2=<span class="hljs-built_in">testStruct</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-comment">//类里面的静态函数</span><br>      f2=name1::classFunc;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;tsy&quot;</span>);<br>      <span class="hljs-comment">//通过转换运算符，将类变成了可调用对象</span><br>      name1 name;<br>      f2=name;<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<br>  <br>      <span class="hljs-comment">//尝试将function当成参数，调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint</span><span class="hljs-params">(f1)</span></span>;<br>      objPrint.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;jc&quot;</span>);<br>      <span class="hljs-comment">//因为我们的类是可调用的对象所以可以当作function</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint2</span><span class="hljs-params">(name)</span></span>;<br>      objPrint2.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;wr&quot;</span>);<br>      <span class="hljs-comment">//调用类的静态</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint3</span><span class="hljs-params">(name.classFunc)</span></span>;<br>      objPrint3.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;01&quot;</span>);<br>      <span class="hljs-comment">//普通函数调用</span><br>      <span class="hljs-function">print <span class="hljs-title">objPrint4</span><span class="hljs-params">(func)</span></span>;<br>      objPrint4.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;gzx&quot;</span>);<br>      <span class="hljs-comment">//使用伪函数时需要创建对象</span><br>      testStruct testStruct;<br>      <span class="hljs-function">print <span class="hljs-title">objPrint5</span><span class="hljs-params">(testStruct)</span></span>;<br>      objPrint5.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&quot;tcx&quot;</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>## 可调用对象绑定器<br><br>- 作用：<br>  - 将可调用对象绑定成仿函数<br>  - 将多元参数函数绑定成参数为<span class="hljs-number">1</span>，或者（n<span class="hljs-number">-1</span>）的可调用对象<br><br>- 绑定非类的实例：<br><br>  ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot; a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; s = &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,std::placeholders::_2);<br>      <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>      <span class="hljs-comment">//注意如果在bind的时候初始化了a和s则在f2(),的括号中添加的参数，没有效果</span><br>      <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(print,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;zjy&quot;</span>);<br>      <span class="hljs-built_in">f2</span>();<br>      <span class="hljs-built_in">f2</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xxp&quot;</span>);<span class="hljs-comment">//无效果</span><br>      <span class="hljs-keyword">auto</span> f3= std::<span class="hljs-built_in">bind</span>(print,std::placeholders::_1,<span class="hljs-string">&quot;xxp&quot;</span>);<br>      <span class="hljs-built_in">f3</span>(<span class="hljs-number">3</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>绑定类里的成员函数和成员变量的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functional&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;this is classFunc&quot;</span>&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; string: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;<br>    &#125;<br>    std::string s;<br>&#125;;<br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">print</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>,std::string)&gt;&amp; function1):<span class="hljs-built_in">tem</span>(function1)&#123;&#125;;<br>    <span class="hljs-comment">//调用function</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Printf</span><span class="hljs-params">(<span class="hljs-type">int</span> a,std::string s)</span></span>&#123;<br>        <span class="hljs-built_in">tem</span>(a,s);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,std::string)&gt; tem;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//类的成员函数的绑定</span><br>    myClass myclassObj1;<br>    <span class="hljs-keyword">auto</span> f1= std::<span class="hljs-built_in">bind</span>(&amp;myClass::test,&amp;myclassObj1,std::placeholders::_1,std::placeholders::_2);<br>    <span class="hljs-function">print <span class="hljs-title">frintObj1</span><span class="hljs-params">(f1)</span></span>;<br>    frintObj1.<span class="hljs-built_in">Printf</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;chg&quot;</span>);<br>    <span class="hljs-comment">//绑定类的成员变量</span><br>    <span class="hljs-keyword">auto</span> f2= std::<span class="hljs-built_in">bind</span>(&amp;myClass::s,&amp;myclassObj1);<br>    <span class="hljs-built_in">f2</span>()=<span class="hljs-string">&quot;chg&quot;</span>;<span class="hljs-comment">//对类成员赋值</span><br>    std::cout&lt;&lt;<span class="hljs-built_in">f2</span>()&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
